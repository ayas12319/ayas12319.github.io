<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git的基本使用</title>
      <link href="/2025/09/14/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/09/14/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2025/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2025/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是最小生成树"><a class="markdownIt-Anchor" href="#什么是最小生成树"></a> 什么是最小生成树：</h1><ul><li>仅仅针对于无向图；</li><li>包含了所有的顶点；</li><li>符合树的定义：连通，无环。</li><li>最小：使得边权相加的结果最小。</li></ul><p><strong>最短路径树与源起点紧密相关；而最小生成树是一个全局概念，与从何处开始无关。</strong></p><h1 id="切割属性"><a class="markdownIt-Anchor" href="#切割属性"></a> 切割属性：</h1><p>对于图集(V,  E)，将V个点分给两个非空集合，构成两个点集S，(V - S)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切割属性的定义：</span><br><span class="line"></span><br><span class="line">跨越连接两个点集的最小权重边必然包含于最小生成树中。</span><br></pre></td></tr></table></figure><hr /><p><strong>证明：</strong></p><p>设最小生成树T不包含最小权重边S = (u, v)。取而代之的是F边。</p><ol><li><p>现在构造一颗新的生成树T‘：</p></li><li><p>从T中移除F边；</p></li><li><p>然后加入我们讨论的最小权重边S；</p></li></ol><p>现在T’的总权重 = T的总权重 - weight(F) + weight(S);</p><p>又因为weight(S) &lt; weight(F)。故有T’的总权重小于T的总权重。</p><p>但我们假设的是T未最小生成树，故与题意相违背。</p><hr /><p>接下来介绍几种查找MST的算法：</p><h1 id="prim算法"><a class="markdownIt-Anchor" href="#prim算法"></a> Prim算法：</h1><h2 id="核心思想"><a class="markdownIt-Anchor" href="#核心思想"></a> 核心思想：</h2><p>在每一步，逐步连接当前已在MST中的顶点与尚未在MST中的顶点集合间的最小权重边，直至所有顶点都在MST中。</p><h2 id="算法流程"><a class="markdownIt-Anchor" href="#算法流程"></a> 算法流程：</h2><p>两个关键数组：</p><p>dist数组：维护每个顶点到<strong>当前MST集合</strong>的最小边权重；</p><p><strong><u>(注意此点与dijkstra算法的区别，dikstra算法是维护到起点单点的最短距离，prim算法维护的是到MST集合的距离。但代码其余部分基本与dijkstra算法相似)</u></strong></p><p>parent数组：记录每个新节点加入后是和哪个节点相连的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int, int&gt; PII; //(distance, node)</span><br><span class="line"></span><br><span class="line">void prim(int start int V)&#123;</span><br><span class="line"> memset(dist, int, sizeof dist);</span><br><span class="line"> memset(parent, -1, sizeof parent);</span><br><span class="line"> bool inMST[N];</span><br><span class="line"> memset(inMST, false, sizeof inMST);</span><br><span class="line"> dist[start] = 0;</span><br><span class="line"> priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line"> pq.push(&#123;0, start&#125;);</span><br><span class="line"> while(pq.size())&#123;</span><br><span class="line">   //选取当前对MST集合距离最近的点，贪心的体现。</span><br><span class="line">   int cur_node = pq.top().second;</span><br><span class="line">   pq.pop();</span><br><span class="line">   if(inMST[cur_node]) continue;</span><br><span class="line">   inMST[cur_node] = true;</span><br><span class="line">   for(auto&amp; neighbor: graph[cur_node])&#123;</span><br><span class="line">      int v = neighbor.first;</span><br><span class="line">      int weight = neight.second;</span><br><span class="line">      //不在MST中，且找到了更小权边。</span><br><span class="line">      if(!inMST[v] &amp;&amp; weight &lt; dist[v])&#123;</span><br><span class="line">         dist[v] = weight;</span><br><span class="line">         parent[v] = u;</span><br><span class="line">         pq.push(&#123;dist[v], v&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析"><a class="markdownIt-Anchor" href="#时间复杂度分析"></a> 时间复杂度分析：</h2><ul><li>初始化：O(V);</li><li>push操作：O（VlogV）[优先队列是基于二叉堆实现的]</li><li>pop操作：O (VlogV)</li><li>遍历相连边：O(E)</li><li>push更新操作：O（ElogV)</li></ul><p><strong>故总复杂度为：O((V + E) logV)</strong></p><h1 id="kruskal算法"><a class="markdownIt-Anchor" href="#kruskal算法"></a> Kruskal算法：</h1><h2 id="核心思想-2"><a class="markdownIt-Anchor" href="#核心思想-2"></a> 核心思想：</h2><ul><li>将图中的所有边按权重从小到大进行排序；</li><li>从权重最小的边开始，一次考虑每一条边；</li><li>若加入当前的环会与已选择的边之间形成环，则跳过；</li><li>当已选边数 = 顶点数 - 1时，停止循环。</li></ul><h2 id="数据结构实现基础并查集"><a class="markdownIt-Anchor" href="#数据结构实现基础并查集"></a> 数据结构实现基础(并查集)：</h2><p>并查集用来判断两个顶点是否连通，以及用来合并两个连通分量。</p><p><strong>主循环流程：</strong></p><ul><li><p>取出最小权重边；</p></li><li><p>检查环(使用并查集的find函数):</p><ul><li>若根节点相同，说明u与v已经连通，加入会构成环；</li><li>若根节点不同，说明不在同一连通快，可以加入；</li></ul></li><li><p>合并：</p><ul><li>加入MST集合；</li><li>使用union操作，将u和v的集合合并。</li></ul></li><li><p>结束：</p></li></ul><p>当MST集合中包含V - 1条边时，结束。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct Edge&#123;</span><br><span class="line"> int u, v, weight;</span><br><span class="line"> bool operator&lt;(const Edge&amp; other)&#123;</span><br><span class="line">   return weight &lt; other.weight;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line"> if(parent[x] != x)&#123;</span><br><span class="line">   parent[x] = find(parent[x]);</span><br><span class="line"> &#125;</span><br><span class="line"> return parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void union(int x, int y)&#123;</span><br><span class="line">  int rootx = find(x);</span><br><span class="line">  int rooty = find(y);</span><br><span class="line">  if(rootx == rooty) return;</span><br><span class="line">  //按秩合并</span><br><span class="line">  if(rank_[rootx] &lt; rank_[rooty])&#123;</span><br><span class="line">     parent[rootx] = rooty;</span><br><span class="line">  &#125;</span><br><span class="line">  else if(rank_[rootx] &gt; rank_[rooty])&#123;</span><br><span class="line">     parent[rooty] = rootx;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123; //相等时，任意合并，但秩要增加</span><br><span class="line">     parent[rootx] = rooty;</span><br><span class="line">     rank_[rooty]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int kruskal(int V, vector&lt;Edge&gt;&amp; edges)&#123;</span><br><span class="line">  sort(edges.begin(), edges.end());</span><br><span class="line">  //初始化并查集相关数组</span><br><span class="line">  for(int i = 0; i &lt; V; ++i)&#123;</span><br><span class="line">     parent[i] = i;</span><br><span class="line">     rank_[i] = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int mstweight = 0;</span><br><span class="line">  int usededges = 0;</span><br><span class="line">  for(Edge&amp; e: edges)&#123;</span><br><span class="line">     if(usededges == V - 1)&#123;</span><br><span class="line">        break;</span><br><span class="line">     &#125;</span><br><span class="line">     int rootU = find(e.u);</span><br><span class="line">     int rootV = find(e.v);</span><br><span class="line">     if(rootU != rootV)&#123; //合并</span><br><span class="line">       union(rootU, rootV);</span><br><span class="line">       mstweight += e.weight;</span><br><span class="line">       usededges ++;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return mstweight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析-2"><a class="markdownIt-Anchor" href="#时间复杂度分析-2"></a> 时间复杂度分析：</h2><p>由于压缩路径后的并查集操作均为反阿克曼函数，均可视为常数</p><p>故主要是排序的O(ElogV);</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="/2025/09/11/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2025/09/11/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历：</h1><h2 id="广度优先搜索"><a class="markdownIt-Anchor" href="#广度优先搜索"></a> 广度优先搜索：</h2><h3 id="核心思想"><a class="markdownIt-Anchor" href="#核心思想"></a> 核心思想：</h3><p>一层层地向外扩展，先访问起点的相邻节点，再访问相邻节点的相邻节点…</p><h3 id="数据结构实现基础"><a class="markdownIt-Anchor" href="#数据结构实现基础"></a> 数据结构实现基础：</h3><p>队列：用来存储遍历到了，但还没有访问其所有邻接节点的节点。其先进先出的结构符合一层层传递的特性。</p><h3 id="代码框架"><a class="markdownIt-Anchor" href="#代码框架"></a> 代码框架：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; edges[N];</span><br><span class="line">void bfs(int st, int target)&#123;</span><br><span class="line"> int vis[N];</span><br><span class="line"> memset(vis, 0, sizeof vis);</span><br><span class="line"> queue&lt;int&gt; a;</span><br><span class="line"> a.push(st);</span><br><span class="line"> vis[st] = 1;</span><br><span class="line"> while(a.size())&#123;</span><br><span class="line">   int q = a.front();</span><br><span class="line">   a.pop();</span><br><span class="line">   if(q == target) return;</span><br><span class="line">   for(int i = 0; i &lt; edges[q].size(); ++i)&#123;</span><br><span class="line">       int now = edges[q][i];</span><br><span class="line">       if(!vis[now])&#123;</span><br><span class="line">         vis[now] = 1;</span><br><span class="line">         a.push(now);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bfs的特点就决定了其可以找到最短路径：(<strong>当路径没有权重</strong>)</p><p>由于其是一层层遍历的，第一次找到了目标点，即是最短路径。</p><h2 id="深度优先搜索"><a class="markdownIt-Anchor" href="#深度优先搜索"></a> 深度优先搜索：</h2><h3 id="核心思想-2"><a class="markdownIt-Anchor" href="#核心思想-2"></a> 核心思想：</h3><p>就是一条路走到黑，直到当前节点没有未遍历的节点为止，才开始进行回溯。</p><h3 id="数据结构实现基础-2"><a class="markdownIt-Anchor" href="#数据结构实现基础-2"></a> 数据结构实现基础：</h3><p>栈：在迭代过程中自动实现，其后进先出的特点，正好满足了优先探索最新节点的需求。</p><h3 id="代码框架-2"><a class="markdownIt-Anchor" href="#代码框架-2"></a> 代码框架：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector edges[N];</span><br><span class="line">int vis[N];</span><br><span class="line">void dfs(int idx)&#123;</span><br><span class="line">  if(vis[idx])&#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[idx] = 1;</span><br><span class="line">  for(int i = 0; i &lt; edges[idx].size(); ++i)&#123;</span><br><span class="line">        dfs(edges[idx][i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时两者的性能比较"><a class="markdownIt-Anchor" href="#运行时两者的性能比较"></a> 运行时两者的性能比较：</h2><ul><li>对于细长图，dfs明显更差，迭代递归次数过多，容易造成爆栈问题；</li><li>对于bushy图，bfs明显更差，队列会被大量使用。</li></ul><p><strong>对于bfs查找最短路径时的问题：</strong></p><p>相对更短路径定义模糊，当边存在权重时，更短的定义往往根据题意而定。</p><p>所以当路径有权重时，我们还需要设计另一种算法来计算。</p><h1 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法"></a> Dijkstra算法：</h1><h2 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤：</h2><p>1，创建优先级队列；</p><p>2，将起点s以优先级0加入priority_queue;</p><p>​      将其他所有点以优先级inf加入priority_queue;</p><p>3，当队列不为空时，弹出顶点，并松弛从顶点出发的所有边。</p><h2 id="核心思想-3"><a class="markdownIt-Anchor" href="#核心思想-3"></a> 核心思想：</h2><p><strong>贪心算法+松弛操作；</strong></p><p><strong>1，全局的最优路径可以不断地通过局部最优路径累计得到；</strong></p><p>​    原理：当目前弹出的顶点是V1，说明V1目前是距离start最近的点。若后续操作中V1到start的距离可以被进一步更新，则说明必定存在V2到start的距离更短，前后相矛盾。</p><p><strong>2，松弛操作：通过不断更新和改进估计的距离最优值，逼近最优策略；</strong></p><p>​    具体：记现在的dist[now]为最佳距离，遍历当前队列弹出的顶点ver的所有边，检查是否有dist[ver] + weight[ver] [now] &lt; dist[now]，然后用来更新dist[now]的值。</p><p><strong>NOTICE: 我们不会再用其他顶点来松弛已访问过的顶点的，因为它的最短距离已经确定过了，无需再次更新。</strong></p><h2 id="代码框架实现"><a class="markdownIt-Anchor" href="#代码框架实现"></a> 代码框架实现：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int, int&gt; PII;  //(distance, node)</span><br><span class="line">vector&lt;vector&lt;PII&gt;&gt; graph;</span><br><span class="line">bool st[N];</span><br><span class="line">void dijkstra(int s, vector&lt;int&gt;&amp; dist)&#123;</span><br><span class="line">   int n = graph.size();</span><br><span class="line">   for(int i = 0; i &lt; n;++i)&#123;</span><br><span class="line">      dist[i] = inf;</span><br><span class="line">   &#125;</span><br><span class="line">   dist[s] = 0;</span><br><span class="line">   priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">   pq.push(&#123;0, s&#125;);</span><br><span class="line">   while(pq.size())&#123;</span><br><span class="line">     int node = pq.top().second;</span><br><span class="line">     int dis = pq.top().first;</span><br><span class="line">     pq.pop();</span><br><span class="line">     if(st[node]) continue;</span><br><span class="line">     st[node] = true;</span><br><span class="line">     for(int i = 0; i &lt; graph[node].size(); ++i)&#123;</span><br><span class="line">       int cur_node = graph[node][i].second;</span><br><span class="line">       int cur_weight = graph[node][i].first;</span><br><span class="line">       if(dist[node] + cur_weight &lt; dist[cur_node])&#123;</span><br><span class="line">          dist[cur_node] = dist[node] + cur_weight;</span><br><span class="line">          pq.push(&#123;dist[cur_node], cur_node&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊情况"><a class="markdownIt-Anchor" href="#特殊情况"></a> 特殊情况：</h2><p>当出现负权边时，该算法不成立。因为负权边的存在使得 **”““当前弹出的点的最小距离不会再次改变”“**这点不成立。因为有可能前半段距离很长，但突然经过一个负权边补偿后，举例又变小。</p><h1 id="a算法"><a class="markdownIt-Anchor" href="#a算法"></a> A*算法：</h1><p>A *本质上是Dijkstra的一种启发式改进。如果说Dijkstra算法是一种从source以同心圆的形式逐步一圈圈向外扩散。那么A *算法则是给定一个大致的前进方向，大大缩减了需要遍历检查的节点数量。</p><h2 id="核心思想-4"><a class="markdownIt-Anchor" href="#核心思想-4"></a> 核心思想：</h2><p>为每一个节点计算一个代价函数F(n)，并以代价函数作为优先级来比较。</p><p>F(n) = G(n) + H(n);</p><ul><li>G(n)：从起始点到当前节点的准确距离；</li><li>H(n)：从当前节点n到目标节点的预估成本。通常采用直线距离或曼哈顿距离。</li><li>F(n)：通过节点n的路径的预估总成本。</li></ul><h2 id="具体代码框架"><a class="markdownIt-Anchor" href="#具体代码框架"></a> 具体代码框架：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;double, int&gt; PII;  //(f_score, 节点)</span><br><span class="line">vector&lt;vector&lt;PII&gt;&gt; graph;</span><br><span class="line">bool st[N];</span><br><span class="line">int g[N];</span><br><span class="line">int came_from[N];</span><br><span class="line">double get_dist(int a, int b)&#123;</span><br><span class="line">  return num ;  //结合具体计算直线距离...</span><br><span class="line">&#125;</span><br><span class="line">void A_star(int start, int goal, vector&lt;int&gt;&amp; path)&#123;</span><br><span class="line">    int n = graph.size();</span><br><span class="line">    memset(g, inf, sizeof g);</span><br><span class="line">    memset(came_from, -1, sizeof came_from);</span><br><span class="line">    g[start] = 0;</span><br><span class="line">    double f_score = g[start] + get_dist(start, goal);</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123;f_score, start&#125;);</span><br><span class="line">    while(pq.size())&#123;</span><br><span class="line">       double current_f = pq.top().first;</span><br><span class="line">       int node = pq.top().second;</span><br><span class="line">       pq.pop();</span><br><span class="line">       if(st[node]) continue;</span><br><span class="line">       st[node] = true;</span><br><span class="line">       //记录路径</span><br><span class="line">       if(node == goal)&#123;</span><br><span class="line">          path.clear();</span><br><span class="line">          for(int node = goal; node != -1; node = came_from[node])&#123;</span><br><span class="line">             path.push_back(node);</span><br><span class="line">          &#125;</span><br><span class="line">          reverse(path.begin(), path.end());</span><br><span class="line">          return;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       for(int i = 0; i &lt; graph[node].size(); ++i)&#123;</span><br><span class="line">          int edge_weight = graph[node][i].first;</span><br><span class="line">          int neighbor = graph[node][i].second;</span><br><span class="line">          if(st[neighbor]) continue;</span><br><span class="line">          if(g[node] + edge_weight &lt; g[neighbor])&#123;</span><br><span class="line">             g[neighbor] = g[node] + edge_Weight;</span><br><span class="line">             double f_score = g[neighbor] + get_dist(neighbor, goal);</span><br><span class="line">             pq.push(&#123;f_score, neighbor&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：A*算法同样无法处理负权边的图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的遍历与图</title>
      <link href="/2025/09/10/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/"/>
      <url>/2025/09/10/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>什么是树：</p><p>1，一组连接的节点；</p><p>2，连接这些节点的一组边；</p><p>​      (限制：没有一组边可以形成一个循环。即从一个节点到任意另一个节点没有第二条路径)；</p><p>树的遍历方式：</p><p>考虑到树的分支结构，对于树的遍历(迭代)有以下两种方式：</p><p>1, level_order遍历：广度优先搜索(BFS)</p><p>2, 深度优先遍历(DFS): 其中有三种方式前序，中序，后序。</p><p>以下面这个树为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    D</span><br><span class="line">   / \</span><br><span class="line">  B   F</span><br><span class="line"> / \   \</span><br><span class="line">A   C   G</span><br></pre></td></tr></table></figure><p>前序遍历：</p><p>基本思路：打印出当前节点；向左走，递归；向右走，递归；</p><p>遵循这个逻辑，将得到顺序D B A C F G。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preOrder(Node x)&#123;</span><br><span class="line">  if(x == null) return;</span><br><span class="line">  print(x.key);</span><br><span class="line">  preOrder(x.left);</span><br><span class="line">  preOrder(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><p>假设我们当前处于D，知道向左遍历会打印出左节点，向右遍历会得到右节点。又已知我们想要得到的顺序为： [左起项目] D [右起项目]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inOrder(Node x)&#123;</span><br><span class="line">  if(x == null) return;</span><br><span class="line">  inorder(x.left);</span><br><span class="line">  print(x.key);</span><br><span class="line">  inorder(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><p>按照我们刚刚提到的思路，我们目标想要得到的顺序为：[D左起项目] [D右起项目] D</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postOrder(Node x)&#123;</span><br><span class="line">   if(x == null) return;</span><br><span class="line">   postOrder(x.left);</span><br><span class="line">   postOrder(x.right);</span><br><span class="line">   print(x.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图：</p><p>组成：</p><p>1，一组节点；</p><p>2，一组边，每条边连接两个节点。</p><p>与树的关键区别在于：<strong>图中没有限制</strong>。边可以形成环，两个顶点之间也可以有多条路径。</p><p>图的实现：</p><p>1，邻接矩阵：</p><p>核心思想：</p><p>用邻接矩阵–一个二维数组。</p><ul><li>如果图中存在从顶点 <code>i</code> 到顶点 <code>j</code> 的边，那么 <code>matrix[i][j] = 1</code>（或边的权重）。</li><li>如果不存在这条边，那么 <code>matrix[i][j] = 0</code>（或一个特殊值，如无穷大 <code>∞</code>）。</li></ul><p>优点：</p><p>查询连接关系快: O(1);</p><p>添加删除关系快：O(1);</p><p>缺点：</p><p>占用空间大：即使图很稀疏，也需要V^2的空间。</p><p>遍历邻接点慢：找到顶点V的，必须扫描整个第V行。</p><p>2，邻接表：</p><p>核心思想：</p><p>为每一个顶点都维护一个链表/数组：</p><p>存储所有与该顶点直接相连的邻接节点。</p><p>优点：</p><p>1，空间效率高：O(V + E).</p><p>2, 遍历邻接点快。</p><p>缺点：</p><p>查询路径是否存在慢，需要逐步遍历链表并迭代。</p><p>边列表：</p><p>核心思想：</p><p>直接用一个数组存储图中的所有边。U和V之间有权重为W的边，则直接有m[U] [V] = W;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern SQL(MySQL为例)</title>
      <link href="/2025/09/09/Modern-SQL/"/>
      <url>/2025/09/09/Modern-SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="sql由三种类别命令组成"><a class="markdownIt-Anchor" href="#sql由三种类别命令组成"></a> SQL由三种类别命令组成：</h1><p>1，数据操作语言(DML): SELECT、INSERT、UPDATE 和 DELETE 语句。</p><p>2，数据定义语言(DDL)：表、索引、视图和其他对象的架构定义。</p><p>3，数据控制语言(DCL)：安全性，控制访问。</p><p>关系模型基于的是Set(有序，不可重复)；而SQL基于的是bag(无序，可重复)。</p><h1 id="关系模型"><a class="markdownIt-Anchor" href="#关系模型"></a> 关系模型：</h1><h2 id="主键"><a class="markdownIt-Anchor" href="#主键"></a> 主键：</h2><p>在关系数据库中，一张表的一行数据被称为一条记录。一条记录由多个字段组成。</p><p>对于关系表，有一个重要约束：任意两条记录不能重复。</p><p>不能重复并非指内容不能完全相同，而是能通过某一字段唯一区分出不同的记录，这个字段称为 “主键”。</p><h3 id="主键的选取原则"><a class="markdownIt-Anchor" href="#主键的选取原则"></a> 主键的选取原则：</h3><p>不能使用业务相关的字段作为主键。</p><p>常用的可作为id字段的类型有：</p><p>1，自增整数类型：记录插入时，系统自动发配一个自增整数。</p><p>2，全局唯一GUID类型：通过GUID算法，保证任一生成的均不同。</p><h3 id="联合主键"><a class="markdownIt-Anchor" href="#联合主键"></a> 联合主键：</h3><p>还允许多个字段来唯一标识一条记录，只要不是所有主键列均重复即可。</p><h2 id="外键"><a class="markdownIt-Anchor" href="#外键"></a> 外键：</h2><h3 id="一对多"><a class="markdownIt-Anchor" href="#一对多"></a> 一对多：</h3><p>在使用主键唯一确定一条记录后，我们可以在student表中确定任意一个学生的记录。我们还可以在class表中确定任意一个班级信息。那么我们如何确定某一个学生是属于哪一个班级的？</p><p>因为一个班级可以拥有多个学生，属于一对多关系。</p><p>故需要再student表中加入class_id，反映与class表的对应关系。</p><p><strong>这种可以把数据与另外一张表相关联的列，称为外键。</strong></p><p>外键不是通过加新列实现的，而是通过定义外键约束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id  //指定外键约束的名称为fk_class_id.</span><br><span class="line">FOREIGN KEY (class_id)   //指定class_id作为外键</span><br><span class="line">REFERENCES classes (id); //指定这个外键将关联到classes表的id列。</span><br></pre></td></tr></table></figure><p>删除一个外键约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意删除外键约束，只是删掉了关联关系，并没有删掉这一列。</p><p>删除列是通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP COLUMN ....</span><br></pre></td></tr></table></figure><p>来实现的</p><h3 id="多对多"><a class="markdownIt-Anchor" href="#多对多"></a> 多对多：</h3><p>例如一个班级可以对应多个老师，一个老师可以对应多个班级。</p><p>多对多关系的实现，实际上通过一个中间表实现的。中间表将实际对应关系一个个阐明清楚。</p><h3 id="一对一"><a class="markdownIt-Anchor" href="#一对一"></a> 一对一：</h3><p>实际需要：如在存储学生的联系方式时，可能某个学生没有联系方式，则这个学生在contacts表中就没有对应的记录。</p><h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引：</h2><p>对于关系数据库中的大量记录，使用索引可以在查询时加速。</p><p>索引是一种对某一列或多列进行预排列的数据结构。</p><h3 id="索引的创建"><a class="markdownIt-Anchor" href="#索引的创建"></a> 索引的创建：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score(score);</span><br></pre></td></tr></table></figure><p>创建了一个名为idx_score，使用列score的索引。</p><p>索引支持多列。</p><h3 id="索引的效率"><a class="markdownIt-Anchor" href="#索引的效率"></a> 索引的效率：</h3><p>该列的值越不相同，索引的查询效率就越高。</p><p>索引的优点：增快了查询速度；</p><p>索引的缺点：在插入，更新，删除记录时，同时也要改变索引。因此索引越多，其他操作越慢。</p><p>主键的索引效率是最高的。</p><h3 id="唯一索引"><a class="markdownIt-Anchor" href="#唯一索引"></a> 唯一索引：</h3><p>在设计表时，那些看上去唯一的列，如身份证号，由于具有业务相关性，不能充当索引，此时就可以为这一列加上唯一索引，使得这一列的数值不能出现重复。</p><p>主键是特殊的唯一索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>此例通过unique关键词添加了唯一索引。</p><p>通过添加唯一约束，也可实现相同效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT uni_name UNIQUE (name);</span><br></pre></td></tr></table></figure><h1 id="查询数据"><a class="markdownIt-Anchor" href="#查询数据"></a> 查询数据：</h1><h2 id="基本查询"><a class="markdownIt-Anchor" href="#基本查询"></a> 基本查询：</h2><h3 id="查询students表的所有数据"><a class="markdownIt-Anchor" href="#查询students表的所有数据"></a> 查询students表的所有数据：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt;</span><br></pre></td></tr></table></figure><p><strong>SELECT为查询的关键字； * 表示所有列；FROM表示从哪个表中进行查询。</strong></p><h3 id="without-from子句的select操作"><a class="markdownIt-Anchor" href="#without-from子句的select操作"></a> without FROM子句的SELECT操作：</h3><ul><li><p>SELECT语句可以进行简单计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 100+200</span><br><span class="line">&gt; 300</span><br></pre></td></tr></table></figure></li><li><p>用来判断当前到数据库的连接是否有效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1;</span><br></pre></td></tr></table></figure></li></ul><h2 id="条件查询"><a class="markdownIt-Anchor" href="#条件查询"></a> 条件查询：</h2><h3 id="通过where条件语句来设定查询条件"><a class="markdownIt-Anchor" href="#通过where条件语句来设定查询条件"></a> 通过where条件语句来设定查询条件：</h3><p>例如：查找指定分数在80以上的学生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><p>故条件查询的基本语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; where &lt;条件&gt;</span><br></pre></td></tr></table></figure><h3 id="多个条件的书写"><a class="markdownIt-Anchor" href="#多个条件的书写"></a> 多个条件的书写：</h3><ul><li>符合条件1和条件2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE &lt;条件1&gt; AND &lt;条件2&gt;</span><br></pre></td></tr></table></figure><ul><li>符合条件1或条件2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE &lt;条件1&gt; OR &lt;条件2&gt;</span><br></pre></td></tr></table></figure><ul><li><p>组合三个及以上的条件语句：</p><p>用()表示如何进行运算。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE (score &lt; 80 AND score &gt; 90) AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用的条件表达式"><a class="markdownIt-Anchor" href="#常用的条件表达式"></a> 常用的条件表达式：</h3><table><thead><tr><th>条件</th><th>举例</th><th>说明</th></tr></thead><tbody><tr><td>判断相等使用=</td><td>name = ’xiong_mi_lan‘</td><td>字符串需要用单引号括起来</td></tr><tr><td>使用&lt;&gt;判断不相等</td><td>score &lt;&gt; 80</td><td></td></tr><tr><td>使用LIKE判断相似</td><td>name LIKE ‘ab%’</td><td>%表示任意字符。例中将匹配：‘ab’, ‘abc’, ‘abcd’…</td></tr></tbody></table><h2 id="投影查询"><a class="markdownIt-Anchor" href="#投影查询"></a> 投影查询：</h2><p>以上的SELECT * 我们所得到的都是二维表。</p><p>若我们只想要得到某些列的数据。我们可以采用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列1，列2，列3 FROM ...</span><br></pre></td></tr></table></figure><p>这种操作被称为投影查询。</p><h3 id="重命名"><a class="markdownIt-Anchor" href="#重命名"></a> 重命名：</h3><p>使用投影查询时，我们还可以给每一列起一个别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列1 别名1，列2 别名2 FROM ...</span><br></pre></td></tr></table></figure><h3 id="where语句投影查询"><a class="markdownIt-Anchor" href="#where语句投影查询"></a> where语句+投影查询：</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序：</h2><h3 id="order-by-语句"><a class="markdownIt-Anchor" href="#order-by-语句"></a> ORDER BY 语句：</h3><p>当我们使用SELECT查询时，默认是按照id从小到大进行排序的。</p><p>ORDER BY 语句支持我们自定义排序依据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, gender, score FROM students ORDER BY score;</span><br></pre></td></tr></table></figure><h3 id="倒序的实现"><a class="markdownIt-Anchor" href="#倒序的实现"></a> <strong>倒序的实现：</strong></h3><p>可以在句末加上DESC关键字，进行从大到小排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure><p>升序的关键字是：ASC。默认省略</p><h3 id="对于存在相同数据的处理"><a class="markdownIt-Anchor" href="#对于存在相同数据的处理"></a> <strong>对于存在相同数据的处理：</strong></h3><p>可以继续添加列名，进行进一步的排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score, gender FROM students ORDER BY score DESC, id DESC;</span><br></pre></td></tr></table></figure><p>先按照score的倒序排序，score相同时，再按照id的倒序排序。</p><p><strong>补充：</strong></p><p>ORDER BY 语句位置应处于句末。****</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC</span><br></pre></td></tr></table></figure><h2 id="分页查询"><a class="markdownIt-Anchor" href="#分页查询"></a> 分页查询：</h2><p>对于很大的数据量，放在同一个页面，画面未免有些太过拥挤，不如分页展示。</p><p><strong>基本语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 最多几条记录 OFFSET 从哪条开始(start)</span><br></pre></td></tr></table></figure><p><strong>start的计算公式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start = pageSize * (pageIndex - 1)</span><br></pre></td></tr></table></figure><p>假如一页最多三条记录，查询第二页的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score</span><br><span class="line">LIMIT 3 OFFSET 3;</span><br></pre></td></tr></table></figure><p><strong>简写形式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 15 OFFSET 30，还可以简写为 LIMIT 30, 15。</span><br></pre></td></tr></table></figure><h2 id="聚合查询"><a class="markdownIt-Anchor" href="#聚合查询"></a> 聚合查询：</h2><p>统计总记录数，计算平均数，使用聚合函数可以得到快速的查询。</p><p>查询总数可以使用count函数：</p><h3 id="查询所有列的行数"><a class="markdownIt-Anchor" href="#查询所有列的行数"></a> 查询所有列的行数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM students</span><br></pre></td></tr></table></figure><p><strong>注意：查询的结果其实仍是一个二维表，只是为1行1列，并且列名为COUNT(*)。</strong></p><p>所以通常查询时会设置一个别名，表示统计结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students;</span><br></pre></td></tr></table></figure><p>同样可以使用WHERE语句进行条件判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students </span><br><span class="line">WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><h3 id="其他聚合函数"><a class="markdownIt-Anchor" href="#其他聚合函数"></a> 其他聚合函数：</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的合计值，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算平均值，必须为数值类型</td></tr><tr><td>MAX</td><td>计算某列最大值</td></tr><tr><td>MIN</td><td>计算某列最小值</td></tr></tbody></table><h3 id="分组聚合"><a class="markdownIt-Anchor" href="#分组聚合"></a> 分组聚合：</h3><p>若我们想要知道每一班的总人数分别是多少，可以使用GROUP BY函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, COUNT(*) num FROM students </span><br><span class="line">GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>按照class_id来分组，统计人数。</p><h2 id="多表查询"><a class="markdownIt-Anchor" href="#多表查询"></a> 多表查询：</h2><h3 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表1&gt;, &lt;表2&gt;；</span><br></pre></td></tr></table></figure><p>返回的是一个二维表，表1与表2的合并结果。每一行都两两拼接而成。</p><h3 id="设置别名"><a class="markdownIt-Anchor" href="#设置别名"></a> 设置别名</h3><p>在通常下我们会设置别名来进行统一区分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    students.id sid,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><p>多表查询时可以使用<strong>表名.列名</strong> 的形式来设置引用列。</p><h2 id="连接查询"><a class="markdownIt-Anchor" href="#连接查询"></a> 连接查询：</h2><p>是另一种类型的的多表查询。</p><p>实质上就是对于多个表进行join操作：</p><p>先确定一个主表作为结果集，然后把其他表的行有选择性地连在主表结果集上。</p><h3 id="inner-join"><a class="markdownIt-Anchor" href="#inner-join"></a> INNER JOIN:</h3><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 选出所有学生，同时返回对应的班级名称</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.gender</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">on s.classes_id = c.id;</span><br></pre></td></tr></table></figure><p><strong>INNER JOIN查询的语法为</strong>：</p><p>1，先确定主表，仍然使用SELECT FROM 语句</p><p>2，确定需要连接的表，INNER JOIN &lt;表2&gt;</p><p>3，确定连接条件，使用 on &lt;条件…&gt;</p><p><strong>特点：</strong></p><p><strong>返回的结果只会有同时存在于两张表中的行数据。</strong></p><h3 id="right-outer-join"><a class="markdownIt-Anchor" href="#right-outer-join"></a> RIGHT OUTER JOIN:</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S.id, S.name, S.class_id, C.name class_name</span><br><span class="line">FROM students S</span><br><span class="line">RIGHT OUTER JOIN classes C</span><br><span class="line">ON C.class_id = C.id;</span><br></pre></td></tr></table></figure><p><strong>RIGHT OUTER JOIN 返回右表中都存在的行，若某行仅在右表中存在，则会以NULL填充剩余字段。</strong></p><p><u>LEFT OUTER JOIN 同理类推。</u></p><p><u>FULL OUTER JOIN 同理会返回两张表的所有记录，并填充NULL进对方不存在的列。</u></p><h1 id="修改数据"><a class="markdownIt-Anchor" href="#修改数据"></a> 修改数据：</h1><h2 id="插入数据"><a class="markdownIt-Anchor" href="#插入数据"></a> 插入数据：</h2><p><strong>基本语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1，字段2，字段3,...) VALUES (值1，值2，值3...)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;xiaoming&#x27;, &#x27;M&#x27;, 80);</span><br></pre></td></tr></table></figure><p>还可以一次性添加多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line"> (1, &#x27;ONE&#x27;, &#x27;M&#x27;, 87),</span><br><span class="line"> (2, &#x27;TWO&#x27;, &#x27;M&#x27;, 90);</span><br></pre></td></tr></table></figure><h2 id="更新数据"><a class="markdownIt-Anchor" href="#更新数据"></a> 更新数据：</h2><p>更新表中<strong>已存在</strong>记录的值。</p><p><strong>基本语法：(UPDATE语句)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1=值1，字段2=值2，字段3=值3，...WHERE...;</span><br></pre></td></tr></table></figure><p>例如：更新id = 1的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students SET name=&#x27;xiaoming&#x27;, score=66 WHERE id=1;</span><br></pre></td></tr></table></figure><p>当没有WHERE语句时，默认修改的是全表。</p><h2 id="删除数据"><a class="markdownIt-Anchor" href="#删除数据"></a> 删除数据：</h2><p>删除数据使用DELETE语句：</p><p><strong>基本语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt; WHERE ...;</span><br></pre></td></tr></table></figure><p>例如删除id=1的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM students WHERE id=1;</span><br></pre></td></tr></table></figure><p>同样没有WHERE语句时，会删除整个表。</p><h1 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> MYSQL:</h1><h2 id="管理mysql"><a class="markdownIt-Anchor" href="#管理mysql"></a> 管理MySQL:</h2><h3 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库：</h3><p>在一个mysql服务器上，可以创建多个数据库。</p><h4 id="枚列"><a class="markdownIt-Anchor" href="#枚列"></a> 枚列：</h4><p>可以通过命令 SHOW DATABASES，列出所有的数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| shici              |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">| school             |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p><h4 id="创建数据库"><a class="markdownIt-Anchor" href="#创建数据库"></a> 创建数据库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test;</span><br></pre></td></tr></table></figure><h4 id="删除数据库"><a class="markdownIt-Anchor" href="#删除数据库"></a> 删除数据库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE test;</span><br></pre></td></tr></table></figure><h4 id="切换当前数据库"><a class="markdownIt-Anchor" href="#切换当前数据库"></a> 切换当前数据库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br></pre></td></tr></table></figure><h3 id="表"><a class="markdownIt-Anchor" href="#表"></a> 表：</h3><h4 id="列出当前数据库的所有表"><a class="markdownIt-Anchor" href="#列出当前数据库的所有表"></a> 列出当前数据库的所有表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_test      |</span><br><span class="line">+---------------------+</span><br><span class="line">| classes             |</span><br><span class="line">| statistics          |</span><br><span class="line">| students            |</span><br><span class="line">| students_of_class1  |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h4 id="查看一个表的结构"><a class="markdownIt-Anchor" href="#查看一个表的结构"></a> 查看一个表的结构：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC students；</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| class_id | bigint(20)   | NO   |     | NULL    |                |</span><br><span class="line">| name     | varchar(100) | NO   |     | NULL    |                |</span><br><span class="line">| gender   | varchar(1)   | NO   |     | NULL    |                |</span><br><span class="line">| score    | int(11)      | NO   |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="创建表"><a class="markdownIt-Anchor" href="#创建表"></a> 创建表：</h4><p>CREATE TABLE &lt;表名&gt;；</p><h4 id="删除表"><a class="markdownIt-Anchor" href="#删除表"></a> 删除表：</h4><p>DROP TABLE &lt;表名&gt;；</p><h4 id="修改表"><a class="markdownIt-Anchor" href="#修改表"></a> 修改表：</h4><h5 id="新增一列"><a class="markdownIt-Anchor" href="#新增一列"></a> 新增一列：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">ADD COLUMN 列名 数据类型 [约束条件] [位置];</span><br></pre></td></tr></table></figure><p>例如：</p><p>新增一列数据类型为VARCHAR(10)，不为空的birth列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure><h5 id="修改列"><a class="markdownIt-Anchor" href="#修改列"></a> 修改列：</h5><p>将ADD关键字改为CHANGE即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">CHANGE COLUMN 列名 数据类型 [约束条件] [位置];</span><br></pre></td></tr></table></figure><h5 id="删除列"><a class="markdownIt-Anchor" href="#删除列"></a> 删除列：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">DROP COLUMN 列名;</span><br></pre></td></tr></table></figure><h3 id="退出mysql"><a class="markdownIt-Anchor" href="#退出mysql"></a> 退出MySQL:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXIT</span><br></pre></td></tr></table></figure><p><u>注意EXIT仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</u></p><h2 id="实用sql语句"><a class="markdownIt-Anchor" href="#实用sql语句"></a> 实用SQL语句：</h2><h3 id="插入或替换"><a class="markdownIt-Anchor" href="#插入或替换"></a> 插入或替换：</h3><p>插入新记录，若存在则替换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO 表名 (字段1，字段2...) VALUES (值1，值2...);</span><br></pre></td></tr></table></figure><h3 id="插入或更新"><a class="markdownIt-Anchor" href="#插入或更新"></a> 插入或更新：</h3><p>插入新记录，若存在则更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段1，字段2...) VALUES (值1，值2...);</span><br></pre></td></tr></table></figure><h3 id="插入或忽略"><a class="markdownIt-Anchor" href="#插入或忽略"></a> 插入或忽略：</h3><p>插入新纪录，若存在则忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO 表名 (字段1，字段2...) VALUES (值1，值2...);</span><br></pre></td></tr></table></figure><h3 id="快照"><a class="markdownIt-Anchor" href="#快照"></a> 快照：</h3><p>复制当前的表的数据到一个新表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 新表名 SELECT * FROM 表名 WHERE...</span><br></pre></td></tr></table></figure><h3 id="创建查询结果集"><a class="markdownIt-Anchor" href="#创建查询结果集"></a> 创建查询结果集：</h3><p>例：创建统计成绩的表，记录各班的平均成绩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE anser(</span><br><span class="line">   id BIGINT NOT NULL AUTO_INCREMENT(自动递增，生成唯一id),</span><br><span class="line">   class_id BIGINT NOT NULL,</span><br><span class="line">   average DOUBLE NOT NULL,</span><br><span class="line">   PRIMARY KEY (id) (设置主键为id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="cte语句-公用表表达式"><a class="markdownIt-Anchor" href="#cte语句-公用表表达式"></a> CTE语句-公用表表达式：</h2><p>CTE是一个临时的结果集，一个临时的视图，只在它所在的语句中生效。是嵌套结构的优化版</p><h3 id="基本语法-2"><a class="markdownIt-Anchor" href="#基本语法-2"></a> 基本语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WITH 为这个结果集起的名字 [column_name[列名1，列名2...]] AS(</span><br><span class="line">--CTE的查询定义</span><br><span class="line">SELECT...</span><br><span class="line">)</span><br><span class="line">--主查询，使用上面定义的临时结果集</span><br><span class="line">SELECT * FROM 结果集名;</span><br></pre></td></tr></table></figure><p>WITH关键字表示开始一个CTE语句块。</p><h3 id="用法"><a class="markdownIt-Anchor" href="#用法"></a> 用法：</h3><h4 id="基本用法避免复杂的嵌套"><a class="markdownIt-Anchor" href="#基本用法避免复杂的嵌套"></a> 基本用法(避免复杂的嵌套):</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WITH avg_salary AS (</span><br><span class="line">   SELECT AVG(salary) AS avg_sal FROM employees</span><br><span class="line">)</span><br><span class="line">SELECT</span><br><span class="line">  e.name,</span><br><span class="line">  e.salary,</span><br><span class="line">  a.avg_sal</span><br><span class="line">FROM employees e, avg_salary a</span><br><span class="line">WHERE e.salary &gt;a.avg_sal;</span><br></pre></td></tr></table></figure><h4 id="递归用法"><a class="markdownIt-Anchor" href="#递归用法"></a> 递归用法：</h4><p>计算从1到10 的和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WITH RECURSIVE cte_re (counter) AS (</span><br><span class="line">  (SELECT 1)    ---锚定成员，产生初始结果集，递归起点，只执行一次</span><br><span class="line">  UNION         -----合并结果集。</span><br><span class="line">  (SELECT counter + 1 FROM cte_re  --递归成员，查询上一次的counter结果，并执行+1操作</span><br><span class="line">   WHERE counter &lt; 10)</span><br><span class="line">)</span><br><span class="line">SELECT * FROM cte_re;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一)概论</title>
      <link href="/2025/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2025/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机的层次结构"><a class="markdownIt-Anchor" href="#计算机的层次结构"></a> 计算机的层次结构：</h2><p>软件在不同机器上运行的根本区别是所需要的指令集的不同。</p><p>越靠近底层的语言，效率越高----能充分发挥硬件的优良特性。</p><h2 id="基本框架"><a class="markdownIt-Anchor" href="#基本框架"></a> 基本框架：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">高级语言----------&gt;虚拟机器M3</span><br><span class="line"></span><br><span class="line">​      |编译</span><br><span class="line"></span><br><span class="line">汇编语言---------&gt;虚拟机器M2</span><br><span class="line"></span><br><span class="line">操作系统----------&gt;虚拟机器</span><br><span class="line"></span><br><span class="line">机器语言---------&gt; 实际机器M1</span><br><span class="line"></span><br><span class="line">微指令系统-------&gt;微程序机器 (在CPU中的CU(control unit)中执行)</span><br></pre></td></tr></table></figure><p><strong>操作系统是软硬件的分界线。(分界线并非一成不变，两者可能互相转化)</strong></p><h3 id="计算机体系结构"><a class="markdownIt-Anchor" href="#计算机体系结构"></a> 计算机体系结构：</h3><p>(如：有无浮点运算指令)</p><p>程序员所见到的计算机系统的属性。概念性的结构与功能特性。(汇编语言)</p><p>(指令系统，数据类型，寻址技术，I/O机理)</p><h3 id="计算机组成"><a class="markdownIt-Anchor" href="#计算机组成"></a> 计算机组成：</h3><p>(如：具体如何实现浮点运算指令)</p><p>实现计算机体系结构所体现的属性。</p><h2 id="计算机基本组成"><a class="markdownIt-Anchor" href="#计算机基本组成"></a> 计算机基本组成：</h2><h4 id="冯诺依曼体系"><a class="markdownIt-Anchor" href="#冯诺依曼体系"></a> 冯.诺依曼体系：</h4><p><strong>1，计算机由五大部件组成；</strong></p><p><strong>2，指令和数据以同等地位存于存储器，可按地址访问。</strong></p><p><strong>3，指令和数据用二进制表示；</strong></p><p><strong>4，指令由操作码和地址码组成；</strong></p><p><strong>5，存储程序方式；</strong></p><p><strong>6，以运算器为中心；(现代是存储器为中心)</strong></p><p>​                         存储器</p><p>​                            |  |</p><p>输入设备-------&gt;运算器----------&gt;输出设备</p><p>​                            |   |</p><p>​                          控制器</p><h4 id="现代硬件"><a class="markdownIt-Anchor" href="#现代硬件"></a> 现代硬件：</h4><ul><li>主机<ul><li>cpu<ul><li>运算器(ALU)</li><li>控制器(CU)</li></ul></li><li>存储器<ul><li>主存</li><li>辅存</li></ul></li></ul></li><li>I/O<ul><li>输入设备</li><li>输出设备</li></ul></li></ul><p>指令格式：</p><p>操作码(6位) + 地址码(10位) 【共16位----2字节】【指令的长短不固定】</p><p><strong>运算器的基本组成和操作过程：</strong></p><p>在一个芯片上，在存储玩主要功能的电路后，可以留有空间来<strong>暂时</strong>存储数据。这些空间就叫做寄存器。</p><p>![屏幕截图 2025-09-11 182348](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-11 182348.png)</p><p>上图中的空白部分，就可以刻入寄存器。</p><p>ACC: l累加器；</p><p>MQ：乘商寄存器；</p><p>X：操作数寄存器；</p><p>这些统称为寄存器。</p><p>操作过程中数据的存储：</p><p>![屏幕截图 2025-09-11 182740](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-11 182740.png)</p><p>以上过程中这些部件的分配均由CU支配。运算的过程就在ALU中进行。</p><p>那又是如何按照时间序列一步步执行的：</p><p>![屏幕截图 2025-09-11 183033](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-11 183033.png)</p><p>初始状态先把被加数从X中取到ACC中；(加载)</p><p>把加法指令给ALU，激活加法电路。</p><p>将另一个加数从地址码中取出。</p><p>将相加的结果存进ACC中。</p><p><strong>存储器：</strong></p><p>基本组成：</p><p>存储单元(0/1) —&gt; 存储单元-----&gt; 存储体</p><p>存储单元：存放一串二进制代码（最小为8个字节）</p><p>存储字：存储单元中二进制代码的组合；</p><p>存储字长：存储单元中二进制代码的位数。</p><p>MAR：存放准备访问的数据的地址。位数反映单元的个数。(2^k个)</p><p>MDR：存放存储器读出或写入的代码或数据，位数反映存储字长。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和优先队列</title>
      <link href="/2025/09/09/%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>/2025/09/09/%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="优先级队列"><a class="markdownIt-Anchor" href="#优先级队列"></a> 优先级队列：</h2><p>是一种ADT，定义了一下的接口：</p><ul><li>插入：向队列中加入一个带有优先级的元素；</li><li>remove操作：提取出队列中优先级最高的元素，并删除。</li></ul><h2 id="堆的引入"><a class="markdownIt-Anchor" href="#堆的引入"></a> 堆的引入：</h2><table><thead><tr><th>操作\数据结构</th><th>有序数组</th><th>hash数组</th><th>bushy BST</th></tr></thead><tbody><tr><td>add</td><td>O(N)</td><td>O(1)</td><td>O(logN)</td></tr><tr><td>get_smallest</td><td>O(1)</td><td>O(N)</td><td>O(logN)</td></tr><tr><td>remove_smallest</td><td>O(N)</td><td>O(N)</td><td>O(logN)</td></tr></tbody></table><p>从现在看来实现优先级队列的最优结构是BST。</p><p>但是否可以对BST进行进一步的优化？</p><p>我们知道BST中，左儿子 &lt;= 父节点，我们若想要得到最小值，我们还要遍历一遍左子树[ O(logN) ]；那么我们可不可以在这个的基础上进行优化，定义一种min-heap，将优先级最高的作为父节点，那么我们进行提取时就能实现为O（1）的复杂度。</p><h2 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆：</h2><p><strong>以min-heap为例，属性如下：</strong></p><ul><li>每个节点都小于等于它的子节点；</li><li>若在叶子节点处缺少项目，所有节点都进可能偏左。</li></ul><p><strong>如何在这种堆模式下，实现以上的三种操作呢？</strong></p><ul><li><p><strong>add:</strong></p><p>将新值临时添加到堆的末尾，再按照规定的排序方式，递归地插入到应该所处的位置。</p></li><li><p><strong>getSmallest：</strong></p><p>返回根节点即可。</p></li><li><p><strong>removeSmallest：</strong></p><p>将堆的最后一项交换到根节点，再递归地调整树的结构即可。</p></li></ul><p><strong>新的问题-----这种树的实现，应该基于什么定义呢？</strong></p><p>一般的BST定义：(基于指针树的定义)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tree&#123;</span><br><span class="line">   int node;</span><br><span class="line">   int value;</span><br><span class="line">   tree* lson;</span><br><span class="line">   tree* rson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们考虑一种新的定义形式----（基于数组）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于a[i], 左儿子为a[i * 2],右儿子为a[i * 2 + 1]。</span><br><span class="line">在查找父节点时，直接a[i / 2]即可。</span><br></pre></td></tr></table></figure><p><strong>优势性：</strong></p><p>具有空间上的紧凑性，简洁性，缓存友好型。</p><p>例如对于一个完全二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    10         a[1]</span><br><span class="line">   /  \</span><br><span class="line">  5    15      a[2], a[3]</span><br><span class="line"> / \   /</span><br><span class="line">2   7 12       a[4], a[5]</span><br></pre></td></tr></table></figure><p>用数组存下来为：</p><p>a[  ] = [null, 10, 5, 15, 2, 7, 12]；正好符合这种数组的形式。</p><p><u><em>注意：根节点的node是从1开始的。</em></u></p><p><strong>那么为什么这种简洁的形式不适用于描述BST？</strong></p><p>—<strong>因为堆一般都是完全二叉树形式，一层层是紧挨着，填满的。</strong></p><p>而BST却不一定，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>若强行用数组存储会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     5         a[1]</span><br><span class="line">   /    \</span><br><span class="line">  3      8      a[2], a[3]</span><br><span class="line"> / \    /  \</span><br><span class="line">1  NULL NULL NULL      a[4], a[5], a[6], a[7]</span><br></pre></td></tr></table></figure><p>a[5], a[6], a[7]均是被浪费的空间。</p><p><strong>那么树的形式实现了，我们回到具体操作的实现上来：</strong></p><p>我们发现到，以上三个操作均有一个核心操作：递归调整数的结构：</p><p>代码实现如下：</p><ul><li><strong>向下调整：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> t = u;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= sizes &amp;&amp; tree[<span class="number">2</span> * u] &lt; tree[t])&#123; <span class="comment">//在边界范围内，且不符合建树规则</span></span><br><span class="line">      t = <span class="number">2</span> * u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span> * u <span class="number">+1</span> &lt;= sizes &amp;&amp; tree[u * <span class="number">2</span> + <span class="number">1</span>] &lt; tree[t])&#123;</span><br><span class="line">      t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">     <span class="built_in">swap</span>(tree[t], tree[u]);</span><br><span class="line">     <span class="built_in">down</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>向上调整：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void up(int u)&#123;</span><br><span class="line">   while(u / 2 &amp;&amp; tree[u] &lt; tree[u / 2])&#123;</span><br><span class="line">      swap(tree[u], tree[u / 2]);</span><br><span class="line">      u /= 2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>add:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree[++sizes] = new_val;</span><br><span class="line">up(sizes);</span><br></pre></td></tr></table></figure><ul><li><strong>remove:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree[1] = tree[sizes];</span><br><span class="line">sizes --;</span><br><span class="line">down(1);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（一，引入；关系模型和代数）</title>
      <link href="/2025/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%8C%E5%BC%95%E5%85%A5%EF%BC%9B%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BB%A3%E6%95%B0%EF%BC%89/"/>
      <url>/2025/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%8C%E5%BC%95%E5%85%A5%EF%BC%9B%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BB%A3%E6%95%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库管理系统dbms"><a class="markdownIt-Anchor" href="#数据库管理系统dbms"></a> 数据库管理系统（DBMS）：</h2><p>DBMS 是一种允许应用程序在数据库中存储和分析信息的软件。</p><p>DBMS 允许根据某些数据模型来定义，创建，查询，更新，管理数据库。</p><h2 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型：</h2><p>是一种描述数据库中数据的概念的集合：</p><p>实例：关系，NoSQL(键/值，文档，图形)，数组/矩阵/向量(用于机器学习)</p><h3 id="关系数据模型"><a class="markdownIt-Anchor" href="#关系数据模型"></a> 关系数据模型：</h3><p>关系数据模型定义了基于关系的数据库抽象概念，以避免更新数据库而要重写代码的开销。</p><h4 id="关系模型三个原则"><a class="markdownIt-Anchor" href="#关系模型三个原则"></a> 关系模型三个原则：</h4><p>1，用简单的数据结构来存储数据；</p><p>2，物理存储方式由 DBMS 的具体实现来决定。</p><p>3，只通过 sql 语言接受数据，DBMS 找出来最佳的执行策略。</p><h4 id="关系模型定义三个概念"><a class="markdownIt-Anchor" href="#关系模型定义三个概念"></a> 关系模型定义三个概念：</h4><p>1，结构：关系的定义及其内容。关系具有的属性，以及这些属性可以包含的值</p><p>2，完整性：确保数据库的内容满足约束。如：year 属性的值必须均为数字</p><p>3，操作：如何访问和修改数据库的内容</p><p>元组是关系中的一组属性值。每个属性都可以有特殊值 NULL，这表示该属性是未定义的。</p><p>具有 n 个属性的关系被称为 n 元关系。n 元关系相当于具有 n 列的表。</p><h4 id="key"><a class="markdownIt-Anchor" href="#key"></a> key:</h4><h5 id="主键"><a class="markdownIt-Anchor" href="#主键"></a> 主键：</h5><p>一个关系的主键独一无二地标识这一个元组。有些 DBMS 会自动创建内部主键。</p><h5 id="外键"><a class="markdownIt-Anchor" href="#外键"></a> 外键：</h5><p>指定一个关系中的属性必须映射到另一个关系中的元组。例如：在专辑表中包含艺术家的 ID，这个 ID 就可以关联到这个艺术家的作品。</p><h2 id="数据操作语言dml"><a class="markdownIt-Anchor" href="#数据操作语言dml"></a> 数据操作语言（DML）：</h2><p>从数据库中存储和检索信息的方法。</p><p>1，过程性：以 set 或 bag 来查找所需结果。例如：通过 for 循环遍历所有结果，以记录总的结果数。（关系代数）</p><p>2，非过程性（声明性）：仅定义想要查询的数据。而不指定查询方式。</p><h3 id="关系代数"><a class="markdownIt-Anchor" href="#关系代数"></a> 关系代数：</h3><p>关系代数是通过关系，检索和操作元组的集合。每一种操作都接受一种或多种关系，然后输出一个新关系。通过连接这些操作，我们可以实现查询的编写。</p><ul><li><h5 id="select"><a class="markdownIt-Anchor" href="#select"></a> select：</h5></li></ul><p>接受一个关系，并从该关系中输出满足选择谓词的元组的子集。我们可以通过连词和析取来组合多个谓词。</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mspace width="1em"></mspace><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>c</mi><mi>t</mi><mspace width="1em"></mspace><mo>(</mo><mi>R</mi><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">\sigma \quad predict\quad ®;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">p</span></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span><br />示例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mspace width="1em"></mspace><msub><mi>a</mi><mi>i</mi></msub><mi>d</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>a</mi><msup><mn>2</mn><mrow><mi mathvariant="normal">′</mi></mrow></msup><mspace width="1em"></mspace><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma \quad a_id='a2'\quad ®</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mord"><span class="mspace quad"></span><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">a</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></p><ul><li><h5 id="projection"><a class="markdownIt-Anchor" href="#projection"></a> projection:</h5></li></ul><p>接受一个关系，并输出一个新的临时关系。可以重新排列输入关系中属性的顺序，和对值进行操作。</p><p>语法: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mspace width="1em"></mspace><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mn>2</mn><mo separator="true">,</mo><mi>A</mi><mn>3</mn><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mspace width="1em"></mspace><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\pi \quad A1,A2,A3…\quad ®</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">A</span></span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">A</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathit">A</span><span class="mord mathrm">3</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span><br />示例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mspace width="1em"></mspace><msub><mi>b</mi><mi>i</mi></msub><mi>d</mi><mo>−</mo><mn>1</mn><mn>0</mn><mn>0</mn><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mi>d</mi><mspace width="1em"></mspace><mo>(</mo><mi>σ</mi><mspace width="1em"></mspace><msub><mi>a</mi><mi>i</mi></msub><mi>d</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>a</mi><msup><mn>2</mn><mrow><mi mathvariant="normal">′</mi></mrow></msup><mspace width="1em"></mspace><mo>(</mo><mi>R</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\pi \quad b_id-100,a_id\quad (\sigma \quad a_id='a2'\quad ®)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mspace quad"></span><span class="mord mathit">b</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mord"><span class="mspace quad"></span><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">a</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br />解释：在 a_id 为 a2 的关系表中，将 b_id 的值都-100，然后排列顺序变为：b_id 在第一列，a_id 在第二列。</p><p>SQL: SELECT b_id-100, a_id FROM R WHERE a_id = ‘a2’</p><ul><li><h5 id="union"><a class="markdownIt-Anchor" href="#union"></a> union:</h5></li></ul><p>接受两个关系并输出一个关系（取并集）。两个输入关系必须具备完全相同的属性。</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>∪</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R \cup S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">∪</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span><br />SQL 中：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo>)</mo><mspace width="1em"></mspace><mi>U</mi><mi>N</mi><mi>I</mi><mi>O</mi><mi>N</mi><mspace width="1em"></mspace><mi>A</mi><mi>L</mi><mi>L</mi><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(SELECT * FROM\quad R)\quad UNION\quad ALL(SELECT * FROM\quad S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mclose">)</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.10903em;">U</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">A</span></span><span class="mord mathit">L</span><span class="mord mathit">L</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span></span></span></span></p><p>注意：union 自动去重，union all 不会去重；</p><ul><li><h5 id="intersection"><a class="markdownIt-Anchor" href="#intersection"></a> intersection:</h5></li></ul><p>输出两个关系的交集：</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>∩</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R \cap S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">∩</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span><br />SQL: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo>)</mo><mi>I</mi><mi>N</mi><mi>T</mi><mi>E</mi><mi>R</mi><mi>S</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(SELECT * FROM\quad R) INTERSECT (SELECT * FROM\quad S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span></span></span></span></p><ul><li><h5 id="差集"><a class="markdownIt-Anchor" href="#差集"></a> 差集：</h5></li></ul><p>输出不同的元组集合</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R-S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span><br />SQL: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo>)</mo><mi>E</mi><mi>X</mi><mi>C</mi><mi>E</mi><mi>P</mi><mi>T</mi><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(SELECT * FROM\quad R) EXCEPT (SELECT * FROM\quad S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span></span></span></span></p><ul><li><h5 id="product"><a class="markdownIt-Anchor" href="#product"></a> product:</h5></li></ul><p>将两个关系表进行笛卡尔积后，输出结果。</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mspace width="1em"></mspace><mi>X</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R\quad X\quad S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span></span></span></span><br />SQL: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo>)</mo><mi>C</mi><mi>R</mi><mi>O</mi><mi>S</mi><mi>S</mi><mspace width="1em"></mspace><mi>J</mi><mi>O</mi><mi>I</mi><mi>N</mi><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo><mspace width="1em"></mspace><mi>o</mi><mi>r</mi><mspace width="1em"></mspace><mi>s</mi><mi>i</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>y</mi><mspace width="1em"></mspace><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo separator="true">,</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">(SELECT * FROM\quad R) CROSS\quad JOIN (SELECT * FROM\quad S)\quad or\quad simply\quad SELECT * FROM\quad R, S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.09618em;">J</span></span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">o</span></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">s</span></span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span></p><ul><li><h5 id="join"><a class="markdownIt-Anchor" href="#join"></a> join：</h5></li></ul><p>输出的关系包含所有元组，这些元组是两个元组的组合(重复的合并，单有的加上)。</p><p>基于相同的值进行连接。</p><p>语法：(R ▷◁ S)</p><p>SQL: SELECT * FROM R JOIN S ON (合并条件…)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本学期自学目标</title>
      <link href="/2025/09/08/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E8%87%AA%E5%AD%A6%E7%9B%AE%E6%A0%87/"/>
      <url>/2025/09/08/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E8%87%AA%E5%AD%A6%E7%9B%AE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<ul><li><p>常微分方程与偏微分方程:</p><ul><li><a href="https://ocw.mit.edu/courses/18-04-complex-variables-with-applications-spring-2018/">Complex Variables with Applications | Mathematics | MIT OpenCourseWare</a>（前置复变函数知识）</li><li><a href="https://ocw.mit.edu/courses/18-03sc-differential-equations-fall-2011/pages/unit-i-first-order-differential-equations/">Unit I: First Order Differential Equations | Differential Equations | Mathematics | MIT OpenCourseWare</a>（常微分方程）</li><li><a href="https://ocw.mit.edu/courses/18-152-introduction-to-partial-differential-equations-fall-2011/">Introduction to Partial Differential Equations | Mathematics | MIT OpenCourseWare</a>（偏微分方程建模与求解）</li></ul></li><li><p>数据库系统:</p><ul><li><a href="https://15445.courses.cs.cmu.edu/spring2023/schedule.html">时间表 |CMU 15-445/645 ：： 数据库系统简介（2023 年春季） — Schedule | CMU 15-445/645 :: Intro to Database Systems (Spring 2023)</a>（作业）</li><li><a href="https://www.youtube.com/playlist?list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf">YouTube</a>（视频）</li></ul></li><li><p>吴恩达-机器学习：</p><p><a href="https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.337.search-card.all.click</a></p></li><li><p>csapp：</p><ul><li><a href="https://www.bilibili.com/video/BV1cD4y1D7uR/%EF%BC%88%E4%B8%AD%E6%96%87%E6%A6%82%E8%A6%81%E8%AE%B2%E8%A7%A3%EF%BC%89">https://www.bilibili.com/video/BV1cD4y1D7uR/（中文概要讲解）</a></li><li><a href="https://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O’Hallaron</a>（课程的project）</li></ul></li><li><p>每日练习一种新算法</p></li><li><p>算法分析与进阶：</p><p><a href="https://ocw.mit.edu/courses/6-046j-design-and-analysis-of-algorithms-spring-2015/">Design and Analysis of Algorithms | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></p></li><li><p>英语六级</p></li><li><p>蓝桥杯省奖</p></li><li><p>数学竞赛</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 目标规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2025/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/"/>
      <url>/2025/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="公共概念"><a class="markdownIt-Anchor" href="#公共概念"></a> 公共概念：</h1><h3 id="基本定义"><a class="markdownIt-Anchor" href="#基本定义"></a> 基本定义：</h3><p>具有相同类型的n个元素的有限序列，称为线性表；<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mrow><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">k_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">+</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的前驱元素；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mrow><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">k_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>称为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">k_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03148em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mbin">−</span><span class="mord mathrm">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>的后继元素。</p><h3 id="基本运算"><a class="markdownIt-Anchor" href="#基本运算"></a> 基本运算：</h3><p>查找；插入；删除；其他。（合并，排列，统计…)</p><h1 id="模块二实例"><a class="markdownIt-Anchor" href="#模块二实例"></a> 模块二：实例：</h1><h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组：</h2><ul><li><h3 id="数组的类实现"><a class="markdownIt-Anchor" href="#数组的类实现"></a> 数组的类实现：</h3></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       Type * elements;</span><br><span class="line">       <span class="type">int</span> ArraySize;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">get_Array</span><span class="params">()</span></span>;  <span class="comment">//动态分配存储空间</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Array</span>(<span class="type">int</span> size); <span class="comment">//根据大小构造函数</span></span><br><span class="line">       <span class="built_in">Array</span>(<span class="type">const</span> Array&lt;Type&gt; &amp;x);  <span class="comment">//复制构造函数</span></span><br><span class="line">       ~<span class="built_in">Array</span>()&#123;  <span class="comment">//析构函数</span></span><br><span class="line">           <span class="keyword">delete</span> []elements;</span><br><span class="line">       &#125;</span><br><span class="line">       Array&lt;Type&gt; &amp; <span class="keyword">operator</span> = (<span class="type">const</span> Array&lt;Type&gt;&amp;A);  <span class="comment">//数组复制</span></span><br><span class="line">       Type&amp; <span class="keyword">operator</span> [](<span class="type">int</span> i);  <span class="comment">//获取特定元素</span></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ArraySize;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="type">int</span> now_size;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> Array&lt;Type&gt; ::<span class="built_in">get_Array</span>()&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[ArraySize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Array</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;MLE&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ArraySize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArraySize = size;</span><br><span class="line">    <span class="built_in">get_Array</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> Array&lt;Type&gt;:: <span class="built_in">Array</span>(<span class="type">const</span> Array &lt;Type&gt;&amp; x)&#123;</span><br><span class="line">    Arraysize = x.ArraySize;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[ArraySize];</span><br><span class="line">    Type* target = x.elements;</span><br><span class="line">    Type* obj = elements;</span><br><span class="line">    <span class="type">int</span> n = ArraySize;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        *obj ++ = *target ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="数组的顺序存储方式"><a class="markdownIt-Anchor" href="#数组的顺序存储方式"></a> 数组的顺序存储方式：</h3></li></ul><p>数组的顺序存储方式就是能够根据下标，计算出对应地址，进而提取对应对象的基础。</p><ol><li>一维数组与二维数组：</li></ol><p>若令s = sizeof (datatype)，则一维地址表达式为：</p><p>&amp;a[i] = &amp;a[0] + i * s;</p><ol start="2"><li><p>二维数组的存储有两种方式：</p><p>2.1. 行序优先方式：</p><p>​        对于二维数组 a[ t1 ] [ t2 ] ，表达式为：</p><p>​        &amp;a[ i ] [ j ] = &amp;a[ 0 ] [ 0 ] + ((i * t2) + j) * s；</p><p>2.2.列序优先方式：</p><p>​       对于二维数组a [ t1 ] [ t2 ],表达式为：</p><p>​       &amp;a[ i ] [ j ] = &amp;a[ 0 ] [ 0 ] + ((j * t1) + i) * s ;</p></li><li><p>三维数组与n维数组：</p><p>对于三维数组a[ t1 ] [ t2 ] [ t3 ]，可以理解为由t1个二维数组a[ t2 ] [ t3]组合而成的长方体。</p><p>其表达式为：</p><p>&amp;a[ i ] [ j ] [ k ] = &amp;a[ 0 ] [ 0 ] [0 ] + ((i * t2 *t3) + (j * t3) + k) *s;</p></li></ol><p>​       故推广后易知，n维数组的表达式为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mrow><msub><mi>c</mi><mi>n</mi></msub><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi>c</mi><mi>j</mi></msub><mo>=</mo><msub><mi>t</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⋅</mo><msub><mi>c</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mtd><mtd><mrow><mo>(</mo><mn>1</mn><mo>⩽</mo><mi>j</mi><mo>&lt;</mo><mi>n</mi><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{cases}<br />c_n = 1 \<br />c_j = t_{j+1} \cdot c_{j+1} &amp; (1 \leqslant j &lt; n)<br />\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.75em;"></span><span class="strut bottom" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="mopen style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist"><span style="top:-0.6819999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord mathrm">1</span></span></span><span style="top:0.7579999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist"><span style="top:0.7579999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mrel amsrm">⩽</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mrel">&lt;</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi mathvariant="normal">&amp;</mi><mi>a</mi><mo>[</mo><msub><mi>t</mi><mn>1</mn></msub><mo>]</mo><mo>[</mo><msub><mi>t</mi><mn>2</mn></msub><mo>]</mo><mo>⋯</mo><mo>[</mo><msub><mi>t</mi><mi>n</mi></msub><mo>]</mo><mo>=</mo><mi mathvariant="normal">&amp;</mi><mi>a</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>⋯</mo><mo>[</mo><mn>0</mn><mo>]</mo></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><msub><mi>i</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>t</mi><mn>2</mn></msub><mo>⋅</mo><msub><mi>t</mi><mn>3</mn></msub><mo>⋯</mo><msub><mi>t</mi><mi>n</mi></msub><mo>⋅</mo><mi>s</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><msub><mi>i</mi><mn>2</mn></msub><mo>⋅</mo><msub><mi>t</mi><mn>3</mn></msub><mo>⋯</mo><msub><mi>t</mi><mi>n</mi></msub><mo>⋅</mo><mi>s</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><mo>⋯</mo></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><msub><mi>i</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⋅</mo><msub><mi>t</mi><mi>n</mi></msub><mo>⋅</mo><mi>s</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><msub><mi>i</mi><mi>n</mi></msub><mo>⋅</mo><mi>s</mi></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}<br />&amp;amp;a[t_1][t_2]\cdots[t_n] = &amp;amp;a[0][0]\cdots[0] &amp;+ i_1 \cdot t_2 \cdot t_3 \cdots t_n \cdot s \<br />&amp;+ i_2 \cdot t_3 \cdots t_n \cdot s \<br />&amp;+ \cdots \<br />&amp;+ i_{n-1} \cdot t_n \cdot s \<br />&amp;+ i_n \cdot s<br />\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:3.25em;"></span><span class="strut bottom" style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">&amp;</span><span class="mord mathit">a</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">]</span><span class="minner">⋯</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">]</span><span class="mrel">=</span><span class="mord mathrm">&amp;</span><span class="mord mathit">a</span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="minner">⋯</span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="col-align-l"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="minner">⋯</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord mathit">s</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="minner">⋯</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord mathit">s</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="minner">⋯</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord mathit">s</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></p><ol start="4"><li><p>三角矩阵与带状矩阵：</p><ul><li>将三角矩阵进行存储时（上下三角），为了节省空间，只会存储三角部分。</li></ul><p>​       地址的计算推导如下：</p><p>\begin{align*}\&a[i][0] &= \&a[0][0] + s \cdot \sum_{k=1}^{i} k = \&a[0][0] + \frac{i(i+1)}{2} \cdot s \\\\\&a[i][j] &= \&a[i][0] + j \cdot s \\\\\&a[i][j] &= \&a[0][0] + \left[\frac{i(i+1)}{2} + j\right] \cdot s\end{align*}</p><ul><li><p>带状矩阵：</p><p>对于n阶矩阵，若只有以最长对角线为中心区域存在非零元素，则将该矩阵称为带状矩阵。</p><p>设上，下方区域均有b条对角线，则称该矩阵的带宽为(2b + 1)。</p><p>在存储时，只存储带状区域元素。存储方式如下：</p><p><u>第一行与最后一行不变，将其他行均当做有(2b+1)个元素进行存储</u>。对于进行补齐的元素，不进行存取操作。</p><p>故可得到地址表达式为：</p><p>&amp;a [ i ] [ j ] = &amp;a [ 0 ] [ 0 ] + [(2b+1) *i + j] * s</p></li></ul></li></ol><ul><li><p>稀疏矩阵：</p><ul><li><p>引入：若矩阵中0元素个数远大于非0元素个数，为了避免空间的浪费，有必要进行矩阵的压缩存储。以下为两种压缩存储方式：</p></li><li><p><u>设i行j列有一个元素a[ i ] [ j ].我们可以将其写成三元组数组的形式：(i,  j,  a[ i ] [ j ])。</u>并用新的二维数组进行存储。<u>存储顺序为行号的递增顺序。</u></p><p>例如稀疏矩阵：<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mn>1</mn><mn>2</mn></mrow></mtd><mtd><mrow><mn>1</mn><mn>5</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>3</mn><mn>6</mn></mrow></mtd><mtd><mrow><mn>4</mn><mn>6</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>5</mn><mn>2</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>7</mn><mn>2</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>6</mn><mn>8</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{matrix}<br />12 &amp; 15 &amp; 0 &amp; 0 \<br />0 &amp; 0 &amp; 0 &amp; 0\<br />36 &amp; 46 &amp; 0 &amp; 52\<br />0 &amp; 0 &amp; 0 &amp; 0 \<br />0 &amp; 72 &amp; 0 &amp; 68<br />\end{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:3.25em;"></span><span class="strut bottom" style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">2</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">6</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">5</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">4</span><span class="mord mathrm">6</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">7</span><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">2</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">6</span><span class="mord mathrm">8</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span><br />转换结果：</p><table><thead><tr><th style="text-align:center">5</th><th style="text-align:center">4</th><th style="text-align:center">7</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">12</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">36</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">46</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">52</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">72</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">3</td><td style="text-align:center">68</td></tr></tbody></table><p>第一行表示总行数，总列数，总元素个数。</p></li><li><p>转换后矩阵的运算：</p></li></ul><p>​       矩阵转置：即将i 与 j 调换即可。为了避免转置后是递增性，提取的顺序按照原列号的递增顺序进行。</p></li></ul><h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表：</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数模a题模型积累及应用</title>
      <link href="/2025/09/03/%E6%95%B0%E6%A8%A1a%E9%A2%98%E6%A8%A1%E5%9E%8B%E7%A7%AF%E7%B4%AF%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2025/09/03/%E6%95%B0%E6%A8%A1a%E9%A2%98%E6%A8%A1%E5%9E%8B%E7%A7%AF%E7%B4%AF%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="微分方程及差分方程"><a class="markdownIt-Anchor" href="#微分方程及差分方程"></a> 微分方程及差分方程</h1><p>偏微分方程（热传导问题）</p><h1 id="优化算法"><a class="markdownIt-Anchor" href="#优化算法"></a> 优化算法</h1><h2 id="现代优化算法"><a class="markdownIt-Anchor" href="#现代优化算法"></a> 现代优化算法</h2><h3 id="模拟退火算法"><a class="markdownIt-Anchor" href="#模拟退火算法"></a> 模拟退火算法：</h3><h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理：</h4><p>来源于固体退火原理，为一种基于概率的算法。将固体加热至充分，再<strong>徐徐</strong>冷却。徐徐冷却时，粒子在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。</p><h4 id="具体过程"><a class="markdownIt-Anchor" href="#具体过程"></a> 具体过程：</h4><p><img src="C:%5CUsers%5CLENOVO%5CPictures%5Ceecbcc6e4ca230adfdd1076ff30f2d52.png" alt="eecbcc6e4ca230adfdd1076ff30f2d52" /></p><h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点：</h4><p>其核心在于以一定概率接受一个比当前解更差的邻域解。概率为：<br /><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>=</mo><msup><mi>e</mi><mrow><mo>−</mo><mo>(</mo><msub><mi>e</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>−</mo><msub><mi>e</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>)</mo><mi mathvariant="normal">/</mi><mi>T</mi></mrow></msup></mrow><annotation encoding="application/x-tex">p = e^{-(e_{new} - e_{old})/T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:1.0824399999999998em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mrel">=</span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathit mtight">e</span><span class="msupsub"><span class="vlist"><span style="top:0.143em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped mtight"><span class="mord scriptscriptstyle cramped mtight"><span class="mord mathit mtight">n</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathit mtight">e</span><span class="msupsub"><span class="vlist"><span style="top:0.15122857142857138em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped mtight"><span class="mord scriptscriptstyle cramped mtight"><span class="mord mathit mtight">o</span><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">d</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose mtight">)</span><span class="mord mathrm mtight">/</span><span class="mord mathit mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p><h4 id="python代码实现模拟退火算法解决旅行商问题"><a class="markdownIt-Anchor" href="#python代码实现模拟退火算法解决旅行商问题"></a> python代码实现模拟退火算法，解决旅行商问题：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_energy</span>(<span class="params">path, distance_matrix</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    num_cities = <span class="built_in">len</span>(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_cities):</span><br><span class="line">        total += distance_matrix[path[i]][path[(i + <span class="number">1</span>) % num_cities]] <span class="comment">##还要返回起点</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过交换两个城市的位置产生新解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">current_path</span>):</span><br><span class="line">    new_path = current_path.copy()</span><br><span class="line">    i, j = random.sample(<span class="built_in">range</span>(<span class="built_in">len</span>(current_path)), <span class="number">2</span>)</span><br><span class="line">    new_path[i], new_path[j] = new_path[j], new_path[i]</span><br><span class="line">    <span class="keyword">return</span> new_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution_tsp</span>(<span class="params">distance_matrix, T_max, T_min, alpha, max_iter</span>):</span><br><span class="line">    <span class="comment">#初始化：</span></span><br><span class="line">    num_cities = <span class="built_in">len</span>(distance_matrix)</span><br><span class="line">    current_path = <span class="built_in">list</span>(<span class="built_in">range</span>(num_cities))  <span class="comment">##0 ~ n-1 随机排列</span></span><br><span class="line">    random.shuffle(current_path)  <span class="comment">##打乱</span></span><br><span class="line">    current_energy = calc_energy(current_path, distance_matrix)</span><br><span class="line">    </span><br><span class="line">    T = T_max</span><br><span class="line">    best_path = current_path</span><br><span class="line">    best_energy = current_energy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> T &gt; T_min:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">            <span class="comment">#a ,打乱产生新解：</span></span><br><span class="line">            new_path = generate(current_path)</span><br><span class="line">            new_energy = calc_energy(new_path, distance_matrix)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> new_energy &lt; current_energy:</span><br><span class="line">                current_path = new_path</span><br><span class="line">                current_energy = current_energy</span><br><span class="line">                <span class="keyword">if</span> new_energy &lt; best_energy:</span><br><span class="line">                    best_path = new_path</span><br><span class="line">                    best_energy = new_energy</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#新解更差，概率接受:</span></span><br><span class="line">                p = math.exp(-(new_energy - current_energy) / T)</span><br><span class="line">                <span class="keyword">if</span> random.random() &lt; p:</span><br><span class="line">                    current_path = new_path</span><br><span class="line">                    current_energy = new_energy</span><br><span class="line">                </span><br><span class="line">        T = T * alpha <span class="comment">##降温</span></span><br><span class="line">    <span class="keyword">return</span> best_path, best_energy</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#创建随机距离矩阵：</span></span><br><span class="line"><span class="comment">#特点：距离矩阵是对称矩阵，对角线上的距离为0</span></span><br><span class="line">num_cities = <span class="number">10</span></span><br><span class="line">data = np.random.rand(num_cities, num_cities)</span><br><span class="line">distance_matrix = (data + data.T) / <span class="number">2</span>  <span class="comment">##data.T, 转置矩阵</span></span><br><span class="line">np.fill_diagonal(distance_matrix, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##运行算法：</span></span><br><span class="line">best_path, best_energy = solution_tsp(</span><br><span class="line">    distance_matrix,</span><br><span class="line">    T_max = <span class="number">1000</span>, <span class="comment">#最大温度</span></span><br><span class="line">    T_min = <span class="number">1</span>, <span class="comment">#最小温度</span></span><br><span class="line">    alpha = <span class="number">0.99</span>, <span class="comment">#降温系数</span></span><br><span class="line">    max_iter = <span class="number">1000</span>, <span class="comment">#每个温度下的最大迭代次数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳路径:&quot;</span>, best_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短距离:&quot;</span>, best_energy)</span><br></pre></td></tr></table></figure><h4 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点：</h4><ul><li><p>优点：</p><ul><li>实现较简单</li><li>能有效避免陷入局部最优解的情况</li></ul></li><li><p>缺点：</p><ul><li>收敛速度慢，占用空间较大</li><li>冷却时必须缓缓冷却。</li></ul></li><li><p>经典优化算法</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP_Note</title>
      <link href="/2025/09/02/CSAPP-Note/"/>
      <url>/2025/09/02/CSAPP-Note/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章计算机系统漫游"><a class="markdownIt-Anchor" href="#第一章计算机系统漫游"></a> 第一章：计算机系统漫游</h1><h3 id="一信息由字节表示"><a class="markdownIt-Anchor" href="#一信息由字节表示"></a> 一，信息由字节表示：</h3><p>无论是cpp文件亦或是其他文件，程序中的每一个文本字符都是由ASCII码表示的，例如hello.c文件由ASCII文本表示如下：</p><p>![屏幕截图 2025-09-02 181956](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-02 181956.png)</p><p>像以上的文件被称为文本文件，所有其他文件均被称为二进制文件。</p><h3 id="二程序编译过程的不同形式"><a class="markdownIt-Anchor" href="#二程序编译过程的不同形式"></a> 二，程序编译过程的不同形式：</h3><p>系统上helllo.c文件的运行：</p><p>每条C语句被转化为<strong>低级机器语言指令</strong>，这些指令再按照称为<strong>可执行目标程序</strong>的格式打包，以二进制的磁盘文件形式存放。<u>（目标程序文件也被称为可执行目标文件）</u></p><p>从源文件到目标文件的转化是由编译器驱动程序完成的。编译过程则可分为四个阶段，执行四个阶段的程序</p><p><strong>（预处理器，编译器，汇编器，链接器）一起构成了编译系统。</strong></p><p>![屏幕截图 2025-09-02 183128](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-02 183128.png)</p><h4 id="过程解释"><a class="markdownIt-Anchor" href="#过程解释"></a> 过程解释：</h4><h5 id="预处理阶段"><a class="markdownIt-Anchor" href="#预处理阶段"></a> 预处理阶段：</h5><p>根据#子开头的命令，引用并插入库文件内容，得到对应的扩展文件；</p><h5 id="编译阶段"><a class="markdownIt-Anchor" href="#编译阶段"></a> 编译阶段：</h5><p>将文本文件hello.i翻译为文本文件hello.s，其中包括一汇编语言程序。</p><p>汇编语言的作用：将不同编译器编译的不同语言，转化为通用的汇编语言进行输出。</p><h5 id="汇编阶段"><a class="markdownIt-Anchor" href="#汇编阶段"></a> 汇编阶段：</h5><p>将hello.s翻译为机器语言指令，并将其打包为<strong>可重定位目标程序</strong>的格式----hello.o，</p><h5 id="链接阶段"><a class="markdownIt-Anchor" href="#链接阶段"></a> 链接阶段：</h5><p>将printf函数进行解析，链接添加进hello.o文件中，此时才可最终执行。</p><h1 id="第二章信息的表示和处理"><a class="markdownIt-Anchor" href="#第二章信息的表示和处理"></a> 第二章：信息的表示和处理</h1><h3 id="信息的存储"><a class="markdownIt-Anchor" href="#信息的存储"></a> 信息的存储：</h3><p>程序将内存视作一个大型数组，数组的元素由一个个字节(Byte)组成，每个字节都由唯一的数字表示，称为地址。所有地址的集合就称为虚拟地址空间。</p><ul><li><p>字节：</p><p>一个字节由8位组成。取值范围从00000000 ~ 11111111，即为0 ~ 255。这种一位位表示的方式称为位模式。</p></li><li><p>十六进制的引入：</p><ol><li>避免了二进制的冗长与十进制的麻烦：以 0 ~ 9与A ~ F构成。在C语言中，十六进制以0X开头（大小写随意）</li><li>便于与二进制进行转换：直接将每一位数字以二进制表示即可。注意当总位数不是4的倍数时，需要用0进行补齐。</li></ol></li><li><p>进制的转换：</p><ol><li><p>2的n次方转换为二进制，即是1后面跟了n个0</p></li><li><p>二进制与16进制的转换：</p><p>对于二进制 1000…0(n个0)，采取n = i + 4 * j 的方法。</p><p>即表示该数由 j 个0与一个 i 组成。</p></li><li><p>十进制与十六进制的转换：</p><p>采用辗转相除的方法：</p><p>![屏幕截图 2025-09-04 172949](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 172949.png)</p></li></ol></li><li><p>字长(Words):</p><p>字长决定了在虚拟机中能够存储的最大位到多少。</p><p>对于一个字长为w的机器，虚拟地址的范围是 0 ~ 2^w - 1。</p><p>现常见的机器为32位与64位两种：</p><p>其中32位的文件，两种机器均可运行（因为64位机器大都实现了向下兼容）；而64位的文件只能运行在64位机器上</p><p>各类型数据的字节长：</p></li><li><p>字节的存储顺序：</p><ol><li><p>大端法：从高位往低位存储：</p><p>![屏幕截图 2025-09-04 174117](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 174117.png)</p></li><li><p>小端法：从低位往高位存储：</p><p>![屏幕截图 2025-09-04 174129](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 174129.png)</p></li></ol></li><li><p>​    布尔代数：</p><ul><li><p>~ （非）：</p><p>~0 = 1； ~1 = 0；</p></li><li><p>&amp;（与）：</p><p>0 &amp; 0 = 0； 0 &amp; 1 = 0； 1 &amp;1 = 1；</p></li><li><p>|（或）：</p><p>0 | 0 = 0；0 | 1 = 1；1 | 1 = 1；</p></li><li><p>^（异或）：</p><p>两参数相同时为0；不同时为1；</p></li></ul></li><li><p>掩码运算（Masking Operations):</p><p>通过位运算可以得到特定的掩码序列。</p><p>例如想要得到 0X89ABCDEF的最低有效字节：</p><p>![屏幕截图 2025-09-04 175559](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 175559.png)</p></li><li><p>​    位移运算：</p><ul><li><p>左移：左移n位即是在右端补上n个0</p></li><li><p>右移：分为逻辑右移和算术右移：</p></li></ul></li></ul><h3 id="整数表示"><a class="markdownIt-Anchor" href="#整数表示"></a> 整数表示：</h3><h3 id="整数运算"><a class="markdownIt-Anchor" href="#整数运算"></a> 整数运算：</h3><h3 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数：</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习</title>
      <link href="/2025/09/01/CS61B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/09/01/CS61B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Project 2：Gitlet</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
