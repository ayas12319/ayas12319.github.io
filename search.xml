<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>本学期自学目标</title>
      <link href="/2025/09/08/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E8%87%AA%E5%AD%A6%E7%9B%AE%E6%A0%87/"/>
      <url>/2025/09/08/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E8%87%AA%E5%AD%A6%E7%9B%AE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<ul><li><p>常微分方程与偏微分方程:</p><ul><li><a href="https://ocw.mit.edu/courses/18-04-complex-variables-with-applications-spring-2018/">Complex Variables with Applications | Mathematics | MIT OpenCourseWare</a>（前置复变函数知识）</li><li><a href="https://ocw.mit.edu/courses/18-03sc-differential-equations-fall-2011/pages/unit-i-first-order-differential-equations/">Unit I: First Order Differential Equations | Differential Equations | Mathematics | MIT OpenCourseWare</a>（常微分方程）</li><li><a href="https://ocw.mit.edu/courses/18-152-introduction-to-partial-differential-equations-fall-2011/">Introduction to Partial Differential Equations | Mathematics | MIT OpenCourseWare</a>（偏微分方程建模与求解）</li></ul></li><li><p>数据库系统: </p><ul><li><a href="https://15445.courses.cs.cmu.edu/spring2023/schedule.html">时间表 |CMU 15-445&#x2F;645 ：： 数据库系统简介（2023 年春季） — Schedule | CMU 15-445&#x2F;645 :: Intro to Database Systems (Spring 2023)</a>（作业）</li><li><a href="https://www.youtube.com/playlist?list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf">YouTube</a>（视频）</li></ul></li><li><p>吴恩达-机器学习：</p><p><a href="https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.337.search-card.all.click</a></p></li><li><p>csapp：</p><ul><li><a href="https://www.bilibili.com/video/BV1cD4y1D7uR/%EF%BC%88%E4%B8%AD%E6%96%87%E6%A6%82%E8%A6%81%E8%AE%B2%E8%A7%A3%EF%BC%89">https://www.bilibili.com/video/BV1cD4y1D7uR/（中文概要讲解）</a></li><li><a href="https://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O’Hallaron</a>（课程的project）</li></ul></li><li><p>每日练习一种新算法</p></li><li><p>算法分析与进阶：</p><p><a href="https://ocw.mit.edu/courses/6-046j-design-and-analysis-of-algorithms-spring-2015/">Design and Analysis of Algorithms | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></p></li><li><p>英语六级</p></li><li><p>蓝桥杯省奖</p></li><li><p>数学竞赛</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 目标规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门</title>
      <link href="/2025/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/"/>
      <url>/2025/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数模a题模型积累及应用</title>
      <link href="/2025/09/03/%E6%95%B0%E6%A8%A1a%E9%A2%98%E6%A8%A1%E5%9E%8B%E7%A7%AF%E7%B4%AF%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2025/09/03/%E6%95%B0%E6%A8%A1a%E9%A2%98%E6%A8%A1%E5%9E%8B%E7%A7%AF%E7%B4%AF%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="微分方程及差分方程"><a href="#微分方程及差分方程" class="headerlink" title="微分方程及差分方程"></a>微分方程及差分方程</h1><p>偏微分方程（热传导问题）</p><h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="现代优化算法"><a href="#现代优化算法" class="headerlink" title="现代优化算法"></a>现代优化算法</h2><h3 id="模拟退火算法："><a href="#模拟退火算法：" class="headerlink" title="模拟退火算法："></a>模拟退火算法：</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>来源于固体退火原理，为一种基于概率的算法。将固体加热至充分，再<strong>徐徐</strong>冷却。徐徐冷却时，粒子在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。</p><h4 id="具体过程："><a href="#具体过程：" class="headerlink" title="具体过程："></a>具体过程：</h4><p><img src="C:\Users\LENOVO\Pictures\eecbcc6e4ca230adfdd1076ff30f2d52.png" alt="eecbcc6e4ca230adfdd1076ff30f2d52"></p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>其核心在于以一定概率接受一个比当前解更差的邻域解。概率为：<br>$$<br>p &#x3D; e^{-(e_{new} - e_{old})&#x2F;T}<br>$$</p><h4 id="python代码实现模拟退火算法，解决旅行商问题："><a href="#python代码实现模拟退火算法，解决旅行商问题：" class="headerlink" title="python代码实现模拟退火算法，解决旅行商问题："></a>python代码实现模拟退火算法，解决旅行商问题：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_energy</span>(<span class="params">path, distance_matrix</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    num_cities = <span class="built_in">len</span>(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_cities):</span><br><span class="line">        total += distance_matrix[path[i]][path[(i + <span class="number">1</span>) % num_cities]] <span class="comment">##还要返回起点</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过交换两个城市的位置产生新解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">current_path</span>):</span><br><span class="line">    new_path = current_path.copy()</span><br><span class="line">    i, j = random.sample(<span class="built_in">range</span>(<span class="built_in">len</span>(current_path)), <span class="number">2</span>)</span><br><span class="line">    new_path[i], new_path[j] = new_path[j], new_path[i]</span><br><span class="line">    <span class="keyword">return</span> new_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution_tsp</span>(<span class="params">distance_matrix, T_max, T_min, alpha, max_iter</span>):</span><br><span class="line">    <span class="comment">#初始化：</span></span><br><span class="line">    num_cities = <span class="built_in">len</span>(distance_matrix)</span><br><span class="line">    current_path = <span class="built_in">list</span>(<span class="built_in">range</span>(num_cities))  <span class="comment">##0 ~ n-1 随机排列</span></span><br><span class="line">    random.shuffle(current_path)  <span class="comment">##打乱</span></span><br><span class="line">    current_energy = calc_energy(current_path, distance_matrix)</span><br><span class="line">    </span><br><span class="line">    T = T_max</span><br><span class="line">    best_path = current_path</span><br><span class="line">    best_energy = current_energy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> T &gt; T_min:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">            <span class="comment">#a ,打乱产生新解：</span></span><br><span class="line">            new_path = generate(current_path)</span><br><span class="line">            new_energy = calc_energy(new_path, distance_matrix)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> new_energy &lt; current_energy:</span><br><span class="line">                current_path = new_path</span><br><span class="line">                current_energy = current_energy</span><br><span class="line">                <span class="keyword">if</span> new_energy &lt; best_energy:</span><br><span class="line">                    best_path = new_path</span><br><span class="line">                    best_energy = new_energy</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#新解更差，概率接受:</span></span><br><span class="line">                p = math.exp(-(new_energy - current_energy) / T)</span><br><span class="line">                <span class="keyword">if</span> random.random() &lt; p:</span><br><span class="line">                    current_path = new_path</span><br><span class="line">                    current_energy = new_energy</span><br><span class="line">                </span><br><span class="line">        T = T * alpha <span class="comment">##降温</span></span><br><span class="line">    <span class="keyword">return</span> best_path, best_energy</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#创建随机距离矩阵：</span></span><br><span class="line"><span class="comment">#特点：距离矩阵是对称矩阵，对角线上的距离为0</span></span><br><span class="line">num_cities = <span class="number">10</span></span><br><span class="line">data = np.random.rand(num_cities, num_cities)</span><br><span class="line">distance_matrix = (data + data.T) / <span class="number">2</span>  <span class="comment">##data.T, 转置矩阵</span></span><br><span class="line">np.fill_diagonal(distance_matrix, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##运行算法：</span></span><br><span class="line">best_path, best_energy = solution_tsp(</span><br><span class="line">    distance_matrix,</span><br><span class="line">    T_max = <span class="number">1000</span>, <span class="comment">#最大温度</span></span><br><span class="line">    T_min = <span class="number">1</span>, <span class="comment">#最小温度</span></span><br><span class="line">    alpha = <span class="number">0.99</span>, <span class="comment">#降温系数</span></span><br><span class="line">    max_iter = <span class="number">1000</span>, <span class="comment">#每个温度下的最大迭代次数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳路径:&quot;</span>, best_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短距离:&quot;</span>, best_energy)</span><br></pre></td></tr></table></figure><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><ul><li><p>优点：</p><ul><li>实现较简单</li><li>能有效避免陷入局部最优解的情况</li></ul></li><li><p>缺点：</p><ul><li>收敛速度慢，占用空间较大</li><li>冷却时必须缓缓冷却。</li></ul></li><li><p>经典优化算法</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP_Note</title>
      <link href="/2025/09/02/CSAPP-Note/"/>
      <url>/2025/09/02/CSAPP-Note/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：计算机系统漫游"><a href="#第一章：计算机系统漫游" class="headerlink" title="第一章：计算机系统漫游"></a>第一章：计算机系统漫游</h1><h3 id="一，信息由字节表示："><a href="#一，信息由字节表示：" class="headerlink" title="一，信息由字节表示："></a>一，信息由字节表示：</h3><p>无论是cpp文件亦或是其他文件，程序中的每一个文本字符都是由ASCII码表示的，例如hello.c文件由ASCII文本表示如下：</p><p>![屏幕截图 2025-09-02 181956](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-02 181956.png)</p><p>像以上的文件被称为文本文件，所有其他文件均被称为二进制文件。</p><h3 id="二，程序编译过程的不同形式："><a href="#二，程序编译过程的不同形式：" class="headerlink" title="二，程序编译过程的不同形式："></a>二，程序编译过程的不同形式：</h3><p>系统上helllo.c文件的运行：</p><p>每条C语句被转化为<strong>低级机器语言指令</strong>，这些指令再按照称为<strong>可执行目标程序</strong>的格式打包，以二进制的磁盘文件形式存放。<u>（目标程序文件也被称为可执行目标文件）</u></p><p>从源文件到目标文件的转化是由编译器驱动程序完成的。编译过程则可分为四个阶段，执行四个阶段的程序</p><p><strong>（预处理器，编译器，汇编器，链接器）一起构成了编译系统。</strong></p><p>![屏幕截图 2025-09-02 183128](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-02 183128.png)</p><h4 id="过程解释："><a href="#过程解释：" class="headerlink" title="过程解释："></a>过程解释：</h4><h5 id="预处理阶段："><a href="#预处理阶段：" class="headerlink" title="预处理阶段："></a>预处理阶段：</h5><p>根据#子开头的命令，引用并插入库文件内容，得到对应的扩展文件；</p><h5 id="编译阶段："><a href="#编译阶段：" class="headerlink" title="编译阶段："></a>编译阶段：</h5><p>将文本文件hello.i翻译为文本文件hello.s，其中包括一汇编语言程序。</p><p>汇编语言的作用：将不同编译器编译的不同语言，转化为通用的汇编语言进行输出。</p><h5 id="汇编阶段："><a href="#汇编阶段：" class="headerlink" title="汇编阶段："></a>汇编阶段：</h5><p>将hello.s翻译为机器语言指令，并将其打包为<strong>可重定位目标程序</strong>的格式—-hello.o，</p><h5 id="链接阶段："><a href="#链接阶段：" class="headerlink" title="链接阶段："></a>链接阶段：</h5><p>将printf函数进行解析，链接添加进hello.o文件中，此时才可最终执行。</p><h1 id="第二章：信息的表示和处理"><a href="#第二章：信息的表示和处理" class="headerlink" title="第二章：信息的表示和处理"></a>第二章：信息的表示和处理</h1><h3 id="信息的存储："><a href="#信息的存储：" class="headerlink" title="信息的存储："></a>信息的存储：</h3><p>程序将内存视作一个大型数组，数组的元素由一个个字节(Byte)组成，每个字节都由唯一的数字表示，称为地址。所有地址的集合就称为虚拟地址空间。</p><ul><li><p>字节：</p><p>一个字节由8位组成。取值范围从00000000 ~ 11111111，即为0 ~ 255。这种一位位表示的方式称为位模式。</p></li><li><p>十六进制的引入：</p><ol><li>避免了二进制的冗长与十进制的麻烦：以 0 ~ 9与A ~ F构成。在C语言中，十六进制以0X开头（大小写随意）</li><li>便于与二进制进行转换：直接将每一位数字以二进制表示即可。注意当总位数不是4的倍数时，需要用0进行补齐。</li></ol></li><li><p>进制的转换：</p><ol><li><p>2的n次方转换为二进制，即是1后面跟了n个0</p></li><li><p>二进制与16进制的转换：</p><p>对于二进制 1000…0(n个0)，采取n &#x3D; i + 4 * j 的方法。</p><p>即表示该数由 j 个0与一个 i 组成。</p></li><li><p>十进制与十六进制的转换：</p><p>采用辗转相除的方法：</p><p>![屏幕截图 2025-09-04 172949](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 172949.png)</p></li></ol></li><li><p>字长(Words):</p><p>字长决定了在虚拟机中能够存储的最大位到多少。</p><p>对于一个字长为w的机器，虚拟地址的范围是 0 ~ 2^w - 1。</p><p>现常见的机器为32位与64位两种：</p><p>其中32位的文件，两种机器均可运行（因为64位机器大都实现了向下兼容）；而64位的文件只能运行在64位机器上</p><p>各类型数据的字节长：</p></li><li><p>字节的存储顺序：</p><ol><li><p>大端法：从高位往低位存储：</p><p>![屏幕截图 2025-09-04 174117](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 174117.png)</p></li><li><p>小端法：从低位往高位存储：</p><p>![屏幕截图 2025-09-04 174129](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 174129.png)</p></li></ol></li><li><p>​    布尔代数：</p><ul><li><p>~ （非）：</p><p>~0 &#x3D; 1； ~1 &#x3D; 0；</p></li><li><p>&amp;（与）：</p><p>0 &amp; 0 &#x3D; 0； 0 &amp; 1 &#x3D; 0； 1 &amp;1 &#x3D; 1；</p></li><li><p>|（或）：</p><p>0 | 0 &#x3D; 0；0 | 1 &#x3D; 1；1 | 1 &#x3D; 1；</p></li><li><p>^（异或）：</p><p>两参数相同时为0；不同时为1；</p></li></ul></li><li><p>掩码运算（Masking Operations):</p><p>通过位运算可以得到特定的掩码序列。</p><p>例如想要得到 0X89ABCDEF的最低有效字节：</p><p>![屏幕截图 2025-09-04 175559](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 175559.png)</p></li><li><p>​    位移运算：</p><ul><li><p>左移：左移n位即是在右端补上n个0</p></li><li><p>右移：分为逻辑右移和算术右移：</p></li></ul></li></ul><h3 id="整数表示："><a href="#整数表示：" class="headerlink" title="整数表示："></a>整数表示：</h3><h3 id="整数运算："><a href="#整数运算：" class="headerlink" title="整数运算："></a>整数运算：</h3><h3 id="浮点数："><a href="#浮点数：" class="headerlink" title="浮点数："></a>浮点数：</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习</title>
      <link href="/2025/09/01/CS61B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/09/01/CS61B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Project 2：Gitlet</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
