<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据库（一，引入；关系模型和代数）</title>
      <link href="/2025/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%8C%E5%BC%95%E5%85%A5%EF%BC%9B%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BB%A3%E6%95%B0%EF%BC%89/"/>
      <url>/2025/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%8C%E5%BC%95%E5%85%A5%EF%BC%9B%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BB%A3%E6%95%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库管理系统（DBMS）："><a href="#数据库管理系统（DBMS）：" class="headerlink" title="数据库管理系统（DBMS）："></a>数据库管理系统（DBMS）：</h2><p>DBMS是一种允许应用程序在数据库中存储和分析信息的软件。</p><p>DBMS允许根据某些数据模型来定义，创建，查询，更新，管理数据库。</p><h2 id="数据模型："><a href="#数据模型：" class="headerlink" title="数据模型："></a>数据模型：</h2><p>是一种描述数据库中数据的概念的集合：</p><p>实例：关系，NoSQL(键&#x2F;值，文档，图形)，数组&#x2F;矩阵&#x2F;向量(用于机器学习)</p><h3 id="关系数据模型："><a href="#关系数据模型：" class="headerlink" title="关系数据模型："></a>关系数据模型：</h3><p>关系数据模型定义了基于关系的数据库抽象概念，以避免更新数据库而要重写代码的开销。</p><h4 id="关系模型三个原则："><a href="#关系模型三个原则：" class="headerlink" title="关系模型三个原则："></a>关系模型三个原则：</h4><p>1，用简单的数据结构来存储数据；</p><p>2，物理存储方式由DBMS的具体实现来决定。</p><p>3，只通过sql语言接受数据，DBMS找出来最佳的执行策略。</p><h4 id="关系模型定义三个概念："><a href="#关系模型定义三个概念：" class="headerlink" title="关系模型定义三个概念："></a>关系模型定义三个概念：</h4><p>1，结构：关系的定义及其内容。关系具有的属性，以及这些属性可以包含的值</p><p>2，完整性：确保数据库的内容满足约束。如：year属性的值必须均为数字</p><p>3，操作：如何访问和修改数据库的内容</p><p>元组是关系中的一组属性值。每个属性都可以有特殊值NULL，这表示该属性是未定义的。</p><p>具有n个属性的关系被称为n元关系。n元关系相当于具有n列的表。</p><h4 id="key"><a href="#key" class="headerlink" title="key:"></a>key:</h4><h5 id="主键："><a href="#主键：" class="headerlink" title="主键："></a>主键：</h5><p>一个关系的主键独一无二地标识这一个元组。有些DBMS会自动创建内部主键。</p><h5 id="外键："><a href="#外键：" class="headerlink" title="外键："></a>外键：</h5><p>指定一个关系中的属性必须映射到另一个关系中的元组。例如：在专辑表中包含艺术家的ID，这个ID就可以关联到这个艺术家的作品。</p><h2 id="数据操作语言（DML）："><a href="#数据操作语言（DML）：" class="headerlink" title="数据操作语言（DML）："></a>数据操作语言（DML）：</h2><p>从数据库中存储和检索信息的方法。</p><p>1，过程性：以set或bag来查找所需结果。例如：通过for循环遍历所有结果，以记录总的结果数。（关系代数）</p><p>2，非过程性（声明性）：仅定义想要查询的数据。而不指定查询方式。</p><h3 id="关系代数："><a href="#关系代数：" class="headerlink" title="关系代数："></a>关系代数：</h3><p>关系代数是通过关系，检索和操作元组的集合。每一种操作都接受一种或多种关系，然后输出一个新关系。通过连接这些操作，我们可以实现查询的编写。</p><ul><li><h5 id="select："><a href="#select：" class="headerlink" title="select："></a>select：</h5></li></ul><p>接受一个关系，并从该关系中输出满足选择谓词的元组的子集。我们可以通过连词和析取来组合多个谓词。<br>$$<br>语法：\sigma_{predict}(R);\<br>示例：\sigma_{a_id&#x3D;’a2’}(R)<br>$$</p><ul><li><h5 id="projection"><a href="#projection" class="headerlink" title="projection:"></a>projection:</h5></li></ul><p>接受一个关系，并输出一个新的临时关系。可以重新排列输入关系中属性的顺序，和对值进行操作。<br>$$<br>语法: \pi_{A1,A2,A3…}(R) \<br>示例：\pi_{b_id-100,a_id}(\sigma_{a_id&#x3D;’a2’}(R))\<br>解释：在a_id为a2的关系表中，将b_id的值都-100，然后排列顺序变为：b_id在第一列，\a_id在第二列。<br>$$<br>​      SQL: SELECT b_id-100, a_id FROM R WHERE a_id &#x3D; ‘a2’</p><ul><li><h5 id="union"><a href="#union" class="headerlink" title="union:"></a>union:</h5></li></ul><p>接受两个关系并输出一个关系（取并集）。两个输入关系必须具备完全相同的属性。<br>$$<br>语法：(R \cup S)\<br>SQL中：(SELECT * FROM\quad R)\quad UNION\quad ALL(SELECT * FROM\quad S)<br>$$<br>注意：union 自动去重，union all不会去重；</p><ul><li><h5 id="intersection"><a href="#intersection" class="headerlink" title="intersection:"></a>intersection:</h5></li></ul><p>输出两个关系的交集：<br>$$<br>语法：(R \cap S) \<br>SQL: (SELECT * FROM\quad R) INTERSECT (SELECT * FROM\quad S)<br>$$</p><ul><li><h5 id="差集："><a href="#差集：" class="headerlink" title="差集："></a>差集：</h5></li></ul><p>输出不同的元组集合<br>$$<br>语法：(R-S) \<br>SQL: (SELECT * FROM\quad R) EXCEPT (SELECT * FROM\quad S)<br>$$</p><ul><li><h5 id="product"><a href="#product" class="headerlink" title="product:"></a>product:</h5></li></ul><p>将两个关系表进行笛卡尔积后，输出结果。<br>$$<br>语法：(R\quad X\quad S)\<br>SQL: (SELECT * FROM\quad R) CROSS\quad JOIN (SELECT * FROM\quad S)\or\quad simply\quad SELECT * FROM\quad R, S<br>$$</p><ul><li><h5 id="join："><a href="#join：" class="headerlink" title="join："></a>join：</h5></li></ul><p>输出的关系包含所有元组，这些元组是两个元组的组合(重复的合并，单有的加上)。</p><p>基于相同的值进行连接。</p><p>语法：(R ▷◁ S)</p><p>SQL: SELECT * FROM R JOIN S ON (合并条件…)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（一，引入；关系模型和代数）</title>
      <link href="/2025/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2025/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库管理系统（DBMS）："><a href="#数据库管理系统（DBMS）：" class="headerlink" title="数据库管理系统（DBMS）："></a>数据库管理系统（DBMS）：</h2><p>DBMS是一种允许应用程序在数据库中存储和分析信息的软件。</p><p>DBMS允许根据某些数据模型来定义，创建，查询，更新，管理数据库。</p><h2 id="数据模型："><a href="#数据模型：" class="headerlink" title="数据模型："></a>数据模型：</h2><p>是一种描述数据库中数据的概念的集合：</p><p>实例：关系，NoSQL(键&#x2F;值，文档，图形)，数组&#x2F;矩阵&#x2F;向量(用于机器学习)</p><h3 id="关系数据模型："><a href="#关系数据模型：" class="headerlink" title="关系数据模型："></a>关系数据模型：</h3><p>关系数据模型定义了基于关系的数据库抽象概念，以避免更新数据库而要重写代码的开销。</p><h4 id="关系模型三个原则："><a href="#关系模型三个原则：" class="headerlink" title="关系模型三个原则："></a>关系模型三个原则：</h4><p>1，用简单的数据结构来存储数据；</p><p>2，物理存储方式由DBMS的具体实现来决定。</p><p>3，只通过sql语言接受数据，DBMS找出来最佳的执行策略。</p><h4 id="关系模型定义三个概念："><a href="#关系模型定义三个概念：" class="headerlink" title="关系模型定义三个概念："></a>关系模型定义三个概念：</h4><p>1，结构：关系的定义及其内容。关系具有的属性，以及这些属性可以包含的值</p><p>2，完整性：确保数据库的内容满足约束。如：year属性的值必须均为数字</p><p>3，操作：如何访问和修改数据库的内容</p><p>元组是关系中的一组属性值。每个属性都可以有特殊值NULL，这表示该属性是未定义的。</p><p>具有n个属性的关系被称为n元关系。n元关系相当于具有n列的表。</p><h4 id="key"><a href="#key" class="headerlink" title="key:"></a>key:</h4><h5 id="主键："><a href="#主键：" class="headerlink" title="主键："></a>主键：</h5><p>一个关系的主键独一无二地标识这一个元组。有些DBMS会自动创建内部主键。</p><h5 id="外键："><a href="#外键：" class="headerlink" title="外键："></a>外键：</h5><p>指定一个关系中的属性必须映射到另一个关系中的元组。例如：在专辑表中包含艺术家的ID，这个ID就可以关联到这个艺术家的作品。</p><h2 id="数据操作语言（DML）："><a href="#数据操作语言（DML）：" class="headerlink" title="数据操作语言（DML）："></a>数据操作语言（DML）：</h2><p>从数据库中存储和检索信息的方法。</p><p>1，过程性：以set或bag来查找所需结果。例如：通过for循环遍历所有结果，以记录总的结果数。（关系代数）</p><p>2，非过程性（声明性）：仅定义想要查询的数据。而不指定查询方式。</p><h3 id="关系代数："><a href="#关系代数：" class="headerlink" title="关系代数："></a>关系代数：</h3><p>关系代数是通过关系，检索和操作元组的集合。每一种操作都接受一种或多种关系，然后输出一个新关系。通过连接这些操作，我们可以实现查询的编写。</p><ul><li><h5 id="select："><a href="#select：" class="headerlink" title="select："></a>select：</h5></li></ul><p>接受一个关系，并从该关系中输出满足选择谓词的元组的子集。我们可以通过连词和析取来组合多个谓词。<br>$$<br>语法：\sigma_{predict}(R);\<br>示例：\sigma_{a_id&#x3D;’a2’}(R)<br>$$</p><ul><li><h5 id="projection"><a href="#projection" class="headerlink" title="projection:"></a>projection:</h5></li></ul><p>接受一个关系，并输出一个新的临时关系。可以重新排列输入关系中属性的顺序，和对值进行操作。<br>$$<br>语法: \pi_{A1,A2,A3…}(R) \<br>示例：\pi_{b_id-100,a_id}(\sigma_{a_id&#x3D;’a2’}(R))\<br>解释：在a_id为a2的关系表中，将b_id的值都-100，然后排列顺序变为：b_id在第一列，\a_id在第二列。<br>$$<br>​      SQL: SELECT b_id-100, a_id FROM R WHERE a_id &#x3D; ‘a2’</p><ul><li><h5 id="union"><a href="#union" class="headerlink" title="union:"></a>union:</h5></li></ul><p>接受两个关系并输出一个关系（取并集）。两个输入关系必须具备完全相同的属性。<br>$$<br>语法：(R \cup S)\<br>SQL中：(SELECT * FROM\quad R)\quad UNION\quad ALL(SELECT * FROM\quad S)<br>$$<br>注意：union 自动去重，union all不会去重；</p><ul><li><h5 id="intersection"><a href="#intersection" class="headerlink" title="intersection:"></a>intersection:</h5></li></ul><p>输出两个关系的交集：<br>$$<br>语法：(R \cap S) \<br>SQL: (SELECT * FROM\quad R) INTERSECT (SELECT * FROM\quad S)<br>$$</p><ul><li><h5 id="差集："><a href="#差集：" class="headerlink" title="差集："></a>差集：</h5></li></ul><p>输出不同的元组集合<br>$$<br>语法：(R-S) \<br>SQL: (SELECT * FROM\quad R) EXCEPT (SELECT * FROM\quad S)<br>$$</p><ul><li><h5 id="product"><a href="#product" class="headerlink" title="product:"></a>product:</h5></li></ul><p>将两个关系表进行笛卡尔积后，输出结果。<br>$$<br>语法：(R\quad X\quad S)\<br>SQL: (SELECT * FROM\quad R) CROSS\quad JOIN (SELECT * FROM\quad S)\or\quad simply\quad SELECT * FROM\quad R, S<br>$$</p><ul><li><h5 id="join："><a href="#join：" class="headerlink" title="join："></a>join：</h5></li></ul><p>输出的关系包含所有元组，这些元组是两个元组的组合(重复的合并，单有的加上)。</p><p>基于相同的值进行连接。</p><p>语法：(R ▷◁ S)</p><p>SQL: SELECT * FROM R JOIN S ON (合并条件…)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本学期自学目标</title>
      <link href="/2025/09/08/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E8%87%AA%E5%AD%A6%E7%9B%AE%E6%A0%87/"/>
      <url>/2025/09/08/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E8%87%AA%E5%AD%A6%E7%9B%AE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<ul><li><p>常微分方程与偏微分方程:</p><ul><li><a href="https://ocw.mit.edu/courses/18-04-complex-variables-with-applications-spring-2018/">Complex Variables with Applications | Mathematics | MIT OpenCourseWare</a>（前置复变函数知识）</li><li><a href="https://ocw.mit.edu/courses/18-03sc-differential-equations-fall-2011/pages/unit-i-first-order-differential-equations/">Unit I: First Order Differential Equations | Differential Equations | Mathematics | MIT OpenCourseWare</a>（常微分方程）</li><li><a href="https://ocw.mit.edu/courses/18-152-introduction-to-partial-differential-equations-fall-2011/">Introduction to Partial Differential Equations | Mathematics | MIT OpenCourseWare</a>（偏微分方程建模与求解）</li></ul></li><li><p>数据库系统: </p><ul><li><a href="https://15445.courses.cs.cmu.edu/spring2023/schedule.html">时间表 |CMU 15-445&#x2F;645 ：： 数据库系统简介（2023 年春季） — Schedule | CMU 15-445&#x2F;645 :: Intro to Database Systems (Spring 2023)</a>（作业）</li><li><a href="https://www.youtube.com/playlist?list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf">YouTube</a>（视频）</li></ul></li><li><p>吴恩达-机器学习：</p><p><a href="https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.337.search-card.all.click</a></p></li><li><p>csapp：</p><ul><li><a href="https://www.bilibili.com/video/BV1cD4y1D7uR/%EF%BC%88%E4%B8%AD%E6%96%87%E6%A6%82%E8%A6%81%E8%AE%B2%E8%A7%A3%EF%BC%89">https://www.bilibili.com/video/BV1cD4y1D7uR/（中文概要讲解）</a></li><li><a href="https://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O’Hallaron</a>（课程的project）</li></ul></li><li><p>每日练习一种新算法</p></li><li><p>算法分析与进阶：</p><p><a href="https://ocw.mit.edu/courses/6-046j-design-and-analysis-of-algorithms-spring-2015/">Design and Analysis of Algorithms | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></p></li><li><p>英语六级</p></li><li><p>蓝桥杯省奖</p></li><li><p>数学竞赛</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 目标规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构入门</title>
      <link href="/2025/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/"/>
      <url>/2025/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>线性表：</p><p>模块一：公共概念：</p><p> 1，基本定义：</p><p>具有相同类型的n个元素的有限序列，称为线性表；<br>$$<br>k_{i}称为k_{i+1}的前驱元素；k_{i}称为k_{i-1}的后继元素。<br>$$<br>2，基本运算：</p><p>查找；插入；删除；其他。（合并，排列，统计….)</p><p>模块二：实例：</p><p>数组：</p><p>数组的类实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       Type * elements;</span><br><span class="line">       <span class="type">int</span> ArraySize;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">get_Array</span><span class="params">()</span></span>;  <span class="comment">//动态分配存储空间</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Array</span>(<span class="type">int</span> size); <span class="comment">//根据大小构造函数</span></span><br><span class="line">       <span class="built_in">Array</span>(<span class="type">const</span> Array&lt;Type&gt; &amp;x);  <span class="comment">//复制构造函数</span></span><br><span class="line">       ~<span class="built_in">Array</span>()&#123;  <span class="comment">//析构函数</span></span><br><span class="line">           <span class="keyword">delete</span> []elements;</span><br><span class="line">       &#125;</span><br><span class="line">       Array&lt;Type&gt; &amp; <span class="keyword">operator</span> = (<span class="type">const</span> Array&lt;Type&gt;&amp;A);  <span class="comment">//数组复制</span></span><br><span class="line">       Type&amp; <span class="keyword">operator</span> [](<span class="type">int</span> i);  <span class="comment">//获取特定元素</span></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ArraySize;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="type">int</span> now_size;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> Array&lt;Type&gt; ::<span class="built_in">get_Array</span>()&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[ArraySize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Array</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;MLE&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ArraySize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArraySize = size;</span><br><span class="line">    <span class="built_in">get_Array</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> Array&lt;Type&gt;:: <span class="built_in">Array</span>(<span class="type">const</span> Array &lt;Type&gt;&amp; x)&#123;</span><br><span class="line">    Arraysize = x.ArraySize;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[ArraySize];</span><br><span class="line">    Type* target = x.elements;</span><br><span class="line">    Type* obj = elements;</span><br><span class="line">    <span class="type">int</span> n = ArraySize;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        *obj ++ = *target ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数模a题模型积累及应用</title>
      <link href="/2025/09/03/%E6%95%B0%E6%A8%A1a%E9%A2%98%E6%A8%A1%E5%9E%8B%E7%A7%AF%E7%B4%AF%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2025/09/03/%E6%95%B0%E6%A8%A1a%E9%A2%98%E6%A8%A1%E5%9E%8B%E7%A7%AF%E7%B4%AF%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="微分方程及差分方程"><a href="#微分方程及差分方程" class="headerlink" title="微分方程及差分方程"></a>微分方程及差分方程</h1><p>偏微分方程（热传导问题）</p><h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="现代优化算法"><a href="#现代优化算法" class="headerlink" title="现代优化算法"></a>现代优化算法</h2><h3 id="模拟退火算法："><a href="#模拟退火算法：" class="headerlink" title="模拟退火算法："></a>模拟退火算法：</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>来源于固体退火原理，为一种基于概率的算法。将固体加热至充分，再<strong>徐徐</strong>冷却。徐徐冷却时，粒子在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。</p><h4 id="具体过程："><a href="#具体过程：" class="headerlink" title="具体过程："></a>具体过程：</h4><p><img src="C:\Users\LENOVO\Pictures\eecbcc6e4ca230adfdd1076ff30f2d52.png" alt="eecbcc6e4ca230adfdd1076ff30f2d52"></p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>其核心在于以一定概率接受一个比当前解更差的邻域解。概率为：<br>$$<br>p &#x3D; e^{-(e_{new} - e_{old})&#x2F;T}<br>$$</p><h4 id="python代码实现模拟退火算法，解决旅行商问题："><a href="#python代码实现模拟退火算法，解决旅行商问题：" class="headerlink" title="python代码实现模拟退火算法，解决旅行商问题："></a>python代码实现模拟退火算法，解决旅行商问题：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_energy</span>(<span class="params">path, distance_matrix</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    num_cities = <span class="built_in">len</span>(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_cities):</span><br><span class="line">        total += distance_matrix[path[i]][path[(i + <span class="number">1</span>) % num_cities]] <span class="comment">##还要返回起点</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过交换两个城市的位置产生新解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">current_path</span>):</span><br><span class="line">    new_path = current_path.copy()</span><br><span class="line">    i, j = random.sample(<span class="built_in">range</span>(<span class="built_in">len</span>(current_path)), <span class="number">2</span>)</span><br><span class="line">    new_path[i], new_path[j] = new_path[j], new_path[i]</span><br><span class="line">    <span class="keyword">return</span> new_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution_tsp</span>(<span class="params">distance_matrix, T_max, T_min, alpha, max_iter</span>):</span><br><span class="line">    <span class="comment">#初始化：</span></span><br><span class="line">    num_cities = <span class="built_in">len</span>(distance_matrix)</span><br><span class="line">    current_path = <span class="built_in">list</span>(<span class="built_in">range</span>(num_cities))  <span class="comment">##0 ~ n-1 随机排列</span></span><br><span class="line">    random.shuffle(current_path)  <span class="comment">##打乱</span></span><br><span class="line">    current_energy = calc_energy(current_path, distance_matrix)</span><br><span class="line">    </span><br><span class="line">    T = T_max</span><br><span class="line">    best_path = current_path</span><br><span class="line">    best_energy = current_energy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> T &gt; T_min:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">            <span class="comment">#a ,打乱产生新解：</span></span><br><span class="line">            new_path = generate(current_path)</span><br><span class="line">            new_energy = calc_energy(new_path, distance_matrix)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> new_energy &lt; current_energy:</span><br><span class="line">                current_path = new_path</span><br><span class="line">                current_energy = current_energy</span><br><span class="line">                <span class="keyword">if</span> new_energy &lt; best_energy:</span><br><span class="line">                    best_path = new_path</span><br><span class="line">                    best_energy = new_energy</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#新解更差，概率接受:</span></span><br><span class="line">                p = math.exp(-(new_energy - current_energy) / T)</span><br><span class="line">                <span class="keyword">if</span> random.random() &lt; p:</span><br><span class="line">                    current_path = new_path</span><br><span class="line">                    current_energy = new_energy</span><br><span class="line">                </span><br><span class="line">        T = T * alpha <span class="comment">##降温</span></span><br><span class="line">    <span class="keyword">return</span> best_path, best_energy</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#创建随机距离矩阵：</span></span><br><span class="line"><span class="comment">#特点：距离矩阵是对称矩阵，对角线上的距离为0</span></span><br><span class="line">num_cities = <span class="number">10</span></span><br><span class="line">data = np.random.rand(num_cities, num_cities)</span><br><span class="line">distance_matrix = (data + data.T) / <span class="number">2</span>  <span class="comment">##data.T, 转置矩阵</span></span><br><span class="line">np.fill_diagonal(distance_matrix, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##运行算法：</span></span><br><span class="line">best_path, best_energy = solution_tsp(</span><br><span class="line">    distance_matrix,</span><br><span class="line">    T_max = <span class="number">1000</span>, <span class="comment">#最大温度</span></span><br><span class="line">    T_min = <span class="number">1</span>, <span class="comment">#最小温度</span></span><br><span class="line">    alpha = <span class="number">0.99</span>, <span class="comment">#降温系数</span></span><br><span class="line">    max_iter = <span class="number">1000</span>, <span class="comment">#每个温度下的最大迭代次数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳路径:&quot;</span>, best_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短距离:&quot;</span>, best_energy)</span><br></pre></td></tr></table></figure><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><ul><li><p>优点：</p><ul><li>实现较简单</li><li>能有效避免陷入局部最优解的情况</li></ul></li><li><p>缺点：</p><ul><li>收敛速度慢，占用空间较大</li><li>冷却时必须缓缓冷却。</li></ul></li><li><p>经典优化算法</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP_Note</title>
      <link href="/2025/09/02/CSAPP-Note/"/>
      <url>/2025/09/02/CSAPP-Note/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：计算机系统漫游"><a href="#第一章：计算机系统漫游" class="headerlink" title="第一章：计算机系统漫游"></a>第一章：计算机系统漫游</h1><h3 id="一，信息由字节表示："><a href="#一，信息由字节表示：" class="headerlink" title="一，信息由字节表示："></a>一，信息由字节表示：</h3><p>无论是cpp文件亦或是其他文件，程序中的每一个文本字符都是由ASCII码表示的，例如hello.c文件由ASCII文本表示如下：</p><p>![屏幕截图 2025-09-02 181956](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-02 181956.png)</p><p>像以上的文件被称为文本文件，所有其他文件均被称为二进制文件。</p><h3 id="二，程序编译过程的不同形式："><a href="#二，程序编译过程的不同形式：" class="headerlink" title="二，程序编译过程的不同形式："></a>二，程序编译过程的不同形式：</h3><p>系统上helllo.c文件的运行：</p><p>每条C语句被转化为<strong>低级机器语言指令</strong>，这些指令再按照称为<strong>可执行目标程序</strong>的格式打包，以二进制的磁盘文件形式存放。<u>（目标程序文件也被称为可执行目标文件）</u></p><p>从源文件到目标文件的转化是由编译器驱动程序完成的。编译过程则可分为四个阶段，执行四个阶段的程序</p><p><strong>（预处理器，编译器，汇编器，链接器）一起构成了编译系统。</strong></p><p>![屏幕截图 2025-09-02 183128](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-02 183128.png)</p><h4 id="过程解释："><a href="#过程解释：" class="headerlink" title="过程解释："></a>过程解释：</h4><h5 id="预处理阶段："><a href="#预处理阶段：" class="headerlink" title="预处理阶段："></a>预处理阶段：</h5><p>根据#子开头的命令，引用并插入库文件内容，得到对应的扩展文件；</p><h5 id="编译阶段："><a href="#编译阶段：" class="headerlink" title="编译阶段："></a>编译阶段：</h5><p>将文本文件hello.i翻译为文本文件hello.s，其中包括一汇编语言程序。</p><p>汇编语言的作用：将不同编译器编译的不同语言，转化为通用的汇编语言进行输出。</p><h5 id="汇编阶段："><a href="#汇编阶段：" class="headerlink" title="汇编阶段："></a>汇编阶段：</h5><p>将hello.s翻译为机器语言指令，并将其打包为<strong>可重定位目标程序</strong>的格式—-hello.o，</p><h5 id="链接阶段："><a href="#链接阶段：" class="headerlink" title="链接阶段："></a>链接阶段：</h5><p>将printf函数进行解析，链接添加进hello.o文件中，此时才可最终执行。</p><h1 id="第二章：信息的表示和处理"><a href="#第二章：信息的表示和处理" class="headerlink" title="第二章：信息的表示和处理"></a>第二章：信息的表示和处理</h1><h3 id="信息的存储："><a href="#信息的存储：" class="headerlink" title="信息的存储："></a>信息的存储：</h3><p>程序将内存视作一个大型数组，数组的元素由一个个字节(Byte)组成，每个字节都由唯一的数字表示，称为地址。所有地址的集合就称为虚拟地址空间。</p><ul><li><p>字节：</p><p>一个字节由8位组成。取值范围从00000000 ~ 11111111，即为0 ~ 255。这种一位位表示的方式称为位模式。</p></li><li><p>十六进制的引入：</p><ol><li>避免了二进制的冗长与十进制的麻烦：以 0 ~ 9与A ~ F构成。在C语言中，十六进制以0X开头（大小写随意）</li><li>便于与二进制进行转换：直接将每一位数字以二进制表示即可。注意当总位数不是4的倍数时，需要用0进行补齐。</li></ol></li><li><p>进制的转换：</p><ol><li><p>2的n次方转换为二进制，即是1后面跟了n个0</p></li><li><p>二进制与16进制的转换：</p><p>对于二进制 1000…0(n个0)，采取n &#x3D; i + 4 * j 的方法。</p><p>即表示该数由 j 个0与一个 i 组成。</p></li><li><p>十进制与十六进制的转换：</p><p>采用辗转相除的方法：</p><p>![屏幕截图 2025-09-04 172949](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 172949.png)</p></li></ol></li><li><p>字长(Words):</p><p>字长决定了在虚拟机中能够存储的最大位到多少。</p><p>对于一个字长为w的机器，虚拟地址的范围是 0 ~ 2^w - 1。</p><p>现常见的机器为32位与64位两种：</p><p>其中32位的文件，两种机器均可运行（因为64位机器大都实现了向下兼容）；而64位的文件只能运行在64位机器上</p><p>各类型数据的字节长：</p></li><li><p>字节的存储顺序：</p><ol><li><p>大端法：从高位往低位存储：</p><p>![屏幕截图 2025-09-04 174117](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 174117.png)</p></li><li><p>小端法：从低位往高位存储：</p><p>![屏幕截图 2025-09-04 174129](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 174129.png)</p></li></ol></li><li><p>​    布尔代数：</p><ul><li><p>~ （非）：</p><p>~0 &#x3D; 1； ~1 &#x3D; 0；</p></li><li><p>&amp;（与）：</p><p>0 &amp; 0 &#x3D; 0； 0 &amp; 1 &#x3D; 0； 1 &amp;1 &#x3D; 1；</p></li><li><p>|（或）：</p><p>0 | 0 &#x3D; 0；0 | 1 &#x3D; 1；1 | 1 &#x3D; 1；</p></li><li><p>^（异或）：</p><p>两参数相同时为0；不同时为1；</p></li></ul></li><li><p>掩码运算（Masking Operations):</p><p>通过位运算可以得到特定的掩码序列。</p><p>例如想要得到 0X89ABCDEF的最低有效字节：</p><p>![屏幕截图 2025-09-04 175559](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-04 175559.png)</p></li><li><p>​    位移运算：</p><ul><li><p>左移：左移n位即是在右端补上n个0</p></li><li><p>右移：分为逻辑右移和算术右移：</p></li></ul></li></ul><h3 id="整数表示："><a href="#整数表示：" class="headerlink" title="整数表示："></a>整数表示：</h3><h3 id="整数运算："><a href="#整数运算：" class="headerlink" title="整数运算："></a>整数运算：</h3><h3 id="浮点数："><a href="#浮点数：" class="headerlink" title="浮点数："></a>浮点数：</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习</title>
      <link href="/2025/09/01/CS61B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/09/01/CS61B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Project 2：Gitlet</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
