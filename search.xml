<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>拓扑排序与DAG</title>
      <link href="/2025/09/16/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG/"/>
      <url>/2025/09/16/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%8EDAG/</url>
      
        <content type="html"><![CDATA[<h1 id="拓扑排序："><a href="#拓扑排序：" class="headerlink" title="拓扑排序："></a>拓扑排序：</h1><p>假设有一系列的任务，某些任务必须在某个任务完成后才能进行，怎样对这些任务的执行进行排序？</p><p>将这些任务视为一个图，每个节点代表一个任务，V—&gt;W表示任务V必须在W前完成。则问题转换为找到这张图的拓扑排序：</p><p><img src="https://youke1.picui.cn/s1/2025/09/16/68c96d2bc092e.png"></p><p><strong>拓扑排序只有对于有向，无环的图有效。称有向无环图为DAG；</strong></p><p>对于任何拓扑排序，都可以将图线性化。</p><p><img src="https://youke1.picui.cn/s1/2025/09/16/68c96df20fc71.png"></p><p>上述 DAG 的拓扑排序必须以 D 或 E 开头，并且必须以 F 或 C 结尾。因此，D 和 E 称为源，F 和 C 称为汇。</p><h1 id="计算拓扑排序的算法："><a href="#计算拓扑排序的算法：" class="headerlink" title="计算拓扑排序的算法："></a>计算拓扑排序的算法：</h1><h2 id="基于DFS："><a href="#基于DFS：" class="headerlink" title="基于DFS："></a>基于DFS：</h2><p>基于DFS的拓扑算法实际上是逆后序遍历。</p><p>树的逆后序遍历恰好时根节点排在两个子节点的后面，故翻转过来即符合拓扑排序的要求。</p><h2 id="基于BFS："><a href="#基于BFS：" class="headerlink" title="基于BFS："></a>基于BFS：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int h[N], e[N], ne[N], idx;</span><br><span class="line">int in[N]; //存储各节点的入度</span><br><span class="line">int cnt; //存储队列中的元素个数</span><br><span class="line">int top[N]; //存储队列中的元素</span><br><span class="line">void add(int a, int b)&#123; //添加a -&gt; b的边</span><br><span class="line">  e[idx] = b;</span><br><span class="line">  ne[idx] = h[a];</span><br><span class="line">  h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line">bool topsort()&#123;</span><br><span class="line">  queue&lt;int&gt; q;</span><br><span class="line">  for(int i = 1; i &lt;= n; ++i)&#123;</span><br><span class="line">     if(!in[i]) q.push(i);  //先将入度为0的点加入队列中。</span><br><span class="line">  &#125;</span><br><span class="line">  while(q.size())&#123;</span><br><span class="line">     auto t = q.front(); //先一个个以从源点开始</span><br><span class="line">     top[++cnt] = t;</span><br><span class="line">     q.pop();</span><br><span class="line">     for(int i = h[t]; i != -1; i = ne[i])&#123;</span><br><span class="line">        int j = e[i];</span><br><span class="line">        in[j] --;  //这条边标记一次，直至其入度为0时，入队</span><br><span class="line">        if(!in[j]) q.push(j);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return cnt == n;  //可以判断该图是否为DAG</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于拓扑排序的寻找带负权边的DAG最短路："><a href="#基于拓扑排序的寻找带负权边的DAG最短路：" class="headerlink" title="基于拓扑排序的寻找带负权边的DAG最短路："></a>基于拓扑排序的寻找带负权边的DAG最短路：</h2><p>一般Dijkstra算法无法解决负权边问题在于，提前已经假设好了某一点的最短路径，不容许改变。<strong>而拓扑排序则保证了在遍历到节点V之前，若路径上含有负权边，则一定被提前考虑过了。</strong></p><p>其余则按照拓扑顺序逐条松弛出边即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; shorestPath(int source)&#123;</span><br><span class="line">  vector&lt;int&gt; tpOrder = tpsort();//拓扑顺序</span><br><span class="line">  vector&lt;int&gt; dist(V, INF);</span><br><span class="line">  dist[source] = 0;</span><br><span class="line">  for(int u: tpOrder)&#123;</span><br><span class="line">    if(dist[u] != INF)&#123;</span><br><span class="line">       for(auto &amp;edge: adj[u])&#123;</span><br><span class="line">         int v = edge.first;</span><br><span class="line">         int weight = edge.second;</span><br><span class="line">         if(dist[v] &gt; dist[u] + weight)&#123;</span><br><span class="line">           dist[v] = dist[u] +weight;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DAG上的最长路径："><a href="#DAG上的最长路径：" class="headerlink" title="DAG上的最长路径："></a>DAG上的最长路径：</h2><p>即将DAG的边权重全部取为负数。再运行一次上述的最短路算法，将结果取负即可。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PROJ0&amp;&amp;HK1の学习笔记</title>
      <link href="/2025/09/15/PROJ0-HK1%E3%81%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/09/15/PROJ0-HK1%E3%81%AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的分支</title>
      <link href="/2025/09/15/Git%E7%9A%84%E5%88%86%E6%94%AF/"/>
      <url>/2025/09/15/Git%E7%9A%84%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="分支介绍："><a href="#分支介绍：" class="headerlink" title="分支介绍："></a>分支介绍：</h1><h2 id="git-commit的存储对象："><a href="#git-commit的存储对象：" class="headerlink" title="git commit的存储对象："></a>git commit的存储对象：</h2><p>包括暂存对象内容的指针，提交信息，指向父节点的指针</p><p>每次提交的过程都会保留为：</p><ul><li>各个文件对象(Blob对象)；</li><li>本次提交所记录的项目完整结构和所有文件内容(树对象)；</li><li>指向树对象的指针(包括<strong>提交的信息</strong>和<strong>指向前一对象的指针</strong>)。</li></ul><p>例如：</p><p>假设现有一个工作目录，里面有三个将被暂存与提交的文件。现执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add README test.rb LICENSE</span><br><span class="line">git commit -m &#x27;this is the initial commit&#x27;</span><br></pre></td></tr></table></figure><p>那么此时git仓库里就有5个对象：</p><p>三个文件对象(Blob对象)；一个树对象；指向该树的对象(附加提交信息和指向前树的指针)；</p><h2 id="git的分支："><a href="#git的分支：" class="headerlink" title="git的分支："></a>git的分支：</h2><p>本质上就是指向提交对象的可变指针。在多次提交后，就已经有了指向了最后一个提交对象的master分支。master分支会在每次提交时自动向前移动。</p><h3 id="分支的创建："><a href="#分支的创建：" class="headerlink" title="分支的创建："></a>分支的创建：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &lt;分支名&gt;</span><br></pre></td></tr></table></figure><p>会在当前提交对象上创建一个新分支；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">master(默认分支)</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">98ca9  ←─┐</span><br><span class="line">  │      │</span><br><span class="line">  ▼      testing(新分支)</span><br><span class="line">34ac2    </span><br><span class="line">  │      </span><br><span class="line">  ▼      </span><br><span class="line">f30ab    </span><br></pre></td></tr></table></figure><p><strong>git是通过HEAD指针来判断当前处于哪一个分支上的</strong>。</p><p>故当前实际上也是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">master(默认分支)&lt;-----HEAD</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">98ca9  ←─┐</span><br><span class="line">  │      │</span><br><span class="line">  ▼      testing(新分支)</span><br><span class="line">34ac2    </span><br><span class="line">  │      </span><br><span class="line">  ▼      </span><br><span class="line">f30ab</span><br></pre></td></tr></table></figure><p><strong>使用git log的–decorate参数可以查看各个分支当前所指的对象：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --decorate</span><br><span class="line">&gt;f30ab (HEAD -&gt; master, testing) add feature #32 - ability to add new formats to the central interface</span><br><span class="line">34ac2 Fixed bug #1328 - stack overflow under certain conditions</span><br><span class="line">98ca9 The initial commit of my project</span><br></pre></td></tr></table></figure><h3 id="分支切换："><a href="#分支切换：" class="headerlink" title="分支切换："></a>分支切换：</h3><p>若我们想要切换当前所处的分支，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;目标分支&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout testing</span><br></pre></td></tr></table></figure><p>得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">master(默认分支)</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">98ca9  ←─┐</span><br><span class="line">  │      │</span><br><span class="line">  ▼      testing(新分支)&lt;-----HEAD</span><br><span class="line">34ac2    </span><br><span class="line">  │      </span><br><span class="line">  ▼      </span><br><span class="line">f30ab</span><br></pre></td></tr></table></figure><p>实际意义是什么呢？</p><p>我们再提交一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">                 master  testing &lt;--HEAD</span><br><span class="line">                    │       |</span><br><span class="line">                    ▼       ▼</span><br><span class="line">98ca9 ←─ 34ac2 ←─ f30ab ←─ 87ab2</span><br></pre></td></tr></table></figure><p>再切换回master分支，<strong>此时我们就实现了文件的版本回溯。</strong></p><p>再提交一次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        98ca9</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">        34ac2</span><br><span class="line">         │</span><br><span class="line">         ▼      </span><br><span class="line">testing f30ab</span><br><span class="line">   ↓  ↗     ↖</span><br><span class="line"> 87ab2       c2b9e &lt;--master&lt;--HEAD</span><br></pre></td></tr></table></figure><p>此时就形成了分支结构</p><p><strong>新增分支的简写形式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;新分支名&gt;</span><br><span class="line">就相当于：</span><br><span class="line">git branch iss53</span><br><span class="line">git checkout iss53</span><br></pre></td></tr></table></figure><p>相对引用：</p><p>使用^向上移动一个提交记录；</p><p>使用~<num>向上移动多个提交记录；</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout main^</span><br></pre></td></tr></table></figure><p>即移动到main的父节点；</p><p>HEAD也可以作为相对引用的参照节点；</p><h3 id="git分支的高效性："><a href="#git分支的高效性：" class="headerlink" title="git分支的高效性："></a>git分支的高效性：</h3><p>由于git的保存实质上就是文件的检验和(长度为40的sha-1字符串),所以使得分支的创建与销毁都很高效。</p><h2 id="分支的合并："><a href="#分支的合并：" class="headerlink" title="分支的合并："></a>分支的合并：</h2><p>假如目前处于状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">       98ca9</span><br><span class="line">         │</span><br><span class="line">         ▼</span><br><span class="line">        34ac2</span><br><span class="line">         │</span><br><span class="line">         ▼      </span><br><span class="line">testing f30ab</span><br><span class="line">   ↓  ↗     ↖</span><br><span class="line"> 87ab2       c2b9e &lt;--master&lt;--HEAD</span><br></pre></td></tr></table></figure><p>目前在master分支上工作，目前想要将testing分支上的结果整合进master分支中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge testing</span><br></pre></td></tr></table></figure><h3 id="合并的三方合并："><a href="#合并的三方合并：" class="headerlink" title="合并的三方合并："></a>合并的三方合并：</h3><p>因为目前master分支所在的文件并不是testing分支的直接祖先，故需要进行三方合并：</p><p>定位到两个分支的LCA，以及两个分支分别的最后提交结果。<strong>将三方合并的结果进行一个快照并自动创建一个提交指向它，被称为一次合并提交。</strong></p><p>合并结束后，testing分支无作用了，故应该直接删掉它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d testing</span><br></pre></td></tr></table></figure><h3 id="合并冲突："><a href="#合并冲突：" class="headerlink" title="合并冲突："></a>合并冲突：</h3><p>当我们再两个文件的相同位置做了不同的修改，就会发生合并冲突：</p><p>合并到中途文件为止，且无法提交。解决方法：</p><p>git status 查看因冲突而无法合并的文件(unmerged)</p><p>直接打开文件，git会自动加上标注，形如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</span><br><span class="line">=======</span><br><span class="line">&lt;div id=&quot;footer&quot;&gt;</span><br><span class="line"> please contact us at support@github.com</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;上方为当前所在分支的冲突文件内容，下方为合并分支的，清晰地指出了冲突内容。</p><h2 id="分支管理："><a href="#分支管理：" class="headerlink" title="分支管理："></a>分支管理：</h2><p>常用的一些分支管理工具：</p><ul><li><strong>git branch</strong> 不加参数，可以得到当前所有分支的列表：</li></ul><p>​       (前带有*的branch，表示是当前HEAD指针的指向分支)</p><ul><li><strong>–merge</strong> 与 <strong>–no-merge</strong> 查看是否合并到当前分支的对象：</li></ul><p>​       作用：对于已经合并的分支我们就可以直接删除了。</p><h2 id="远程分支："><a href="#远程分支：" class="headerlink" title="远程分支："></a>远程分支：</h2><p>远程引用是对远程仓库的引用，包括指针，标签……</p><h3 id="列出："><a href="#列出：" class="headerlink" title="列出："></a>列出：</h3><p>通过git ls-remote <remote>来获取远程引用的列表；</p><p>git remote show <remote> 来获取更加详细的信息；</p><h3 id="远程跟踪分支："><a href="#远程跟踪分支：" class="headerlink" title="远程跟踪分支："></a>远程跟踪分支：</h3><p>使用<remote> &#x2F; <branch> 来命名。与本地的同名分支相区别。</p><p>不使用git fetch <remote>操作抓取远程库，远程跟踪指针就不会移动</p><h3 id="推送："><a href="#推送：" class="headerlink" title="推送："></a>推送：</h3><p>将自己的修改上传到远程库中</p><p>例如：想与他人在testing分支上一起工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin testing</span><br></pre></td></tr></table></figure><p>当想要在自己的分支上继续执行抓取的文件的后续操作，可以建立在远程跟踪分支之上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b serverfix origin/serverfix</span><br></pre></td></tr></table></figure><h3 id="跟踪分支："><a href="#跟踪分支：" class="headerlink" title="跟踪分支："></a>跟踪分支：</h3><p>上述建立的serverfix分支即为远程库origin的跟踪分支。</p><p>是与远程分支有直接联系的本地分支。</p><p>在跟踪分支上直接使用pull操作，能自动识别到哪个服务器上抓取与合并。</p><p><strong>git branch -vv查看所有本地分支及信息：</strong></p><p>如：正在跟踪哪个远程分支，与本地分支是否领先。</p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line">  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets</span><br><span class="line">  master    1ae2a45 [origin/master] deploying index fix</span><br><span class="line">* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it</span><br><span class="line">  testing   5ea463a trying something new</span><br></pre></td></tr></table></figure><p>ahead 2表示本地有2个提交还未推送；</p><p>ahead 3 behind 1表示：本地有3个提交未推送，且服务器有1个提交未合并到本地。</p><hr><p>注意这里统计的数据都是上一次抓取fetch的结果。</p><p>若想统计最新数据可以操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch -all; git branch -vv;</span><br></pre></td></tr></table></figure><hr><h3 id="拉取："><a href="#拉取：" class="headerlink" title="拉取："></a>拉取：</h3><p>区别于git fetch ，git fetch是抓取数据，需要你自己合并；</p><p>而git pull 是抓取数据后，自动合并到远程跟踪分支。</p><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支:"></a>删除远程分支:</h3><p>可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; --delete &lt;branch&gt;</span><br></pre></td></tr></table></figure><h2 id="变基："><a href="#变基：" class="headerlink" title="变基："></a>变基：</h2><p>在git中整合不同分支的修改主要为两种方法：merge 与 rebase</p><p>回顾merge的流程：</p><p>采用三角定位，形成结果的快照并提交：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C feature</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure><p>变为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C feature</span><br><span class="line">     /         \</span><br><span class="line">D---E---F---G---H master</span><br></pre></td></tr></table></figure><p>rebase的工作流程：</p><p>对于初始状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      A---B---C feature</span><br><span class="line">     /</span><br><span class="line">D---E---F---G master</span><br></pre></td></tr></table></figure><p>首先找到两个分支的LCA(最近公共祖先)，即为E；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>提取差异并保存：</p><p>保存从E开始的A,B,C的所有差异，保存为差异文件；</p><p>重置基指针：</p><p>将feature分支指针移动到G上，并重新播放差异文件，生成新提交A’, B’, C’。</p><p>新提交的内容不变，但hash值与时间戳发生了改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D---E---F---G [master]</span><br><span class="line">            |</span><br><span class="line">            A&#x27;--B&#x27;--C&#x27;[feature]</span><br></pre></td></tr></table></figure><p>快进合并：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure><p>实现为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D---E---F---G---A&#x27;---B&#x27;---C&#x27; master</span><br></pre></td></tr></table></figure><p>形象理解：</p><p>想象一下你在拍电影：</p><ul><li><strong>原始拍摄（正常提交）</strong>：你在场景A（E）拍了一系列戏（A,B,C）。</li><li><strong>导演要求</strong>：现在导演说：”我觉得这段戏不应该基于场景A，而应该基于场景B（G）来拍。”</li><li><strong>重拍（Rebase）</strong>：于是，你让演员<strong>重新表演一次完全相同的戏份</strong>，但这次是在场景B（G）中拍摄。</li></ul><p><strong>结果</strong>：戏的内容（修改）完全一样，但背景（基提交）不同了，所以这算是<strong>一部新的影片</strong>（新的提交）。</p><p>实际意义：</p><p>向远程推送时，使历史提交记录为线性结构，更加整洁；</p><p>风险：</p><p>它会丢弃掉一些现有提交，而生成一些内容相同但实际不同的提交。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具-Git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie树</title>
      <link href="/2025/09/14/Trie%E6%A0%91/"/>
      <url>/2025/09/14/Trie%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="Trie的引入："><a href="#Trie的引入：" class="headerlink" title="Trie的引入："></a>Trie的引入：</h1><p>当我们要查询某一字符串时，根据现有的数据结构，可能会有以下几种选择：</p><ul><li>Hash表：<ul><li>哈希表中的元素是无序存储的，每次搜索前缀时，均需要遍历O(N);</li></ul></li><li>BST:<ul><li>首先找到匹配的前缀就需要O(logN)的时间，其次需要以中序遍历搜索所有prexxx的字符串。故总时间复杂度为O( K + logN),且不知道K具体会有多大。</li></ul></li></ul><h1 id="Trie的原理："><a href="#Trie的原理：" class="headerlink" title="Trie的原理："></a>Trie的原理：</h1><h3 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h3><p>用空间来换取时间，用字符串的公共前缀来降低搜索的时间复杂度。</p><h3 id="基本性质："><a href="#基本性质：" class="headerlink" title="基本性质："></a>基本性质：</h3><ul><li><p>根节点不包括字符。其余每一个节点均包括一个字符；</p></li><li><p>以路径表示字符串；</p></li><li><p>对于终点进行标记；</p></li></ul><h1 id="Trie的实现："><a href="#Trie的实现：" class="headerlink" title="Trie的实现："></a>Trie的实现：</h1><p>根据数组来实现trie树：</p><p>维护两个数组：</p><ul><li>son[N] [26]: 第一维表示节点，第二维表示每个节点最多有26个子节点(字母总数)</li><li>cnt[N]: cnt[p]表示以字符p结尾的路径个数</li></ul><h2 id="插入操作："><a href="#插入操作：" class="headerlink" title="插入操作："></a>插入操作：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void insert (char* str)&#123;</span><br><span class="line">  int p = 0; //从根节点开始遍历</span><br><span class="line">  for(int i = 0; str[i]; ++i)&#123;</span><br><span class="line">     int u = str[i] - &#x27;a&#x27;;  //转化成对应数值</span><br><span class="line">     if(!son[p][u])&#123;  //若没有对应子节点，则创建</span><br><span class="line">         son[p][u] = ++idx;</span><br><span class="line">     &#125;</span><br><span class="line">     p = son[p][u];</span><br><span class="line">  &#125;</span><br><span class="line">  cnt[p] ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询操作："><a href="#查询操作：" class="headerlink" title="查询操作："></a>查询操作：</h2><p>(以特定字母结尾的字符串个数)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int query(char* str)&#123;</span><br><span class="line">   int p = 0;</span><br><span class="line">   for(int i = 0; str[i]; ++i)&#123;</span><br><span class="line">     int u = str[i] - &#x27;a&#x27;;</span><br><span class="line">     if(!son[p][u])&#123;</span><br><span class="line">         return 0; </span><br><span class="line">     &#125;</span><br><span class="line">     p = son[p][u];</span><br><span class="line">   &#125;</span><br><span class="line">   return cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h1><p>虽然占用的空间开销较大，但插入与查询操作均加速到了O(L);</p><p>L为字符串的长度。均与N无关。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基本使用</title>
      <link href="/2025/09/14/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/09/14/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git基础："><a href="#Git基础：" class="headerlink" title="Git基础："></a>Git基础：</h1><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><p>通常有两种方式：</p><p>1，将尚未进行版本控制的文件目录转化为git仓库。</p><p>2，从其他服务器上克隆一个已存在的仓库。</p><h3 id="在已存在目录中初始化仓库："><a href="#在已存在目录中初始化仓库：" class="headerlink" title="在已存在目录中初始化仓库："></a>在已存在目录中初始化仓库：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>会得到一个名为.git的子目录</p><h3 id="克隆一份现有的仓库："><a href="#克隆一份现有的仓库：" class="headerlink" title="克隆一份现有的仓库："></a>克隆一份现有的仓库：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;url&gt;</span><br></pre></td></tr></table></figure><p>注意git复制的不仅仅是全部文件，更包括了远程仓库中的每个文件的每个版本。</p><h4 id="自定义仓库名："><a href="#自定义仓库名：" class="headerlink" title="自定义仓库名："></a>自定义仓库名：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;url&gt; name</span><br></pre></td></tr></table></figure><h4 id="git支持多种数据传输协议："><a href="#git支持多种数据传输协议：" class="headerlink" title="git支持多种数据传输协议："></a>git支持多种数据传输协议：</h4><p>1，https:&#x2F;&#x2F;协议；</p><p>2，git:&#x2F;&#x2F;协议；</p><p>3，SSH协议：<strong>username@server:path&#x2F;to&#x2F;repo.git</strong></p><h2 id="记录更新到仓库："><a href="#记录更新到仓库：" class="headerlink" title="记录更新到仓库："></a>记录更新到仓库：</h2><h3 id="文件的状态："><a href="#文件的状态：" class="headerlink" title="文件的状态："></a>文件的状态：</h3><p>工作目录下的文件只有两种状态：跟踪；未跟踪。</p><p>已跟踪文件：已纳入版本控制的文件，在上一次的快照中存在，git已经知道存在的文件；</p><p>未跟踪文件：既不存在于上一次的快照记录中，也没有被放在暂存区中。</p><p><strong>文件的三种状态：</strong></p><p>1，已提交(commited):数据已经保存在本地数据库中；</p><p>2，以修改(modefied):修改了文件，但未保存进数据库；</p><p>3，已暂存(staged):对一个已修改文件的当前版本进行了标记，使之包含在下次提交的快照中。</p><p><strong>git的工作流程</strong>：</p><p>1，在工作区中修改文件；</p><p>2，将想要提交的文件提交到暂存区中；</p><p>3，提交更新，提交暂存区中文件的快照；</p><h3 id="检查文件当前状态："><a href="#检查文件当前状态：" class="headerlink" title="检查文件当前状态："></a>检查文件当前状态：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>会特别列出还未跟踪的文件；</p><h3 id="跟踪新文件："><a href="#跟踪新文件：" class="headerlink" title="跟踪新文件："></a>跟踪新文件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 新文件名</span><br></pre></td></tr></table></figure><p> 跟踪指向的文件，并将其放在暂存区中。</p><p>而此时若我们再次对新文件进行修改，此时再查看git status，会发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">No commits yet</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   README</span><br></pre></td></tr></table></figure><p>README文件同时出现在了暂存区与非暂存区。实际上此时暂存区里存的是上一次git add时的文件版本。我们需要再次git add以存入最新版本。</p><p><strong>综上，git add的作用实际上是：将最新内容精确加到下次提交中。</strong></p><h4 id="状态简览："><a href="#状态简览：" class="headerlink" title="状态简览："></a>状态简览：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s 或git status -short</span><br></pre></td></tr></table></figure><p>可以用简化的方式查看更改：</p><ul><li>新添加的未跟踪文件前面有 <code>??</code> 标记；</li><li>新添加到暂存区中的文件前面有 <code>A</code> 标记；</li><li>修改过的文件前面有 <code>M</code> 标记</li></ul><h3 id="忽略文件："><a href="#忽略文件：" class="headerlink" title="忽略文件："></a>忽略文件：</h3><p>当我们有些文件无需被跟踪时，进行忽略标注：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat .gitignore</span><br><span class="line">*.[oa]</span><br></pre></td></tr></table></figure><p>忽略对象表达式是用正则写的。</p><h3 id="查看修改内容："><a href="#查看修改内容：" class="headerlink" title="查看修改内容："></a>查看修改内容：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>可以查看<strong>尚未暂存的文件内容与暂存区的文件内容</strong>的差异，具体哪里被修改了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --staged 或 git diff --cached</span><br></pre></td></tr></table></figure><p>可以查看<strong>暂存区的内容与上一次提交内容</strong>的差异。</p><h3 id="提交更新："><a href="#提交更新：" class="headerlink" title="提交更新："></a>提交更新：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><h4 id="跳过暂存区域提交："><a href="#跳过暂存区域提交：" class="headerlink" title="跳过暂存区域提交："></a>跳过暂存区域提交：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure><p>自动把所有已跟踪的文件暂存起来，一并提交。</p><h3 id="移除文件："><a href="#移除文件：" class="headerlink" title="移除文件："></a>移除文件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm 文件名</span><br></pre></td></tr></table></figure><p>将文件从暂存区移除，提交记录。同时从工作目录中删除该文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件名</span><br></pre></td></tr></table></figure><p>从暂存区移除，但在工作目录中不删除。</p><h3 id="重命名文件："><a href="#重命名文件：" class="headerlink" title="重命名文件："></a>重命名文件：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv pre_name new_name</span><br></pre></td></tr></table></figure><p>就相当于执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv pre_name new_name</span><br><span class="line">git rm pre_name</span><br><span class="line">git add now_name</span><br></pre></td></tr></table></figure><h2 id="查看提交历史："><a href="#查看提交历史：" class="headerlink" title="查看提交历史："></a>查看提交历史：</h2><p>在提交了若干更新，或克隆下来一个项目时，想要查看历史提交修改，提交记录，可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure><h3 id="git-log的查询选项："><a href="#git-log的查询选项：" class="headerlink" title="git log的查询选项："></a>git log的查询选项：</h3><h4 id="显示每次提交的差异："><a href="#显示每次提交的差异：" class="headerlink" title="显示每次提交的差异："></a>显示每次提交的差异：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p 或 git log -patch</span><br></pre></td></tr></table></figure><h4 id="总结性选项："><a href="#总结性选项：" class="headerlink" title="总结性选项："></a>总结性选项：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --start</span><br></pre></td></tr></table></figure><p>–stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。</p><h4 id="个性化显示："><a href="#个性化显示：" class="headerlink" title="个性化显示："></a>个性化显示：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log pretty=format</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;</span><br><span class="line">ca82a6d - Scott Chacon, 6 years ago : changed the version number</span><br><span class="line">085bb3b - Scott Chacon, 6 years ago : removed unnecessary test</span><br><span class="line">a11bef0 - Scott Chacon, 6 years ago : first commit</span><br></pre></td></tr></table></figure><p><code>git log --pretty=format</code> 常用的选项</p><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td>%H</td><td>提交的完整哈希值</td></tr><tr><td>%h</td><td>提交的简写哈希值</td></tr><tr><td>%T</td><td>树的完整哈希值</td></tr><tr><td>%P</td><td>父提交的完整哈希</td></tr><tr><td>%an</td><td>修改者名字</td></tr><tr><td>%cn</td><td>提交者名字</td></tr><tr><td>%cd</td><td>提交日期</td></tr></tbody></table><h4 id="图形展示历史："><a href="#图形展示历史：" class="headerlink" title="图形展示历史："></a>图形展示历史：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --graph</span><br></pre></td></tr></table></figure><h4 id="过滤器："><a href="#过滤器：" class="headerlink" title="过滤器："></a>过滤器：</h4><h5 id="限制显示的日志数量："><a href="#限制显示的日志数量：" class="headerlink" title="限制显示的日志数量："></a>限制显示的日志数量：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -p -2</span><br></pre></td></tr></table></figure><p>(显示最近2次记录)</p><h5 id="按照时间限制："><a href="#按照时间限制：" class="headerlink" title="按照时间限制："></a>按照时间限制：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --since=2.weeks</span><br></pre></td></tr></table></figure><p>列出最近两周的提交</p><h5 id="按照作者限制："><a href="#按照作者限制：" class="headerlink" title="按照作者限制："></a>按照作者限制：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log author=xxx</span><br></pre></td></tr></table></figure><h5 id="仅显示指定字符串的删改："><a href="#仅显示指定字符串的删改：" class="headerlink" title="仅显示指定字符串的删改："></a>仅显示指定字符串的删改：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -S 字符串</span><br></pre></td></tr></table></figure><p>实例：</p><p>查看 Junio Hamano 在 2008 年 10 月其间， 除了合并提交之外的哪一个提交修改了测试文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log -pretty=&quot;%h - %s&quot; --author=&#x27;Junio Hamano&#x27; --since=&quot;2008-10-01&quot; --before=&quot;2008-11-01&quot; --no-merges -- t</span><br></pre></td></tr></table></figure><h2 id="撤销操作："><a href="#撤销操作：" class="headerlink" title="撤销操作："></a>撤销操作：</h2><h3 id="覆盖重新提交："><a href="#覆盖重新提交：" class="headerlink" title="覆盖重新提交："></a>覆盖重新提交：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>会将暂存区的文件提交。提交后，打开文本编辑器，会显示上一次的提交信息。修改保存后，会覆盖掉原有提交(包括历史记录)</p><p>实例场景：</p><p>提交后忘记暂存某个重要修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &#x27;initial commit&#x27;</span><br><span class="line">git add forgotten_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>你最终只会有一个提交</p><h3 id="取消暂存："><a href="#取消暂存：" class="headerlink" title="取消暂存："></a>取消暂存：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git resetHEAD 目标文件</span><br></pre></td></tr></table></figure><h3 id="撤销对文件的修改："><a href="#撤销对文件的修改：" class="headerlink" title="撤销对文件的修改："></a>撤销对文件的修改：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --&lt;file&gt;</span><br></pre></td></tr></table></figure><p>用最近的一次提交来覆盖掉当前修改的版本。</p><h2 id="远程仓库的使用："><a href="#远程仓库的使用：" class="headerlink" title="远程仓库的使用："></a>远程仓库的使用：</h2><h3 id="查看远程仓库："><a href="#查看远程仓库：" class="headerlink" title="查看远程仓库："></a>查看远程仓库：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><p>列出你指定的每一个远程服务器的简写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>显示需要读写的仓库的简写及其url</p><h3 id="添加远程仓库："><a href="#添加远程仓库：" class="headerlink" title="添加远程仓库："></a>添加远程仓库：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add &lt;简写&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure><p>例如你已经执行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add pb https://github.com/paulboone/ticgit</span><br></pre></td></tr></table></figure><p>现在想拉取目标仓库中有而你没有的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch pb</span><br></pre></td></tr></table></figure><h3 id="从远程仓库中抓取与拉取："><a href="#从远程仓库中抓取与拉取：" class="headerlink" title="从远程仓库中抓取与拉取："></a>从远程仓库中抓取与拉取：</h3><p>从远程仓库中获取自己没有的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch &lt;remote&gt;</span><br></pre></td></tr></table></figure><p>若使用clone克隆了一个仓库，命令会自动将其添加为远程仓库，并命名为origin。所以<strong>git fetch origin</strong>会自动抓取上次抓取之后推送的所有新动作。</p><h3 id="推送到远程仓库："><a href="#推送到远程仓库：" class="headerlink" title="推送到远程仓库："></a>推送到远程仓库：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>将你的branch分支上的内容推送到remote远程仓库中。</p><h3 id="远程仓库的重命名与移除："><a href="#远程仓库的重命名与移除：" class="headerlink" title="远程仓库的重命名与移除："></a>远程仓库的重命名与移除：</h3><p>可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rename &lt;now_name&gt; &lt;new_name&gt; </span><br></pre></td></tr></table></figure><p>来给一个远程仓库重命名</p><p>可以使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove &lt;简写名&gt; 或 git remote rm...</span><br></pre></td></tr></table></figure><p>来移除一个远程仓库。</p><h2 id="标签："><a href="#标签：" class="headerlink" title="标签："></a>标签：</h2><p>可以给仓库里的某个提交打上标签，以示重要性。</p><h3 id="列出标签："><a href="#列出标签：" class="headerlink" title="列出标签："></a>列出标签：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><p>以字母顺序列出标签。</p><p>若需要按照通配符列出对应标签，需要使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -1 “V1.8.5*” (示例)</span><br></pre></td></tr></table></figure><h3 id="创建标签："><a href="#创建标签：" class="headerlink" title="创建标签："></a>创建标签：</h3><p><strong>标签分为：轻量标签和附注标签。</strong></p><p>轻量标签只是某个特定提交的引用；而附注标签是一个存储在git数据库中的完整对象，包括许多author’s name，date…..的信息</p><h4 id="附注标签："><a href="#附注标签：" class="headerlink" title="附注标签："></a>附注标签：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 标签名 -m &quot;存储在标签中的信息&quot;</span><br></pre></td></tr></table></figure><p>通过git show就可以查看标签信息，及其对应的提交信息；</p><h4 id="轻量标签："><a href="#轻量标签：" class="headerlink" title="轻量标签："></a>轻量标签：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 标签名</span><br></pre></td></tr></table></figure><p>将提交检验和存储到一个文件中，无其他附加信息。</p><h4 id="后期打标签："><a href="#后期打标签：" class="headerlink" title="后期打标签："></a>后期打标签：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a 标签名 提交的检验和</span><br></pre></td></tr></table></figure><p>提交的检验和即是：Hash值的前7位，或整个Hash值。</p><h3 id="共享标签："><a href="#共享标签：" class="headerlink" title="共享标签："></a>共享标签：</h3><p>一般下，git push不会把标签随文件一起推送到远程库中。</p><p>创建标签后，必须手动推送标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;标签名&gt;</span><br></pre></td></tr></table></figure><p>或者一次性推送所有标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h3 id="删除标签："><a href="#删除标签：" class="headerlink" title="删除标签："></a>删除标签：</h3><ul><li>删除本地的标签：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><ul><li>还需要手动更新远程仓库：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1，git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>​        含义：将冒号前的空值推送至远程的标签名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2，git push &lt;remote&gt; --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>​        直接删除</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/2025/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2025/09/12/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是最小生成树："><a href="#什么是最小生成树：" class="headerlink" title="什么是最小生成树："></a>什么是最小生成树：</h1><ul><li>仅仅针对于无向图；</li><li>包含了所有的顶点；</li><li>符合树的定义：连通，无环。</li><li>最小：使得边权相加的结果最小。</li></ul><p><strong>最短路径树与源起点紧密相关；而最小生成树是一个全局概念，与从何处开始无关。</strong></p><h1 id="切割属性："><a href="#切割属性：" class="headerlink" title="切割属性："></a>切割属性：</h1><p>对于图集(V,  E)，将V个点分给两个非空集合，构成两个点集S，(V - S)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">切割属性的定义：</span><br><span class="line"></span><br><span class="line">跨越连接两个点集的最小权重边必然包含于最小生成树中。</span><br></pre></td></tr></table></figure><hr><p><strong>证明：</strong></p><p>设最小生成树T不包含最小权重边S &#x3D; (u, v)。取而代之的是F边。</p><ol><li><p>现在构造一颗新的生成树T‘：</p></li><li><p>从T中移除F边；</p></li><li><p>然后加入我们讨论的最小权重边S；</p></li></ol><p>现在T’的总权重 &#x3D; T的总权重 - weight(F) + weight(S);</p><p>又因为weight(S) &lt; weight(F)。故有T’的总权重小于T的总权重。</p><p>但我们假设的是T未最小生成树，故与题意相违背。</p><hr><p>接下来介绍几种查找MST的算法：</p><h1 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h1><h2 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h2><p>在每一步，逐步连接当前已在MST中的顶点与尚未在MST中的顶点集合间的最小权重边，直至所有顶点都在MST中。</p><h2 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h2><p>两个关键数组：</p><p>dist数组：维护每个顶点到<strong>当前MST集合</strong>的最小边权重；</p><p><strong><u>(注意此点与dijkstra算法的区别，dikstra算法是维护到起点单点的最短距离，prim算法维护的是到MST集合的距离。但代码其余部分基本与dijkstra算法相似)</u></strong></p><p>parent数组：记录每个新节点加入后是和哪个节点相连的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int, int&gt; PII; //(distance, node)</span><br><span class="line"></span><br><span class="line">void prim(int start int V)&#123;</span><br><span class="line"> memset(dist, int, sizeof dist);</span><br><span class="line"> memset(parent, -1, sizeof parent);</span><br><span class="line"> bool inMST[N];</span><br><span class="line"> memset(inMST, false, sizeof inMST);</span><br><span class="line"> dist[start] = 0;</span><br><span class="line"> priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line"> pq.push(&#123;0, start&#125;);</span><br><span class="line"> while(pq.size())&#123;</span><br><span class="line">   //选取当前对MST集合距离最近的点，贪心的体现。</span><br><span class="line">   int cur_node = pq.top().second;</span><br><span class="line">   pq.pop();</span><br><span class="line">   if(inMST[cur_node]) continue;</span><br><span class="line">   inMST[cur_node] = true;</span><br><span class="line">   for(auto&amp; neighbor: graph[cur_node])&#123;</span><br><span class="line">      int v = neighbor.first;</span><br><span class="line">      int weight = neight.second;</span><br><span class="line">      //不在MST中，且找到了更小权边。</span><br><span class="line">      if(!inMST[v] &amp;&amp; weight &lt; dist[v])&#123;</span><br><span class="line">         dist[v] = weight;</span><br><span class="line">         parent[v] = u;</span><br><span class="line">         pq.push(&#123;dist[v], v&#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><ul><li>初始化：O(V);</li><li>push操作：O（VlogV）[优先队列是基于二叉堆实现的]</li><li>pop操作：O (VlogV)</li><li>遍历相连边：O(E)</li><li>push更新操作：O（ElogV)</li></ul><p><strong>故总复杂度为：O((V + E) logV)</strong></p><h1 id="Kruskal算法："><a href="#Kruskal算法：" class="headerlink" title="Kruskal算法："></a>Kruskal算法：</h1><h2 id="核心思想：-1"><a href="#核心思想：-1" class="headerlink" title="核心思想："></a>核心思想：</h2><ul><li>将图中的所有边按权重从小到大进行排序；</li><li>从权重最小的边开始，一次考虑每一条边；</li><li>若加入当前的环会与已选择的边之间形成环，则跳过；</li><li>当已选边数 &#x3D; 顶点数 - 1时，停止循环。</li></ul><h2 id="数据结构实现基础-并查集-："><a href="#数据结构实现基础-并查集-：" class="headerlink" title="数据结构实现基础(并查集)："></a>数据结构实现基础(并查集)：</h2><p>并查集用来判断两个顶点是否连通，以及用来合并两个连通分量。</p><p><strong>主循环流程：</strong></p><ul><li><p>取出最小权重边；</p></li><li><p>检查环(使用并查集的find函数):</p><ul><li>若根节点相同，说明u与v已经连通，加入会构成环；</li><li>若根节点不同，说明不在同一连通快，可以加入；</li></ul></li><li><p>合并：</p><ul><li>加入MST集合；</li><li>使用union操作，将u和v的集合合并。</li></ul></li><li><p>结束：</p></li></ul><p>当MST集合中包含V - 1条边时，结束。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">struct Edge&#123;</span><br><span class="line"> int u, v, weight;</span><br><span class="line"> bool operator&lt;(const Edge&amp; other)&#123;</span><br><span class="line">   return weight &lt; other.weight;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line"> if(parent[x] != x)&#123;</span><br><span class="line">   parent[x] = find(parent[x]);</span><br><span class="line"> &#125;</span><br><span class="line"> return parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void union(int x, int y)&#123;</span><br><span class="line">  int rootx = find(x);</span><br><span class="line">  int rooty = find(y);</span><br><span class="line">  if(rootx == rooty) return;</span><br><span class="line">  //按秩合并</span><br><span class="line">  if(rank_[rootx] &lt; rank_[rooty])&#123;</span><br><span class="line">     parent[rootx] = rooty;</span><br><span class="line">  &#125;</span><br><span class="line">  else if(rank_[rootx] &gt; rank_[rooty])&#123;</span><br><span class="line">     parent[rooty] = rootx;</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123; //相等时，任意合并，但秩要增加</span><br><span class="line">     parent[rootx] = rooty;</span><br><span class="line">     rank_[rooty]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">int kruskal(int V, vector&lt;Edge&gt;&amp; edges)&#123;</span><br><span class="line">  sort(edges.begin(), edges.end());</span><br><span class="line">  //初始化并查集相关数组</span><br><span class="line">  for(int i = 0; i &lt; V; ++i)&#123;</span><br><span class="line">     parent[i] = i;</span><br><span class="line">     rank_[i] = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  int mstweight = 0;</span><br><span class="line">  int usededges = 0;</span><br><span class="line">  for(Edge&amp; e: edges)&#123;</span><br><span class="line">     if(usededges == V - 1)&#123;</span><br><span class="line">        break;</span><br><span class="line">     &#125;</span><br><span class="line">     int rootU = find(e.u);</span><br><span class="line">     int rootV = find(e.v);</span><br><span class="line">     if(rootU != rootV)&#123; //合并</span><br><span class="line">       union(rootU, rootV);</span><br><span class="line">       mstweight += e.weight;</span><br><span class="line">       usededges ++;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return mstweight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析：-1"><a href="#时间复杂度分析：-1" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h2><p>由于压缩路径后的并查集操作均为反阿克曼函数，均可视为常数</p><p>故主要是排序的O(ElogV);</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="/2025/09/11/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2025/09/11/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="图的遍历："><a href="#图的遍历：" class="headerlink" title="图的遍历："></a>图的遍历：</h1><h2 id="广度优先搜索："><a href="#广度优先搜索：" class="headerlink" title="广度优先搜索："></a>广度优先搜索：</h2><h3 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h3><p>一层层地向外扩展，先访问起点的相邻节点，再访问相邻节点的相邻节点…..</p><h3 id="数据结构实现基础："><a href="#数据结构实现基础：" class="headerlink" title="数据结构实现基础："></a>数据结构实现基础：</h3><p>队列：用来存储遍历到了，但还没有访问其所有邻接节点的节点。其先进先出的结构符合一层层传递的特性。</p><h3 id="代码框架："><a href="#代码框架：" class="headerlink" title="代码框架："></a>代码框架：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; edges[N];</span><br><span class="line">void bfs(int st, int target)&#123;</span><br><span class="line"> int vis[N];</span><br><span class="line"> memset(vis, 0, sizeof vis);</span><br><span class="line"> queue&lt;int&gt; a;</span><br><span class="line"> a.push(st);</span><br><span class="line"> vis[st] = 1;</span><br><span class="line"> while(a.size())&#123;</span><br><span class="line">   int q = a.front();</span><br><span class="line">   a.pop();</span><br><span class="line">   if(q == target) return;</span><br><span class="line">   for(int i = 0; i &lt; edges[q].size(); ++i)&#123;</span><br><span class="line">       int now = edges[q][i];</span><br><span class="line">       if(!vis[now])&#123;</span><br><span class="line">         vis[now] = 1;</span><br><span class="line">         a.push(now);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bfs的特点就决定了其可以找到最短路径：(<strong>当路径没有权重</strong>)</p><p>由于其是一层层遍历的，第一次找到了目标点，即是最短路径。</p><h2 id="深度优先搜索："><a href="#深度优先搜索：" class="headerlink" title="深度优先搜索："></a>深度优先搜索：</h2><h3 id="核心思想：-1"><a href="#核心思想：-1" class="headerlink" title="核心思想："></a>核心思想：</h3><p>就是一条路走到黑，直到当前节点没有未遍历的节点为止，才开始进行回溯。</p><h3 id="数据结构实现基础：-1"><a href="#数据结构实现基础：-1" class="headerlink" title="数据结构实现基础："></a>数据结构实现基础：</h3><p>栈：在迭代过程中自动实现，其后进先出的特点，正好满足了优先探索最新节点的需求。</p><h3 id="代码框架：-1"><a href="#代码框架：-1" class="headerlink" title="代码框架："></a>代码框架：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector edges[N];</span><br><span class="line">int vis[N];</span><br><span class="line">void dfs(int idx)&#123;</span><br><span class="line">  if(vis[idx])&#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  vis[idx] = 1;</span><br><span class="line">  for(int i = 0; i &lt; edges[idx].size(); ++i)&#123;</span><br><span class="line">        dfs(edges[idx][i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时两者的性能比较："><a href="#运行时两者的性能比较：" class="headerlink" title="运行时两者的性能比较："></a>运行时两者的性能比较：</h2><ul><li>对于细长图，dfs明显更差，迭代递归次数过多，容易造成爆栈问题；</li><li>对于bushy图，bfs明显更差，队列会被大量使用。</li></ul><p><strong>对于bfs查找最短路径时的问题：</strong></p><p>相对更短路径定义模糊，当边存在权重时，更短的定义往往根据题意而定。</p><p>所以当路径有权重时，我们还需要设计另一种算法来计算。</p><h1 id="Dijkstra算法："><a href="#Dijkstra算法：" class="headerlink" title="Dijkstra算法："></a>Dijkstra算法：</h1><h2 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>1，创建优先级队列；</p><p>2，将起点s以优先级0加入priority_queue;</p><p>​      将其他所有点以优先级inf加入priority_queue;</p><p>3，当队列不为空时，弹出顶点，并松弛从顶点出发的所有边。</p><h2 id="核心思想：-2"><a href="#核心思想：-2" class="headerlink" title="核心思想："></a>核心思想：</h2><p><strong>贪心算法+松弛操作；</strong></p><p><strong>1，全局的最优路径可以不断地通过局部最优路径累计得到；</strong></p><p>​    原理：当目前弹出的顶点是V1，说明V1目前是距离start最近的点。若后续操作中V1到start的距离可以被进一步更新，则说明必定存在V2到start的距离更短，前后相矛盾。</p><p><strong>2，松弛操作：通过不断更新和改进估计的距离最优值，逼近最优策略；</strong></p><p>​    具体：记现在的dist[now]为最佳距离，遍历当前队列弹出的顶点ver的所有边，检查是否有dist[ver] + weight[ver] [now] &lt; dist[now]，然后用来更新dist[now]的值。</p><p><strong>NOTICE: 我们不会再用其他顶点来松弛已访问过的顶点的，因为它的最短距离已经确定过了，无需再次更新。</strong></p><h2 id="代码框架实现："><a href="#代码框架实现：" class="headerlink" title="代码框架实现："></a>代码框架实现：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int, int&gt; PII;  //(distance, node)</span><br><span class="line">vector&lt;vector&lt;PII&gt;&gt; graph;</span><br><span class="line">bool st[N];</span><br><span class="line">void dijkstra(int s, vector&lt;int&gt;&amp; dist)&#123;</span><br><span class="line">   int n = graph.size();</span><br><span class="line">   for(int i = 0; i &lt; n;++i)&#123;</span><br><span class="line">      dist[i] = inf;</span><br><span class="line">   &#125;</span><br><span class="line">   dist[s] = 0;</span><br><span class="line">   priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">   pq.push(&#123;0, s&#125;);</span><br><span class="line">   while(pq.size())&#123;</span><br><span class="line">     int node = pq.top().second;</span><br><span class="line">     int dis = pq.top().first;</span><br><span class="line">     pq.pop();</span><br><span class="line">     if(st[node]) continue;</span><br><span class="line">     st[node] = true;</span><br><span class="line">     for(int i = 0; i &lt; graph[node].size(); ++i)&#123;</span><br><span class="line">       int cur_node = graph[node][i].second;</span><br><span class="line">       int cur_weight = graph[node][i].first;</span><br><span class="line">       if(dist[node] + cur_weight &lt; dist[cur_node])&#123;</span><br><span class="line">          dist[cur_node] = dist[node] + cur_weight;</span><br><span class="line">          pq.push(&#123;dist[cur_node], cur_node&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊情况："><a href="#特殊情况：" class="headerlink" title="特殊情况："></a>特殊情况：</h2><p>当出现负权边时，该算法不成立。因为负权边的存在使得 <strong>”““当前弹出的点的最小距离不会再次改变”“</strong>这点不成立。因为有可能前半段距离很长，但突然经过一个负权边补偿后，举例又变小。</p><h1 id="A-算法："><a href="#A-算法：" class="headerlink" title="A*算法："></a>A*算法：</h1><p>A *本质上是Dijkstra的一种启发式改进。如果说Dijkstra算法是一种从source以同心圆的形式逐步一圈圈向外扩散。那么A *算法则是给定一个大致的前进方向，大大缩减了需要遍历检查的节点数量。</p><h2 id="核心思想：-3"><a href="#核心思想：-3" class="headerlink" title="核心思想："></a>核心思想：</h2><p>为每一个节点计算一个代价函数F(n)，并以代价函数作为优先级来比较。</p><p>F(n) &#x3D; G(n) + H(n);</p><ul><li>G(n)：从起始点到当前节点的准确距离；</li><li>H(n)：从当前节点n到目标节点的预估成本。通常采用直线距离或曼哈顿距离。</li><li>F(n)：通过节点n的路径的预估总成本。</li></ul><h2 id="具体代码框架："><a href="#具体代码框架：" class="headerlink" title="具体代码框架："></a>具体代码框架：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;double, int&gt; PII;  //(f_score, 节点)</span><br><span class="line">vector&lt;vector&lt;PII&gt;&gt; graph;</span><br><span class="line">bool st[N];</span><br><span class="line">int g[N];</span><br><span class="line">int came_from[N];</span><br><span class="line">double get_dist(int a, int b)&#123;</span><br><span class="line">  return num ;  //结合具体计算直线距离...</span><br><span class="line">&#125;</span><br><span class="line">void A_star(int start, int goal, vector&lt;int&gt;&amp; path)&#123;</span><br><span class="line">    int n = graph.size();</span><br><span class="line">    memset(g, inf, sizeof g);</span><br><span class="line">    memset(came_from, -1, sizeof came_from);</span><br><span class="line">    g[start] = 0;</span><br><span class="line">    double f_score = g[start] + get_dist(start, goal);</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; pq;</span><br><span class="line">    pq.push(&#123;f_score, start&#125;);</span><br><span class="line">    while(pq.size())&#123;</span><br><span class="line">       double current_f = pq.top().first;</span><br><span class="line">       int node = pq.top().second;</span><br><span class="line">       pq.pop();</span><br><span class="line">       if(st[node]) continue;</span><br><span class="line">       st[node] = true;</span><br><span class="line">       //记录路径</span><br><span class="line">       if(node == goal)&#123;</span><br><span class="line">          path.clear();</span><br><span class="line">          for(int node = goal; node != -1; node = came_from[node])&#123;</span><br><span class="line">             path.push_back(node);</span><br><span class="line">          &#125;</span><br><span class="line">          reverse(path.begin(), path.end());</span><br><span class="line">          return;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       for(int i = 0; i &lt; graph[node].size(); ++i)&#123;</span><br><span class="line">          int edge_weight = graph[node][i].first;</span><br><span class="line">          int neighbor = graph[node][i].second;</span><br><span class="line">          if(st[neighbor]) continue;</span><br><span class="line">          if(g[node] + edge_weight &lt; g[neighbor])&#123;</span><br><span class="line">             g[neighbor] = g[node] + edge_Weight;</span><br><span class="line">             double f_score = g[neighbor] + get_dist(neighbor, goal);</span><br><span class="line">             pq.push(&#123;f_score, neighbor&#125;);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：A*算法同样无法处理负权边的图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树的遍历与图</title>
      <link href="/2025/09/10/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/"/>
      <url>/2025/09/10/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>什么是树：</p><p>1，一组连接的节点；</p><p>2，连接这些节点的一组边；</p><p>​      (限制：没有一组边可以形成一个循环。即从一个节点到任意另一个节点没有第二条路径)；</p><p>树的遍历方式：</p><p>考虑到树的分支结构，对于树的遍历(迭代)有以下两种方式：</p><p>1, level_order遍历：广度优先搜索(BFS)</p><p>2, 深度优先遍历(DFS): 其中有三种方式前序，中序，后序。</p><p>以下面这个树为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    D</span><br><span class="line">   / \</span><br><span class="line">  B   F</span><br><span class="line"> / \   \</span><br><span class="line">A   C   G</span><br></pre></td></tr></table></figure><p>前序遍历：</p><p>基本思路：打印出当前节点；向左走，递归；向右走，递归；</p><p>遵循这个逻辑，将得到顺序D B A C F G。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preOrder(Node x)&#123;</span><br><span class="line">  if(x == null) return;</span><br><span class="line">  print(x.key);</span><br><span class="line">  preOrder(x.left);</span><br><span class="line">  preOrder(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><p>假设我们当前处于D，知道向左遍历会打印出左节点，向右遍历会得到右节点。又已知我们想要得到的顺序为： [左起项目] D [右起项目]。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inOrder(Node x)&#123;</span><br><span class="line">  if(x == null) return;</span><br><span class="line">  inorder(x.left);</span><br><span class="line">  print(x.key);</span><br><span class="line">  inorder(x.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><p>按照我们刚刚提到的思路，我们目标想要得到的顺序为：[D左起项目] [D右起项目] D</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">postOrder(Node x)&#123;</span><br><span class="line">   if(x == null) return;</span><br><span class="line">   postOrder(x.left);</span><br><span class="line">   postOrder(x.right);</span><br><span class="line">   print(x.key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图：</p><p>组成：</p><p>1，一组节点；</p><p>2，一组边，每条边连接两个节点。</p><p>与树的关键区别在于：<strong>图中没有限制</strong>。边可以形成环，两个顶点之间也可以有多条路径。</p><p>图的实现：</p><p>1，邻接矩阵：</p><p>核心思想：</p><p>用邻接矩阵–一个二维数组。</p><ul><li>如果图中存在从顶点 <code>i</code> 到顶点 <code>j</code> 的边，那么 <code>matrix[i][j] = 1</code>（或边的权重）。</li><li>如果不存在这条边，那么 <code>matrix[i][j] = 0</code>（或一个特殊值，如无穷大 <code>∞</code>）。</li></ul><p>优点：</p><p>查询连接关系快: O(1);</p><p>添加删除关系快：O(1);</p><p>缺点：</p><p>占用空间大：即使图很稀疏，也需要V^2的空间。</p><p>遍历邻接点慢：找到顶点V的，必须扫描整个第V行。</p><p>2，邻接表：</p><p>核心思想：</p><p>为每一个顶点都维护一个链表&#x2F;数组：</p><p>存储所有与该顶点直接相连的邻接节点。</p><p>优点：</p><p>1，空间效率高：O(V + E).</p><p>2, 遍历邻接点快。</p><p>缺点：</p><p>查询路径是否存在慢，需要逐步遍历链表并迭代。</p><p>边列表：</p><p>核心思想：</p><p>直接用一个数组存储图中的所有边。U和V之间有权重为W的边，则直接有m[U] [V] &#x3D; W;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modern SQL(MySQL为例)</title>
      <link href="/2025/09/09/Modern-SQL/"/>
      <url>/2025/09/09/Modern-SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL由三种类别命令组成："><a href="#SQL由三种类别命令组成：" class="headerlink" title="SQL由三种类别命令组成："></a>SQL由三种类别命令组成：</h1><p>1，数据操作语言(DML): SELECT、INSERT、UPDATE 和 DELETE 语句。</p><p>2，数据定义语言(DDL)：表、索引、视图和其他对象的架构定义。</p><p>3，数据控制语言(DCL)：安全性，控制访问。</p><p>关系模型基于的是Set(有序，不可重复)；而SQL基于的是bag(无序，可重复)。</p><h1 id="关系模型："><a href="#关系模型：" class="headerlink" title="关系模型："></a>关系模型：</h1><h2 id="主键："><a href="#主键：" class="headerlink" title="主键："></a>主键：</h2><p>在关系数据库中，一张表的一行数据被称为一条记录。一条记录由多个字段组成。</p><p>对于关系表，有一个重要约束：任意两条记录不能重复。</p><p>不能重复并非指内容不能完全相同，而是能通过某一字段唯一区分出不同的记录，这个字段称为 “主键”。</p><h3 id="主键的选取原则："><a href="#主键的选取原则：" class="headerlink" title="主键的选取原则："></a>主键的选取原则：</h3><p>不能使用业务相关的字段作为主键。</p><p>常用的可作为id字段的类型有：</p><p>1，自增整数类型：记录插入时，系统自动发配一个自增整数。</p><p>2，全局唯一GUID类型：通过GUID算法，保证任一生成的均不同。</p><h3 id="联合主键："><a href="#联合主键：" class="headerlink" title="联合主键："></a>联合主键：</h3><p>还允许多个字段来唯一标识一条记录，只要不是所有主键列均重复即可。</p><h2 id="外键："><a href="#外键：" class="headerlink" title="外键："></a>外键：</h2><h3 id="一对多："><a href="#一对多：" class="headerlink" title="一对多："></a>一对多：</h3><p>在使用主键唯一确定一条记录后，我们可以在student表中确定任意一个学生的记录。我们还可以在class表中确定任意一个班级信息。那么我们如何确定某一个学生是属于哪一个班级的？</p><p>因为一个班级可以拥有多个学生，属于一对多关系。</p><p>故需要再student表中加入class_id，反映与class表的对应关系。</p><p><strong>这种可以把数据与另外一张表相关联的列，称为外键。</strong></p><p>外键不是通过加新列实现的，而是通过定义外键约束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT fk_class_id  //指定外键约束的名称为fk_class_id.</span><br><span class="line">FOREIGN KEY (class_id)   //指定class_id作为外键</span><br><span class="line">REFERENCES classes (id); //指定这个外键将关联到classes表的id列。</span><br></pre></td></tr></table></figure><p>删除一个外键约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">DROP FOREIGN KEY fk_class_id;</span><br></pre></td></tr></table></figure><p>注意删除外键约束，只是删掉了关联关系，并没有删掉这一列。</p><p>删除列是通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP COLUMN ....</span><br></pre></td></tr></table></figure><p> 来实现的</p><h3 id="多对多："><a href="#多对多：" class="headerlink" title="多对多："></a>多对多：</h3><p>例如一个班级可以对应多个老师，一个老师可以对应多个班级。</p><p>多对多关系的实现，实际上通过一个中间表实现的。中间表将实际对应关系一个个阐明清楚。</p><h3 id="一对一："><a href="#一对一：" class="headerlink" title="一对一："></a>一对一：</h3><p>实际需要：如在存储学生的联系方式时，可能某个学生没有联系方式，则这个学生在contacts表中就没有对应的记录。</p><h2 id="索引："><a href="#索引：" class="headerlink" title="索引："></a>索引：</h2><p>对于关系数据库中的大量记录，使用索引可以在查询时加速。</p><p>索引是一种对某一列或多列进行预排列的数据结构。</p><h3 id="索引的创建："><a href="#索引的创建：" class="headerlink" title="索引的创建："></a>索引的创建：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD INDEX idx_score(score);</span><br></pre></td></tr></table></figure><p>创建了一个名为idx_score，使用列score的索引。</p><p>索引支持多列。</p><h3 id="索引的效率："><a href="#索引的效率：" class="headerlink" title="索引的效率："></a>索引的效率：</h3><p>该列的值越不相同，索引的查询效率就越高。</p><p>索引的优点：增快了查询速度；</p><p>索引的缺点：在插入，更新，删除记录时，同时也要改变索引。因此索引越多，其他操作越慢。</p><p>主键的索引效率是最高的。</p><h3 id="唯一索引："><a href="#唯一索引：" class="headerlink" title="唯一索引："></a>唯一索引：</h3><p>在设计表时，那些看上去唯一的列，如身份证号，由于具有业务相关性，不能充当索引，此时就可以为这一列加上唯一索引，使得这一列的数值不能出现重复。</p><p>主键是特殊的唯一索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD UNIQUE INDEX uni_name (name);</span><br></pre></td></tr></table></figure><p>此例通过unique关键词添加了唯一索引。</p><p>通过添加唯一约束，也可实现相同效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD CONSTRAINT uni_name UNIQUE (name);</span><br></pre></td></tr></table></figure><h1 id="查询数据："><a href="#查询数据：" class="headerlink" title="查询数据："></a>查询数据：</h1><h2 id="基本查询："><a href="#基本查询：" class="headerlink" title="基本查询："></a>基本查询：</h2><h3 id="查询students表的所有数据："><a href="#查询students表的所有数据：" class="headerlink" title="查询students表的所有数据："></a>查询students表的所有数据：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt;</span><br></pre></td></tr></table></figure><p><strong>SELECT为查询的关键字； * 表示所有列；FROM表示从哪个表中进行查询。</strong></p><h3 id="without-FROM子句的SELECT操作："><a href="#without-FROM子句的SELECT操作：" class="headerlink" title="without FROM子句的SELECT操作："></a>without FROM子句的SELECT操作：</h3><ul><li><p>SELECT语句可以进行简单计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 100+200</span><br><span class="line">&gt; 300</span><br></pre></td></tr></table></figure></li><li><p>用来判断当前到数据库的连接是否有效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1;</span><br></pre></td></tr></table></figure></li></ul><h2 id="条件查询："><a href="#条件查询：" class="headerlink" title="条件查询："></a>条件查询：</h2><h3 id="通过where条件语句来设定查询条件："><a href="#通过where条件语句来设定查询条件：" class="headerlink" title="通过where条件语句来设定查询条件："></a>通过where条件语句来设定查询条件：</h3><p>例如：查找指定分数在80以上的学生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><p>故条件查询的基本语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表名&gt; where &lt;条件&gt;</span><br></pre></td></tr></table></figure><h3 id="多个条件的书写："><a href="#多个条件的书写：" class="headerlink" title="多个条件的书写："></a>多个条件的书写：</h3><ul><li>符合条件1和条件2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE &lt;条件1&gt; AND &lt;条件2&gt;</span><br></pre></td></tr></table></figure><ul><li>符合条件1或条件2：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE &lt;条件1&gt; OR &lt;条件2&gt;</span><br></pre></td></tr></table></figure><ul><li><p>组合三个及以上的条件语句：</p><p>用()表示如何进行运算。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students WHERE (score &lt; 80 AND score &gt; 90) AND gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="常用的条件表达式："><a href="#常用的条件表达式：" class="headerlink" title="常用的条件表达式："></a>常用的条件表达式：</h3><table><thead><tr><th>条件</th><th>举例</th><th>说明</th></tr></thead><tbody><tr><td>判断相等使用&#x3D;</td><td>name &#x3D; ’xiong_mi_lan‘</td><td>字符串需要用单引号括起来</td></tr><tr><td>使用&lt;&gt;判断不相等</td><td>score &lt;&gt; 80</td><td></td></tr><tr><td>使用LIKE判断相似</td><td>name LIKE ‘ab%’</td><td>%表示任意字符。例中将匹配：’ab’, ‘abc’, ‘abcd’…</td></tr></tbody></table><h3 id="COALESCE函数："><a href="#COALESCE函数：" class="headerlink" title="COALESCE函数："></a>COALESCE函数：</h3><p>COALESCE(e1, e2, e3,……)将返回参数列表中第一个非null的值。</p><p>用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COALESCE(A, 2023)；</span><br></pre></td></tr></table></figure><p>将为null的A值转换为2023；</p><h2 id="投影查询："><a href="#投影查询：" class="headerlink" title="投影查询："></a>投影查询：</h2><p>以上的SELECT * 我们所得到的都是二维表。</p><p>若我们只想要得到某些列的数据。我们可以采用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列1，列2，列3 FROM ...</span><br></pre></td></tr></table></figure><p>这种操作被称为投影查询。</p><h3 id="重命名："><a href="#重命名：" class="headerlink" title="重命名："></a>重命名：</h3><p>使用投影查询时，我们还可以给每一列起一个别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列1 别名1，列2 别名2 FROM ...</span><br></pre></td></tr></table></figure><h3 id="where语句-投影查询："><a href="#where语句-投影查询：" class="headerlink" title="where语句+投影查询："></a>where语句+投影查询：</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score FROM students WHERE gender = &#x27;M&#x27;;</span><br></pre></td></tr></table></figure><h2 id="排序："><a href="#排序：" class="headerlink" title="排序："></a>排序：</h2><h3 id="ORDER-BY-语句："><a href="#ORDER-BY-语句：" class="headerlink" title="ORDER BY 语句："></a>ORDER BY 语句：</h3><p>当我们使用SELECT查询时，默认是按照id从小到大进行排序的。</p><p>ORDER BY 语句支持我们自定义排序依据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, gender, score FROM students ORDER BY score;</span><br></pre></td></tr></table></figure><h3 id="倒序的实现："><a href="#倒序的实现：" class="headerlink" title="倒序的实现："></a><strong>倒序的实现：</strong></h3><p>可以在句末加上DESC关键字，进行从大到小排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT score FROM students ORDER BY score DESC;</span><br></pre></td></tr></table></figure><p>升序的关键字是：ASC。默认省略</p><h3 id="对于存在相同数据的处理："><a href="#对于存在相同数据的处理：" class="headerlink" title="对于存在相同数据的处理："></a><strong>对于存在相同数据的处理：</strong></h3><p>可以继续添加列名，进行进一步的排序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, score, gender FROM students ORDER BY score DESC, id DESC;</span><br></pre></td></tr></table></figure><p>先按照score的倒序排序，score相同时，再按照id的倒序排序。</p><p><strong>补充：</strong></p><p>ORDER BY 语句位置应处于句末。****</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, gender, score</span><br><span class="line">FROM students</span><br><span class="line">WHERE class_id = 1</span><br><span class="line">ORDER BY score DESC</span><br></pre></td></tr></table></figure><h2 id="分页查询："><a href="#分页查询：" class="headerlink" title="分页查询："></a>分页查询：</h2><p>对于很大的数据量，放在同一个页面，画面未免有些太过拥挤，不如分页展示。</p><p><strong>基本语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 最多几条记录 OFFSET 从哪条开始(start)</span><br></pre></td></tr></table></figure><p><strong>start的计算公式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start = pageSize * (pageIndex - 1)</span><br></pre></td></tr></table></figure><p>假如一页最多三条记录，查询第二页的内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, gender, score</span><br><span class="line">FROM students</span><br><span class="line">ORDER BY score</span><br><span class="line">LIMIT 3 OFFSET 3;</span><br></pre></td></tr></table></figure><p><strong>简写形式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 15 OFFSET 30，还可以简写为 LIMIT 30, 15。</span><br></pre></td></tr></table></figure><h2 id="聚合查询："><a href="#聚合查询：" class="headerlink" title="聚合查询："></a>聚合查询：</h2><p>统计总记录数，计算平均数，使用聚合函数可以得到快速的查询。</p><p>查询总数可以使用count函数：</p><h3 id="查询所有列的行数："><a href="#查询所有列的行数：" class="headerlink" title="查询所有列的行数："></a>查询所有列的行数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) FROM students</span><br></pre></td></tr></table></figure><p><strong>注意：查询的结果其实仍是一个二维表，只是为1行1列，并且列名为COUNT(*)。</strong></p><p>所以通常查询时会设置一个别名，表示统计结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students;</span><br></pre></td></tr></table></figure><p>同样可以使用WHERE语句进行条件判断：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) num FROM students </span><br><span class="line">WHERE score &gt;= 80;</span><br></pre></td></tr></table></figure><h3 id="其他聚合函数："><a href="#其他聚合函数：" class="headerlink" title="其他聚合函数："></a>其他聚合函数：</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SUM</td><td>计算某一列的合计值，该列必须为数值类型</td></tr><tr><td>AVG</td><td>计算平均值，必须为数值类型</td></tr><tr><td>MAX</td><td>计算某列最大值</td></tr><tr><td>MIN</td><td>计算某列最小值</td></tr></tbody></table><h3 id="分组聚合："><a href="#分组聚合：" class="headerlink" title="分组聚合："></a>分组聚合：</h3><p>若我们想要知道每一班的总人数分别是多少，可以使用GROUP BY函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT class_id, COUNT(*) num FROM students </span><br><span class="line">GROUP BY class_id;</span><br></pre></td></tr></table></figure><p>按照class_id来分组，统计人数。</p><h3 id="分组后的筛选关键字："><a href="#分组后的筛选关键字：" class="headerlink" title="分组后的筛选关键字："></a>分组后的筛选关键字：</h3><p>可以使用HAVING关键字来筛选GROUP BY之后产生的小组。</p><p>WHERE关键字只能在分组前进行筛选。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.cid, COUNT(e.sid) AS student_count</span><br><span class="line">FROM enrolled e</span><br><span class="line">GROUP BY e.cid  -- 按课程分组</span><br><span class="line">HAVING COUNT(e.sid) &gt; 5;  -- 筛选出选课人数&gt;5的课程组</span><br></pre></td></tr></table></figure><h2 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h2><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM &lt;表1&gt;, &lt;表2&gt;；</span><br></pre></td></tr></table></figure><p>返回的是一个二维表，表1与表2的合并结果。每一行都两两拼接而成。</p><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>在通常下我们会设置别名来进行统一区分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    students.id sid,</span><br><span class="line">    students.name,</span><br><span class="line">    students.gender,</span><br><span class="line">    students.score,</span><br><span class="line">    classes.id cid,</span><br><span class="line">    classes.name cname</span><br><span class="line">FROM students, classes;</span><br></pre></td></tr></table></figure><p>多表查询时可以使用<strong>表名.列名</strong> 的形式来设置引用列。</p><h2 id="连接查询："><a href="#连接查询：" class="headerlink" title="连接查询："></a>连接查询：</h2><p>是另一种类型的的多表查询。</p><p>实质上就是对于多个表进行join操作：</p><p>先确定一个主表作为结果集，然后把其他表的行有选择性地连在主表结果集上。</p><h3 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN:"></a>INNER JOIN:</h3><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 选出所有学生，同时返回对应的班级名称</span><br><span class="line">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.gender</span><br><span class="line">FROM students s</span><br><span class="line">INNER JOIN classes c</span><br><span class="line">on s.classes_id = c.id;</span><br></pre></td></tr></table></figure><p><strong>INNER JOIN查询的语法为</strong>：</p><p>1，先确定主表，仍然使用SELECT FROM 语句</p><p>2，确定需要连接的表，INNER JOIN &lt;表2&gt;</p><p>3，确定连接条件，使用 on &lt;条件….&gt;</p><p><strong>特点：</strong></p><p><strong>返回的结果只会有同时存在于两张表中的行数据。</strong></p><h3 id="RIGHT-OUTER-JOIN"><a href="#RIGHT-OUTER-JOIN" class="headerlink" title="RIGHT OUTER JOIN:"></a>RIGHT OUTER JOIN:</h3><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT S.id, S.name, S.class_id, C.name class_name</span><br><span class="line">FROM students S</span><br><span class="line">RIGHT OUTER JOIN classes C</span><br><span class="line">ON C.class_id = C.id;</span><br></pre></td></tr></table></figure><p><strong>RIGHT OUTER JOIN 返回右表中都存在的行，若某行仅在右表中存在，则会以NULL填充剩余字段。</strong></p><p><u>LEFT OUTER JOIN 同理类推。</u></p><p><u>FULL OUTER JOIN 同理会返回两张表的所有记录，并填充NULL进对方不存在的列。</u></p><h1 id="修改数据："><a href="#修改数据：" class="headerlink" title="修改数据："></a>修改数据：</h1><h2 id="插入数据："><a href="#插入数据：" class="headerlink" title="插入数据："></a>插入数据：</h2><p><strong>基本语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; (字段1，字段2，字段3,...) VALUES (值1，值2，值3...)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#x27;xiaoming&#x27;, &#x27;M&#x27;, 80);</span><br></pre></td></tr></table></figure><p>还可以一次性添加多条记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (class_id, name, gender, score) VALUES</span><br><span class="line"> (1, &#x27;ONE&#x27;, &#x27;M&#x27;, 87),</span><br><span class="line"> (2, &#x27;TWO&#x27;, &#x27;M&#x27;, 90);</span><br></pre></td></tr></table></figure><h2 id="更新数据："><a href="#更新数据：" class="headerlink" title="更新数据："></a>更新数据：</h2><p>更新表中<strong>已存在</strong>记录的值。</p><p><strong>基本语法：(UPDATE语句)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE &lt;表名&gt; SET 字段1=值1，字段2=值2，字段3=值3，...WHERE...;</span><br></pre></td></tr></table></figure><p>例如：更新id &#x3D; 1的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE students SET name=&#x27;xiaoming&#x27;, score=66 WHERE id=1;</span><br></pre></td></tr></table></figure><p>当没有WHERE语句时，默认修改的是全表。</p><h2 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h2><p>删除数据使用DELETE语句：</p><p><strong>基本语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM &lt;表名&gt; WHERE ...;</span><br></pre></td></tr></table></figure><p>例如删除id&#x3D;1的记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM students WHERE id=1;</span><br></pre></td></tr></table></figure><p>同样没有WHERE语句时，会删除整个表。</p><h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL:"></a>MYSQL:</h1><h2 id="管理MySQL"><a href="#管理MySQL" class="headerlink" title="管理MySQL:"></a>管理MySQL:</h2><h3 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a>数据库：</h3><p>在一个mysql服务器上，可以创建多个数据库。</p><h4 id="枚列："><a href="#枚列：" class="headerlink" title="枚列："></a>枚列：</h4><p>可以通过命令 SHOW DATABASES，列出所有的数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW DATABASES;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| shici              |</span><br><span class="line">| sys                |</span><br><span class="line">| test               |</span><br><span class="line">| school             |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><p>其中，<code>information_schema</code>、<code>mysql</code>、<code>performance_schema</code>和<code>sys</code>是系统库，不要去改动它们。其他的是用户创建的数据库。</p><h4 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE test;</span><br></pre></td></tr></table></figure><h4 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DROP DATABASE test;</span><br></pre></td></tr></table></figure><h4 id="切换当前数据库："><a href="#切换当前数据库：" class="headerlink" title="切换当前数据库："></a>切换当前数据库：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; USE test;</span><br></pre></td></tr></table></figure><h3 id="表："><a href="#表：" class="headerlink" title="表："></a>表：</h3><h4 id="列出当前数据库的所有表："><a href="#列出当前数据库的所有表：" class="headerlink" title="列出当前数据库的所有表："></a>列出当前数据库的所有表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_test      |</span><br><span class="line">+---------------------+</span><br><span class="line">| classes             |</span><br><span class="line">| statistics          |</span><br><span class="line">| students            |</span><br><span class="line">| students_of_class1  |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h4 id="查看一个表的结构："><a href="#查看一个表的结构：" class="headerlink" title="查看一个表的结构："></a>查看一个表的结构：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC students；</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id       | bigint(20)   | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| class_id | bigint(20)   | NO   |     | NULL    |                |</span><br><span class="line">| name     | varchar(100) | NO   |     | NULL    |                |</span><br><span class="line">| gender   | varchar(1)   | NO   |     | NULL    |                |</span><br><span class="line">| score    | int(11)      | NO   |     | NULL    |                |</span><br><span class="line">+----------+--------------+------+-----+---------+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><h4 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt;；</span><br></pre></td></tr></table></figure><h4 id="创建表时的数值类型指定："><a href="#创建表时的数值类型指定：" class="headerlink" title="创建表时的数值类型指定："></a>创建表时的数值类型指定：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATETABLE student(</span><br><span class="line">sid INT PRIMARYKEY,</span><br><span class="line">name VARCHAR(16),</span><br><span class="line">login VARCHAR(32) UNIQUE,</span><br><span class="line">age SMALLINT,</span><br><span class="line">gpa FLOAT</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建的sid，数据类型为整数，约束为主键—-非空且唯一，这张表的索引标识；</p><p>创建的name，数据类型为可变长度的字符串，最多可存储16个字符。</p><p>创建的login，数据类型为可变长的string最多存32个，且约束为唯一；</p><p>创建的age，数据类型为SMALLINT，范围小于INT.</p><p>创建的gpa，类型为浮点数。</p><h4 id="创建外键关联："><a href="#创建外键关联：" class="headerlink" title="创建外键关联："></a>创建外键关联：</h4><p>如一个多对多关联表enrolled—-建立student表与course表之间的映射：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE enrolled(</span><br><span class="line">sid INT REFERENCES student(sid),</span><br><span class="line">cid VARCHAR(32)REFERENCES course(cid),</span><br><span class="line">grade CHAR(1)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>创建int类型的sid，引用的值来自于student表中的sid；</p><p>创建VARCHAR类型的cid，引用的值来自于course表中的cid；</p><p>创建CHAR类型的grade，表示等级。</p><h4 id="去重关键字：DISTINCT"><a href="#去重关键字：DISTINCT" class="headerlink" title="去重关键字：DISTINCT"></a>去重关键字：DISTINCT</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT login)</span><br><span class="line">FROM student WHERE login LIKE &#x27;%@cs&#x27;;</span><br></pre></td></tr></table></figure><p>在login字段的值中，相同的只取一次。</p><h4 id="删除表："><a href="#删除表：" class="headerlink" title="删除表："></a>删除表：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE &lt;表名&gt;；</span><br></pre></td></tr></table></figure><h4 id="修改表："><a href="#修改表：" class="headerlink" title="修改表："></a>修改表：</h4><h5 id="新增一列："><a href="#新增一列：" class="headerlink" title="新增一列："></a>新增一列：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">ADD COLUMN 列名 数据类型 [约束条件] [位置];</span><br></pre></td></tr></table></figure><p>例如：</p><p>新增一列数据类型为VARCHAR(10)，不为空的birth列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE students</span><br><span class="line">ADD COLUMN birth VARCHAR(10) NOT NULL;</span><br></pre></td></tr></table></figure><h5 id="修改列："><a href="#修改列：" class="headerlink" title="修改列："></a>修改列：</h5><p>将ADD关键字改为CHANGE即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">CHANGE COLUMN 列名 数据类型 [约束条件] [位置];</span><br></pre></td></tr></table></figure><h5 id="删除列："><a href="#删除列：" class="headerlink" title="删除列："></a>删除列：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt;</span><br><span class="line">DROP COLUMN 列名;</span><br></pre></td></tr></table></figure><h3 id="退出MySQL"><a href="#退出MySQL" class="headerlink" title="退出MySQL:"></a>退出MySQL:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXIT</span><br></pre></td></tr></table></figure><p><u>注意EXIT仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。</u></p><h2 id="实用SQL语句："><a href="#实用SQL语句：" class="headerlink" title="实用SQL语句："></a>实用SQL语句：</h2><h3 id="插入或替换："><a href="#插入或替换：" class="headerlink" title="插入或替换："></a>插入或替换：</h3><p>插入新记录，若存在则替换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE INTO 表名 (字段1，字段2...) VALUES (值1，值2...);</span><br></pre></td></tr></table></figure><h3 id="插入或更新："><a href="#插入或更新：" class="headerlink" title="插入或更新："></a>插入或更新：</h3><p>插入新记录，若存在则更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名 (字段1，字段2...) VALUES (值1，值2...);</span><br></pre></td></tr></table></figure><h3 id="插入或忽略："><a href="#插入或忽略：" class="headerlink" title="插入或忽略："></a>插入或忽略：</h3><p>插入新纪录，若存在则忽略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT IGNORE INTO 表名 (字段1，字段2...) VALUES (值1，值2...);</span><br></pre></td></tr></table></figure><h3 id="快照："><a href="#快照：" class="headerlink" title="快照："></a>快照：</h3><p>复制当前的表的数据到一个新表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 新表名 SELECT * FROM 表名 WHERE...</span><br></pre></td></tr></table></figure><h3 id="创建查询结果集："><a href="#创建查询结果集：" class="headerlink" title="创建查询结果集："></a>创建查询结果集：</h3><p>例：创建统计成绩的表，记录各班的平均成绩</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE anser(</span><br><span class="line">   id BIGINT NOT NULL AUTO_INCREMENT(自动递增，生成唯一id),</span><br><span class="line">   class_id BIGINT NOT NULL,</span><br><span class="line">   average DOUBLE NOT NULL,</span><br><span class="line">   PRIMARY KEY (id) (设置主键为id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="CTE语句-公用表表达式："><a href="#CTE语句-公用表表达式：" class="headerlink" title="CTE语句-公用表表达式："></a>CTE语句-公用表表达式：</h2><p>CTE是一个临时的结果集，一个临时的视图，只在它所在的语句中生效。是嵌套结构的优化版</p><h3 id="基本语法：-1"><a href="#基本语法：-1" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WITH 为这个结果集起的名字 [column_name[列名1，列名2...]] AS(</span><br><span class="line">--CTE的查询定义</span><br><span class="line">SELECT...</span><br><span class="line">)</span><br><span class="line">--主查询，使用上面定义的临时结果集</span><br><span class="line">SELECT * FROM 结果集名;</span><br></pre></td></tr></table></figure><p>WITH关键字表示开始一个CTE语句块。</p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><h4 id="基本用法-避免复杂的嵌套"><a href="#基本用法-避免复杂的嵌套" class="headerlink" title="基本用法(避免复杂的嵌套):"></a>基本用法(避免复杂的嵌套):</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WITH avg_salary AS (</span><br><span class="line">   SELECT AVG(salary) AS avg_sal FROM employees</span><br><span class="line">)</span><br><span class="line">SELECT</span><br><span class="line">  e.name,</span><br><span class="line">  e.salary,</span><br><span class="line">  a.avg_sal</span><br><span class="line">FROM employees e, avg_salary a</span><br><span class="line">WHERE e.salary &gt;a.avg_sal;</span><br></pre></td></tr></table></figure><h4 id="递归用法："><a href="#递归用法：" class="headerlink" title="递归用法："></a>递归用法：</h4><p>计算从1到10 的和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WITH RECURSIVE cte_re (counter) AS (</span><br><span class="line">  (SELECT 1)    ---锚定成员，产生初始结果集，递归起点，只执行一次</span><br><span class="line">  UNION         -----合并结果集。</span><br><span class="line">  (SELECT counter + 1 FROM cte_re  --递归成员，查询上一次的counter结果，并执行+1操作</span><br><span class="line">   WHERE counter &lt; 10)</span><br><span class="line">)</span><br><span class="line">SELECT * FROM cte_re;</span><br></pre></td></tr></table></figure><h2 id="输出的字符串拼接："><a href="#输出的字符串拼接：" class="headerlink" title="输出的字符串拼接："></a>输出的字符串拼接：</h2><ul><li><strong>在sqlite中：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A || &#x27;(&#x27; || B ||&#x27;)&#x27;</span><br></pre></td></tr></table></figure><p>用||作为各个字符的连接。</p><ul><li><strong>在MySQL中：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONTACT(year, &#x27;|&#x27;, title, &#x27;(&#x27;, second_title, &#x27;)&#x27;)</span><br></pre></td></tr></table></figure><p>使用CONTACT函数进行拼接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.output placeholder/q1_sample.sql</span><br></pre></td></tr></table></figure><h2 id="将输出保存入文件中："><a href="#将输出保存入文件中：" class="headerlink" title="将输出保存入文件中："></a>将输出保存入文件中：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.output 文件路径</span><br></pre></td></tr></table></figure><p>可以将后续的输出重定位，输入到目标文件中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.output stdout</span><br></pre></td></tr></table></figure><p>将输出结果重新定位到终端屏幕上。</p><h1 id="CMU15445—HK0的部分实战笔记："><a href="#CMU15445—HK0的部分实战笔记：" class="headerlink" title="CMU15445—HK0的部分实战笔记："></a>CMU15445—HK0的部分实战笔记：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">------q4---------</span><br><span class="line">SELECT </span><br><span class="line">(people.born/10)*10 AS decade,   --巧妙的转换</span><br><span class="line">COUNT(DISTINCT crew.person_id) AS director_count</span><br><span class="line">FROM crew</span><br><span class="line">JOIN people ON people.person_id = crew.person_id  --注意JOIN方式是建立利用外键关系的绝佳方式</span><br><span class="line">WHERE crew.category=&#x27;director&#x27;</span><br><span class="line">  AND people.born IS NOT NULL</span><br><span class="line">  AND people.born &gt;= 1900</span><br><span class="line">  AND people.born &lt;= 2020</span><br><span class="line">GROUP BY decade</span><br><span class="line">ORDER BY decade;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-------q5---------</span><br><span class="line">计算标题是德语(akas.language = &#x27;German&#x27;) AND (akas.types = &#x27;imdbDisplay&#x27; or &#x27;original&#x27;)的不同类型作品(GROUP BY titles.type)评分(ratings.rating)的平均值，最小值，最大值。</span><br><span class="line">akas与titles与ratings的关联是title_id。JOIN函数不能并列写</span><br><span class="line">---------------------------------------------------</span><br><span class="line">SELECT </span><br><span class="line">titles.type, AVG(ratings.rating) AS avg, MAX(ratings.rating), MIN(ratings.rating)</span><br><span class="line">FROM ratings</span><br><span class="line">JOIN titles ON ratings.title_id = titles.title_id   </span><br><span class="line">JOIN akas ON ratings.title_id = akas.title_id</span><br><span class="line">WHERE akas.language = &#x27;German&#x27;</span><br><span class="line">  AND (akas.types = &#x27;imdbDisplay&#x27; OR akas.types = &#x27;original&#x27;)</span><br><span class="line">GROUP BY titles.type</span><br><span class="line">ORDER BY avg;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-------q6------</span><br><span class="line">扮演batman(crew.characters = &#x27;batman&#x27;)的演员(people.name)[people.person_id充当外键]的所有作品的评分的平均值(ratings.rating)[演员与作品的映射：crew.title_id = ratings.title_id 同时 crew.person_id = people.person_id]</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">people.name, ROUND(AVG(ratings.rating), 2) AS avg</span><br><span class="line">FROM people</span><br><span class="line">JOIN crew ON people.person_id = crew.person_id</span><br><span class="line">JOIN ratings ON crew.title_id = ratings.title_id</span><br><span class="line">WHERE crew.characters LIKE &#x27;%&quot;Batman&quot;%&#x27;</span><br><span class="line">GROUP BY people.person_id</span><br><span class="line">ORDER BY avg DESC</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-----q7------</span><br><span class="line">在电影(akas.title = &#x27;The Prestige&#x27;)的首映年(titles.premiered)[title_id]出生(people.born)的演员人数(判别不同:person_id)</span><br><span class="line">------------------------------------</span><br><span class="line">SELECT COUNT(people.person_id) </span><br><span class="line">FROM people</span><br><span class="line">JOIN titles ON titles.premiered = people.born</span><br><span class="line">JOIN akas ON akas.title_id = titles.title_id AND akas.title = &#x27;The Prestige&#x27;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-------q8------</span><br><span class="line">所有与名字为Rose(people.name = &#x27;Rose&#x27;)的演员(crew.category = &#x27;actor&#x27;)在同一部电影(满足前两个条件下的title_id)出现且为director的people的name(crew.category = &#x27;director&#x27;)[person_id串联]，按字母顺序打印。</span><br><span class="line">-------------------------------------------------</span><br><span class="line">这里假设取别名来特定多个集体相混合的问题的方法。</span><br><span class="line">SELECT p.name</span><br><span class="line">FROM people tar</span><br><span class="line">JOIN crew c1 ON c1.person_id = tar.person_id</span><br><span class="line">JOIN titles t1 ON c1.title_id = t1.title_id</span><br><span class="line">JOIN crew c2 ON t1.title_id = c2.title_id</span><br><span class="line">JOIN people p ON c2.person_id = p.person_id</span><br><span class="line">WHERE tar.name = &#x27;Rose&#x27;</span><br><span class="line">  AND c1.category = &#x27;actress&#x27; </span><br><span class="line">  AND c2.category = &#x27;director&#x27;</span><br><span class="line">GROUP BY p.name</span><br><span class="line">ORDER BY p.name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">-------q9-------</span><br><span class="line">列出每一个category中前5名按死亡年序排名的people，再按名字排序，以及其runtime最长的且其中title_id最小的作品</span><br><span class="line">--------------------------------------------------</span><br><span class="line">ETC的综合运用案例，通过构建一系列的中间表，来实现提取特定数据操作。</span><br><span class="line">对于其中ROW_NUMBER()函数的解释：</span><br><span class="line">PARTITION BY A, B：首先按照A, B两值进行分组；</span><br><span class="line">ORDER BY：决定排序准则；</span><br><span class="line">ROW_NUMBER():为每个分组内的行分配序号(1, 2, 3,....)实现效果提取1即可实现提取最值。</span><br><span class="line"></span><br><span class="line">WITH artist_works AS(</span><br><span class="line">  SELECT</span><br><span class="line">    c.category,</span><br><span class="line">    p.name,</span><br><span class="line">    p.died,</span><br><span class="line">    t.primary_title,</span><br><span class="line">    t.runtime_minutes,</span><br><span class="line">    t.title_id,</span><br><span class="line">    ROW_NUMBER() OVER (PARTITION BY p.person_id, c.category ORDER BY t.runtime_minutes DESC, t.title_id ASC) AS work_rank</span><br><span class="line">  FROM people p</span><br><span class="line">  JOIN crew c ON c.person_id = p.person_id</span><br><span class="line">  JOIN titles t ON c.title_id = t.title_id</span><br><span class="line">  WHERE t.runtime_minutes IS NOT NULL</span><br><span class="line">    AND p.died IS NOT NULL</span><br><span class="line">),</span><br><span class="line">artist_longest_work AS(</span><br><span class="line">  SELECT</span><br><span class="line">    category,</span><br><span class="line">    name,</span><br><span class="line">    died,</span><br><span class="line">    primary_title,</span><br><span class="line">    runtime_minutes</span><br><span class="line">  FROM artist_works</span><br><span class="line">  WHERE work_rank = 1</span><br><span class="line">),</span><br><span class="line">category_ranks AS(</span><br><span class="line">  SELECT </span><br><span class="line">    category,</span><br><span class="line">    name,</span><br><span class="line">    died,</span><br><span class="line">    primary_title,</span><br><span class="line">    runtime_minutes,</span><br><span class="line">    ROW_NUMBER() OVER (PARTITION BY category ORDER BY died, name) AS category_rank</span><br><span class="line">  FROM artist_longest_work</span><br><span class="line">)</span><br><span class="line">SELECT</span><br><span class="line">  category,</span><br><span class="line">  name,</span><br><span class="line">  died,</span><br><span class="line">  primary_title,</span><br><span class="line">  runtime_minutes,</span><br><span class="line">  category_rank</span><br><span class="line">FROM category_ranks</span><br><span class="line">WHERE category_rank &lt;= 5</span><br><span class="line">ORDER BY category, died, name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一)概论</title>
      <link href="/2025/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2025/09/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机的层次结构："><a href="#计算机的层次结构：" class="headerlink" title="计算机的层次结构："></a>计算机的层次结构：</h2><p>软件在不同机器上运行的根本区别是所需要的指令集的不同。</p><p>越靠近底层的语言，效率越高—-能充分发挥硬件的优良特性。</p><h2 id="基本框架："><a href="#基本框架：" class="headerlink" title="基本框架："></a>基本框架：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">高级语言----------&gt;虚拟机器M3</span><br><span class="line"></span><br><span class="line">​      |编译</span><br><span class="line"></span><br><span class="line">汇编语言---------&gt;虚拟机器M2</span><br><span class="line"></span><br><span class="line">操作系统----------&gt;虚拟机器</span><br><span class="line"></span><br><span class="line">机器语言---------&gt; 实际机器M1</span><br><span class="line"></span><br><span class="line">微指令系统-------&gt;微程序机器 (在CPU中的CU(control unit)中执行)</span><br></pre></td></tr></table></figure><p><strong>操作系统是软硬件的分界线。(分界线并非一成不变，两者可能互相转化)</strong></p><h3 id="计算机体系结构："><a href="#计算机体系结构：" class="headerlink" title="计算机体系结构："></a>计算机体系结构：</h3><p>(如：有无浮点运算指令)</p><p>程序员所见到的计算机系统的属性。概念性的结构与功能特性。(汇编语言)</p><p>(指令系统，数据类型，寻址技术，I&#x2F;O机理)</p><h3 id="计算机组成："><a href="#计算机组成：" class="headerlink" title="计算机组成："></a>计算机组成：</h3><p>(如：具体如何实现浮点运算指令)</p><p>实现计算机体系结构所体现的属性。</p><h2 id="计算机基本组成："><a href="#计算机基本组成：" class="headerlink" title="计算机基本组成："></a>计算机基本组成：</h2><h4 id="冯-诺依曼体系："><a href="#冯-诺依曼体系：" class="headerlink" title="冯.诺依曼体系："></a>冯.诺依曼体系：</h4><p><strong>1，计算机由五大部件组成；</strong></p><p><strong>2，指令和数据以同等地位存于存储器，可按地址访问。</strong></p><p><strong>3，指令和数据用二进制表示；</strong></p><p><strong>4，指令由操作码和地址码组成；</strong></p><p><strong>5，存储程序方式；</strong></p><p><strong>6，以运算器为中心；(现代是存储器为中心)</strong></p><p>​                         存储器</p><p>​                            |  |</p><p>输入设备——-&gt;运算器———-&gt;输出设备</p><p>​                            |   |</p><p>​                          控制器</p><h4 id="现代硬件："><a href="#现代硬件：" class="headerlink" title="现代硬件："></a>现代硬件：</h4><ul><li>主机<ul><li>cpu<ul><li>运算器(ALU)</li><li>控制器(CU)</li></ul></li><li>存储器<ul><li>主存</li><li>辅存</li></ul></li></ul></li><li>I&#x2F;O<ul><li>输入设备</li><li>输出设备</li></ul></li></ul><p>指令格式：</p><p>操作码(6位) + 地址码(10位) 【共16位—-2字节】【指令的长短不固定】</p><p><strong>运算器的基本组成和操作过程：</strong></p><p>在一个芯片上，在存储玩主要功能的电路后，可以留有空间来<strong>暂时</strong>存储数据。这些空间就叫做寄存器。</p><p>![屏幕截图 2025-09-11 182348](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-11 182348.png)</p><p>上图中的空白部分，就可以刻入寄存器。</p><p>ACC: l累加器；</p><p>MQ：乘商寄存器；</p><p>X：操作数寄存器；</p><p>这些统称为寄存器。</p><p>操作过程中数据的存储：</p><p>![屏幕截图 2025-09-11 182740](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-11 182740.png)</p><p>以上过程中这些部件的分配均由CU支配。运算的过程就在ALU中进行。</p><p>那又是如何按照时间序列一步步执行的：</p><p>![屏幕截图 2025-09-11 183033](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-11 183033.png)</p><p>初始状态先把被加数从X中取到ACC中；(加载)</p><p>把加法指令给ALU，激活加法电路。</p><p>将另一个加数从地址码中取出。</p><p>将相加的结果存进ACC中。</p><p><strong>存储器：</strong></p><p>基本组成：</p><p>存储单元(0&#x2F;1) —&gt; 存储单元—–&gt; 存储体</p><p>存储单元：存放一串二进制代码（最小为8个字节）</p><p>存储字：存储单元中二进制代码的组合；</p><p>存储字长：存储单元中二进制代码的位数。</p><p>MAR：存放准备访问的数据的地址。位数反映单元的个数。(2^k个)</p><p>MDR：存放存储器读出或写入的代码或数据，位数反映存储字长。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和优先队列</title>
      <link href="/2025/09/09/%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>/2025/09/09/%E5%A0%86%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="优先级队列："><a href="#优先级队列：" class="headerlink" title="优先级队列："></a>优先级队列：</h2><p>是一种ADT，定义了一下的接口：</p><ul><li>插入：向队列中加入一个带有优先级的元素；</li><li>remove操作：提取出队列中优先级最高的元素，并删除。</li></ul><h2 id="堆的引入："><a href="#堆的引入：" class="headerlink" title="堆的引入："></a>堆的引入：</h2><table><thead><tr><th>操作\数据结构</th><th>有序数组</th><th>hash数组</th><th>bushy BST</th></tr></thead><tbody><tr><td>add</td><td>O(N)</td><td>O(1)</td><td>O(logN)</td></tr><tr><td>get_smallest</td><td>O(1)</td><td>O(N)</td><td>O(logN)</td></tr><tr><td>remove_smallest</td><td>O(N)</td><td>O(N)</td><td>O(logN)</td></tr></tbody></table><p>从现在看来实现优先级队列的最优结构是BST。</p><p>但是否可以对BST进行进一步的优化？</p><p>我们知道BST中，左儿子 &lt;&#x3D; 父节点，我们若想要得到最小值，我们还要遍历一遍左子树[ O(logN) ]；那么我们可不可以在这个的基础上进行优化，定义一种min-heap，将优先级最高的作为父节点，那么我们进行提取时就能实现为O（1）的复杂度。</p><h2 id="堆："><a href="#堆：" class="headerlink" title="堆："></a>堆：</h2><p><strong>以min-heap为例，属性如下：</strong></p><ul><li>每个节点都小于等于它的子节点；</li><li>若在叶子节点处缺少项目，所有节点都进可能偏左。</li></ul><p><strong>如何在这种堆模式下，实现以上的三种操作呢？</strong></p><ul><li><p><strong>add:</strong></p><p>将新值临时添加到堆的末尾，再按照规定的排序方式，递归地插入到应该所处的位置。</p></li><li><p><strong>getSmallest：</strong></p><p>返回根节点即可。</p></li><li><p><strong>removeSmallest：</strong></p><p>将堆的最后一项交换到根节点，再递归地调整树的结构即可。</p></li></ul><p><strong>新的问题—–这种树的实现，应该基于什么定义呢？</strong></p><p>一般的BST定义：(基于指针树的定义)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct tree&#123;</span><br><span class="line">   int node;</span><br><span class="line">   int value;</span><br><span class="line">   tree* lson;</span><br><span class="line">   tree* rson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们考虑一种新的定义形式—-（基于数组）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对于a[i], 左儿子为a[i * 2],右儿子为a[i * 2 + 1]。</span><br><span class="line">在查找父节点时，直接a[i / 2]即可。</span><br></pre></td></tr></table></figure><p><strong>优势性：</strong></p><p>具有空间上的紧凑性，简洁性，缓存友好型。</p><p>例如对于一个完全二叉树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    10         a[1]</span><br><span class="line">   /  \</span><br><span class="line">  5    15      a[2], a[3]</span><br><span class="line"> / \   /</span><br><span class="line">2   7 12       a[4], a[5]</span><br></pre></td></tr></table></figure><p>用数组存下来为：</p><p>a[  ] &#x3D; [null, 10, 5, 15, 2, 7, 12]；正好符合这种数组的形式。</p><p><u><em>注意：根节点的node是从1开始的。</em></u></p><p><strong>那么为什么这种简洁的形式不适用于描述BST？</strong></p><p>—<strong>因为堆一般都是完全二叉树形式，一层层是紧挨着，填满的。</strong></p><p>而BST却不一定，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   8</span><br><span class="line"> /</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>若强行用数组存储会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     5         a[1]</span><br><span class="line">   /    \</span><br><span class="line">  3      8      a[2], a[3]</span><br><span class="line"> / \    /  \</span><br><span class="line">1  NULL NULL NULL      a[4], a[5], a[6], a[7]</span><br></pre></td></tr></table></figure><p>a[5], a[6], a[7]均是被浪费的空间。</p><p><strong>那么树的形式实现了，我们回到具体操作的实现上来：</strong></p><p>我们发现到，以上三个操作均有一个核心操作：递归调整数的结构：</p><p>代码实现如下：</p><ul><li><strong>向下调整：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> t = u;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= sizes &amp;&amp; tree[<span class="number">2</span> * u] &lt; tree[t])&#123; <span class="comment">//在边界范围内，且不符合建树规则</span></span><br><span class="line">      t = <span class="number">2</span> * u;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="number">2</span> * u <span class="number">+1</span> &lt;= sizes &amp;&amp; tree[u * <span class="number">2</span> + <span class="number">1</span>] &lt; tree[t])&#123;</span><br><span class="line">      t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">     <span class="built_in">swap</span>(tree[t], tree[u]);</span><br><span class="line">     <span class="built_in">down</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>向上调整：</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void up(int u)&#123;</span><br><span class="line">   while(u / 2 &amp;&amp; tree[u] &lt; tree[u / 2])&#123;</span><br><span class="line">      swap(tree[u], tree[u / 2]);</span><br><span class="line">      u /= 2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>add:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tree[++sizes] = new_val;</span><br><span class="line">up(sizes);</span><br></pre></td></tr></table></figure><ul><li><strong>remove:</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tree[1] = tree[sizes];</span><br><span class="line">sizes --;</span><br><span class="line">down(1);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（一，引入；关系模型和代数）</title>
      <link href="/2025/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%8C%E5%BC%95%E5%85%A5%EF%BC%9B%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BB%A3%E6%95%B0%EF%BC%89/"/>
      <url>/2025/09/08/%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%8C%E5%BC%95%E5%85%A5%EF%BC%9B%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BB%A3%E6%95%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库管理系统（DBMS）："><a href="#数据库管理系统（DBMS）：" class="headerlink" title="数据库管理系统（DBMS）："></a>数据库管理系统（DBMS）：</h2><p>DBMS 是一种允许应用程序在数据库中存储和分析信息的软件。</p><p>DBMS 允许根据某些数据模型来定义，创建，查询，更新，管理数据库。</p><h2 id="数据模型："><a href="#数据模型：" class="headerlink" title="数据模型："></a>数据模型：</h2><p>是一种描述数据库中数据的概念的集合：</p><p>实例：关系，NoSQL(键&#x2F;值，文档，图形)，数组&#x2F;矩阵&#x2F;向量(用于机器学习)</p><h3 id="关系数据模型："><a href="#关系数据模型：" class="headerlink" title="关系数据模型："></a>关系数据模型：</h3><p>关系数据模型定义了基于关系的数据库抽象概念，以避免更新数据库而要重写代码的开销。</p><h4 id="关系模型三个原则："><a href="#关系模型三个原则：" class="headerlink" title="关系模型三个原则："></a>关系模型三个原则：</h4><p>1，用简单的数据结构来存储数据；</p><p>2，物理存储方式由 DBMS 的具体实现来决定。</p><p>3，只通过 sql 语言接受数据，DBMS 找出来最佳的执行策略。</p><h4 id="关系模型定义三个概念："><a href="#关系模型定义三个概念：" class="headerlink" title="关系模型定义三个概念："></a>关系模型定义三个概念：</h4><p>1，结构：关系的定义及其内容。关系具有的属性，以及这些属性可以包含的值</p><p>2，完整性：确保数据库的内容满足约束。如：year 属性的值必须均为数字</p><p>3，操作：如何访问和修改数据库的内容</p><p>元组是关系中的一组属性值。每个属性都可以有特殊值 NULL，这表示该属性是未定义的。</p><p>具有 n 个属性的关系被称为 n 元关系。n 元关系相当于具有 n 列的表。</p><h4 id="key"><a href="#key" class="headerlink" title="key:"></a>key:</h4><h5 id="主键："><a href="#主键：" class="headerlink" title="主键："></a>主键：</h5><p>一个关系的主键独一无二地标识这一个元组。有些 DBMS 会自动创建内部主键。</p><h5 id="外键："><a href="#外键：" class="headerlink" title="外键："></a>外键：</h5><p>指定一个关系中的属性必须映射到另一个关系中的元组。例如：在专辑表中包含艺术家的 ID，这个 ID 就可以关联到这个艺术家的作品。</p><p>层次模型：</p><p>组织数据的模型是树，依次往下分类</p><p>网状模型：</p><p>缺点：</p><p>程序的书写较为复杂，且读取较复杂(如需要书写树的遍历函数)</p><h2 id="数据操作语言（DML）："><a href="#数据操作语言（DML）：" class="headerlink" title="数据操作语言（DML）："></a>数据操作语言（DML）：</h2><p>从数据库中存储和检索信息的方法。</p><p>1，过程性：以 set 或 bag 来查找所需结果。例如：通过 for 循环遍历所有结果，以记录总的结果数。（关系代数）</p><p>2，非过程性（声明性）：仅定义想要查询的数据。而不指定查询方式。</p><h3 id="关系代数："><a href="#关系代数：" class="headerlink" title="关系代数："></a>关系代数：</h3><p>关系代数是通过关系，检索和操作元组的集合。每一种操作都接受一种或多种关系，然后输出一个新关系。通过连接这些操作，我们可以实现查询的编写。</p><ul><li><h5 id="select："><a href="#select：" class="headerlink" title="select："></a>select：</h5></li></ul><p>接受一个关系，并从该关系中输出满足选择谓词的元组的子集。我们可以通过连词和析取来组合多个谓词。</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mspace width="1em"></mspace><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>c</mi><mi>t</mi><mspace width="1em"></mspace><mo>(</mo><mi>R</mi><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">\sigma \quad predict\quad (R);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">p</span></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">d</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span><br>示例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mspace width="1em"></mspace><msub><mi>a</mi><mi>i</mi></msub><mi>d</mi><msup><mo>&#x3D;</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>a</mi><msup><mn>2</mn><mrow><mi mathvariant="normal">′</mi></mrow></msup><mspace width="1em"></mspace><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma \quad a_id&#x3D;&#x27;a2&#x27;\quad (R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mord"><span class="mspace quad"></span><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mrel"><span class="mrel">&#x3D;</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">a</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></p><ul><li><h5 id="projection"><a href="#projection" class="headerlink" title="projection:"></a>projection:</h5></li></ul><p>接受一个关系，并输出一个新的临时关系。可以重新排列输入关系中属性的顺序，和对值进行操作。</p><p>语法: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mspace width="1em"></mspace><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mn>2</mn><mo separator="true">,</mo><mi>A</mi><mn>3</mn><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mspace width="1em"></mspace><mo>(</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\pi \quad A1,A2,A3…\quad (R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">A</span></span><span class="mord mathrm">1</span><span class="mpunct">,</span><span class="mord mathit">A</span><span class="mord mathrm">2</span><span class="mpunct">,</span><span class="mord mathit">A</span><span class="mord mathrm">3</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span><br>示例：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mspace width="1em"></mspace><msub><mi>b</mi><mi>i</mi></msub><mi>d</mi><mo>−</mo><mn>1</mn><mn>0</mn><mn>0</mn><mo separator="true">,</mo><msub><mi>a</mi><mi>i</mi></msub><mi>d</mi><mspace width="1em"></mspace><mo>(</mo><mi>σ</mi><mspace width="1em"></mspace><msub><mi>a</mi><mi>i</mi></msub><mi>d</mi><msup><mo>&#x3D;</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>a</mi><msup><mn>2</mn><mrow><mi mathvariant="normal">′</mi></mrow></msup><mspace width="1em"></mspace><mo>(</mo><mi>R</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\pi \quad b_id-100,a_id\quad (\sigma \quad a_id&#x3D;&#x27;a2&#x27;\quad (R))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mspace quad"></span><span class="mord mathit">b</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="mord"><span class="mspace quad"></span><span class="mord mathit">a</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">d</span><span class="mrel"><span class="mrel">&#x3D;</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mord mathit">a</span><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mathrm mtight">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mopen"><span class="mspace quad"></span><span class="mopen">(</span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br>解释：在 a_id 为 a2 的关系表中，将 b_id 的值都-100，然后排列顺序变为：b_id 在第一列，a_id 在第二列。</p><p> SQL: SELECT b_id-100, a_id FROM R WHERE a_id &#x3D; ‘a2’</p><ul><li><h5 id="union"><a href="#union" class="headerlink" title="union:"></a>union:</h5></li></ul><p>接受两个关系并输出一个关系（取并集）。两个输入关系必须具备完全相同的属性。</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>∪</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R \cup S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">∪</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span><br>SQL 中：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo>)</mo><mspace width="1em"></mspace><mi>U</mi><mi>N</mi><mi>I</mi><mi>O</mi><mi>N</mi><mspace width="1em"></mspace><mi>A</mi><mi>L</mi><mi>L</mi><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(SELECT * FROM\quad R)\quad UNION\quad ALL(SELECT * FROM\quad S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mclose">)</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.10903em;">U</span></span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">A</span></span><span class="mord mathit">L</span><span class="mord mathit">L</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span></span></span></span></p><p>注意：union 自动去重，union all 不会去重；</p><ul><li><h5 id="intersection"><a href="#intersection" class="headerlink" title="intersection:"></a>intersection:</h5></li></ul><p>输出两个关系的交集：</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>∩</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R \cap S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">∩</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span><br>SQL: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo>)</mo><mi>I</mi><mi>N</mi><mi>T</mi><mi>E</mi><mi>R</mi><mi>S</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(SELECT * FROM\quad R) INTERSECT (SELECT * FROM\quad S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span></span></span></span></p><ul><li><h5 id="差集："><a href="#差集：" class="headerlink" title="差集："></a>差集：</h5></li></ul><p>输出不同的元组集合</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R-S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mbin">−</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span><br>SQL: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo>)</mo><mi>E</mi><mi>X</mi><mi>C</mi><mi>E</mi><mi>P</mi><mi>T</mi><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(SELECT * FROM\quad R) EXCEPT (SELECT * FROM\quad S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.13889em;">P</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span></span></span></span></p><ul><li><h5 id="product"><a href="#product" class="headerlink" title="product:"></a>product:</h5></li></ul><p>将两个关系表进行笛卡尔积后，输出结果。</p><p>语法：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>R</mi><mspace width="1em"></mspace><mi>X</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(R\quad X\quad S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span></span></span></span><br>SQL: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo>)</mo><mi>C</mi><mi>R</mi><mi>O</mi><mi>S</mi><mi>S</mi><mspace width="1em"></mspace><mi>J</mi><mi>O</mi><mi>I</mi><mi>N</mi><mo>(</mo><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>S</mi><mo>)</mo><mspace width="1em"></mspace><mi>o</mi><mi>r</mi><mspace width="1em"></mspace><mi>s</mi><mi>i</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>y</mi><mspace width="1em"></mspace><mi>S</mi><mi>E</mi><mi>L</mi><mi>E</mi><mi>C</mi><mi>T</mi><mo>∗</mo><mi>F</mi><mi>R</mi><mi>O</mi><mi>M</mi><mspace width="1em"></mspace><mi>R</mi><mo separator="true">,</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">(SELECT * FROM\quad R) CROSS\quad JOIN (SELECT * FROM\quad S)\quad or\quad simply\quad SELECT * FROM\quad R, S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mclose">)</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.09618em;">J</span></span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mclose">)</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">o</span></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit">s</span></span><span class="mord mathit">i</span><span class="mord mathit">m</span><span class="mord mathit">p</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit">L</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.13889em;">F</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit"><span class="mspace quad"></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.05764em;">S</span></span></span></span></p><ul><li><h5 id="join："><a href="#join：" class="headerlink" title="join："></a>join：</h5></li></ul><p>输出的关系包含所有元组，这些元组是两个元组的组合(重复的合并，单有的加上)。</p><p>基于相同的值进行连接。</p><p>语法：(R ▷◁ S)</p><p>SQL: SELECT * FROM R JOIN S ON (合并条件…)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本学期自学目标</title>
      <link href="/2025/09/08/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E8%87%AA%E5%AD%A6%E7%9B%AE%E6%A0%87/"/>
      <url>/2025/09/08/%E6%9C%AC%E5%AD%A6%E6%9C%9F%E8%87%AA%E5%AD%A6%E7%9B%AE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<ul><li><p>常微分方程与偏微分方程:</p><ul><li><a href="https://ocw.mit.edu/courses/18-04-complex-variables-with-applications-spring-2018/">Complex Variables with Applications | Mathematics | MIT OpenCourseWare</a>（前置复变函数知识）</li><li><a href="https://ocw.mit.edu/courses/18-03sc-differential-equations-fall-2011/pages/unit-i-first-order-differential-equations/">Unit I: First Order Differential Equations | Differential Equations | Mathematics | MIT OpenCourseWare</a>（常微分方程）</li><li><a href="https://ocw.mit.edu/courses/18-152-introduction-to-partial-differential-equations-fall-2011/">Introduction to Partial Differential Equations | Mathematics | MIT OpenCourseWare</a>（偏微分方程建模与求解）</li></ul></li><li><p>数据库系统: </p><ul><li><a href="https://15445.courses.cs.cmu.edu/spring2023/schedule.html">时间表 |CMU 15-445&#x2F;645 ：： 数据库系统简介（2023 年春季） — Schedule | CMU 15-445&#x2F;645 :: Intro to Database Systems (Spring 2023)</a>（作业）</li><li><a href="https://www.youtube.com/playlist?list=PLSE8ODhjZXjaKScG3l0nuOiDTTqpfnWFf">YouTube</a>（视频）</li></ul></li><li><p>吴恩达-机器学习：</p><p><a href="https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1Bq421A74G/?spm_id_from=333.337.search-card.all.click</a></p></li><li><p>csapp：</p><ul><li><a href="https://www.bilibili.com/video/BV1cD4y1D7uR/%EF%BC%88%E4%B8%AD%E6%96%87%E6%A6%82%E8%A6%81%E8%AE%B2%E8%A7%A3%EF%BC%89">https://www.bilibili.com/video/BV1cD4y1D7uR/（中文概要讲解）</a></li><li><a href="https://csapp.cs.cmu.edu/3e/labs.html">CS:APP3e, Bryant and O’Hallaron</a>（课程的project）</li></ul></li><li><p>每日练习一种新算法</p></li><li><p>算法分析与进阶：</p><p><a href="https://ocw.mit.edu/courses/6-046j-design-and-analysis-of-algorithms-spring-2015/">Design and Analysis of Algorithms | Electrical Engineering and Computer Science | MIT OpenCourseWare</a></p></li><li><p>英语六级</p></li><li><p>蓝桥杯省奖</p></li><li><p>数学竞赛</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/2025/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/"/>
      <url>/2025/09/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="公共概念："><a href="#公共概念：" class="headerlink" title="公共概念："></a>公共概念：</h1><h3 id="基本定义："><a href="#基本定义：" class="headerlink" title="基本定义："></a>基本定义：</h3><p>具有相同类型的n个元素的有限序列，称为线性表；<br>$k_{i}$称为$k_{i+1}$的前驱元素；$k_{i}$称为$k_{i-1}$的后继元素。</p><h3 id="基本运算："><a href="#基本运算：" class="headerlink" title="基本运算："></a>基本运算：</h3><p>查找；插入；删除；其他。（合并，排列，统计….)</p><h1 id="模块二：实例："><a href="#模块二：实例：" class="headerlink" title="模块二：实例："></a>模块二：实例：</h1><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><ul><li><h3 id="数组的类实现："><a href="#数组的类实现：" class="headerlink" title="数组的类实现："></a>数组的类实现：</h3></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="keyword">class</span> <span class="title class_">Array</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">       Type * elements;</span><br><span class="line">       <span class="type">int</span> ArraySize;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">get_Array</span><span class="params">()</span></span>;  <span class="comment">//动态分配存储空间</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">       <span class="built_in">Array</span>(<span class="type">int</span> size); <span class="comment">//根据大小构造函数</span></span><br><span class="line">       <span class="built_in">Array</span>(<span class="type">const</span> Array&lt;Type&gt; &amp;x);  <span class="comment">//复制构造函数</span></span><br><span class="line">       ~<span class="built_in">Array</span>()&#123;  <span class="comment">//析构函数</span></span><br><span class="line">           <span class="keyword">delete</span> []elements;</span><br><span class="line">       &#125;</span><br><span class="line">       Array&lt;Type&gt; &amp; <span class="keyword">operator</span> = (<span class="type">const</span> Array&lt;Type&gt;&amp;A);  <span class="comment">//数组复制</span></span><br><span class="line">       Type&amp; <span class="keyword">operator</span> [](<span class="type">int</span> i);  <span class="comment">//获取特定元素</span></span><br><span class="line">       <span class="function"><span class="type">int</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> ArraySize;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">()</span></span>&#123;</span><br><span class="line">           <span class="type">int</span> now_size;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> Array&lt;Type&gt; ::<span class="built_in">get_Array</span>()&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[ArraySize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="function"><span class="type">void</span> <span class="title">Array</span><span class="params">(<span class="type">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        cerr&lt;&lt; <span class="string">&quot;MLE&quot;</span>&lt;&lt;endl;</span><br><span class="line">        ArraySize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ArraySize = size;</span><br><span class="line">    <span class="built_in">get_Array</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="type">void</span> Array&lt;Type&gt;:: <span class="built_in">Array</span>(<span class="type">const</span> Array &lt;Type&gt;&amp; x)&#123;</span><br><span class="line">    Arraysize = x.ArraySize;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[ArraySize];</span><br><span class="line">    Type* target = x.elements;</span><br><span class="line">    Type* obj = elements;</span><br><span class="line">    <span class="type">int</span> n = ArraySize;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        *obj ++ = *target ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="数组的顺序存储方式："><a href="#数组的顺序存储方式：" class="headerlink" title="数组的顺序存储方式："></a>数组的顺序存储方式：</h3></li></ul><p>数组的顺序存储方式就是能够根据下标，计算出对应地址，进而提取对应对象的基础。</p><ol><li>一维数组与二维数组：</li></ol><p>   若令s &#x3D; sizeof (datatype)，则一维地址表达式为：</p><p>   &amp;a[i] &#x3D; &amp;a[0] + i * s;</p><ol start="2"><li><p>二维数组的存储有两种方式：</p><p>2.1. 行序优先方式：</p><p>​        对于二维数组 a[ t1 ] [ t2 ] ，表达式为：</p><p>​        &amp;a[ i ] [ j ] &#x3D; &amp;a[ 0 ] [ 0 ] + ((i * t2) + j) * s；</p><p>2.2.列序优先方式：</p><p>​       对于二维数组a [ t1 ] [ t2 ],表达式为：</p><p>​       &amp;a[ i ] [ j ] &#x3D; &amp;a[ 0 ] [ 0 ] + ((j * t1) + i) * s ;</p></li><li><p>三维数组与n维数组：</p><p>对于三维数组a[ t1 ] [ t2 ] [ t3 ]，可以理解为由t1个二维数组a[ t2 ] [ t3]组合而成的长方体。</p><p>其表达式为：</p><p>&amp;a[ i ] [ j ] [ k ] &#x3D; &amp;a[ 0 ] [ 0 ] [0 ] + ((i * t2 *t3) + (j * t3) + k) *s;</p></li></ol><p>​       故推广后易知，n维数组的表达式为：</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mrow><msub><mi>c</mi><mi>n</mi></msub><mo>&#x3D;</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow><msub><mi>c</mi><mi>j</mi></msub><mo>&#x3D;</mo><msub><mi>t</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>⋅</mo><msub><mi>c</mi><mrow><mi>j</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></mtd><mtd><mrow><mo>(</mo><mn>1</mn><mo>⩽</mo><mi>j</mi><mo>&lt;</mo><mi>n</mi><mo>)</mo></mrow></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">\begin{cases}<br>c_n &#x3D; 1 \<br>c_j &#x3D; t_{j+1} \cdot c_{j+1} &amp; (1 \leqslant j &lt; n)<br>\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:1.75em;"></span><span class="strut bottom" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="base textstyle uncramped"><span class="minner textstyle uncramped"><span class="mopen style-wrap reset-textstyle textstyle uncramped" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist"><span style="top:-0.6819999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">&#x3D;</span><span class="mord mathrm">1</span></span></span><span style="top:0.7579999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mrel">&#x3D;</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">c</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">+</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist"><span style="top:0.7579999999999999em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mopen">(</span><span class="mord mathrm">1</span><span class="mrel amsrm">⩽</span><span class="mord mathit" style="margin-right:0.05724em;">j</span><span class="mrel">&lt;</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span><span class="mclose sizing reset-size5 size5 reset-textstyle textstyle uncramped nulldelimiter"></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mi mathvariant="normal">&amp;</mi><mi>a</mi><mo>[</mo><msub><mi>t</mi><mn>1</mn></msub><mo>]</mo><mo>[</mo><msub><mi>t</mi><mn>2</mn></msub><mo>]</mo><mo>⋯</mo><mo>[</mo><msub><mi>t</mi><mi>n</mi></msub><mo>]</mo><mo>&#x3D;</mo><mi mathvariant="normal">&amp;</mi><mi>a</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>⋯</mo><mo>[</mo><mn>0</mn><mo>]</mo></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><msub><mi>i</mi><mn>1</mn></msub><mo>⋅</mo><msub><mi>t</mi><mn>2</mn></msub><mo>⋅</mo><msub><mi>t</mi><mn>3</mn></msub><mo>⋯</mo><msub><mi>t</mi><mi>n</mi></msub><mo>⋅</mo><mi>s</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><msub><mi>i</mi><mn>2</mn></msub><mo>⋅</mo><msub><mi>t</mi><mn>3</mn></msub><mo>⋯</mo><msub><mi>t</mi><mi>n</mi></msub><mo>⋅</mo><mi>s</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><mo>⋯</mo></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><msub><mi>i</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>⋅</mo><msub><mi>t</mi><mi>n</mi></msub><mo>⋅</mo><mi>s</mi></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd><mrow><mrow></mrow><mo>+</mo><msub><mi>i</mi><mi>n</mi></msub><mo>⋅</mo><mi>s</mi></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{aligned}<br>&amp;amp;a[t_1][t_2]\cdots[t_n] &#x3D; &amp;amp;a[0][0]\cdots[0] &amp;+ i_1 \cdot t_2 \cdot t_3 \cdots t_n \cdot s \<br>&amp;+ i_2 \cdot t_3 \cdots t_n \cdot s \<br>&amp;+ \cdots \<br>&amp;+ i_{n-1} \cdot t_n \cdot s \<br>&amp;+ i_n \cdot s<br>\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:3.25em;"></span><span class="strut bottom" style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">&amp;</span><span class="mord mathit">a</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">]</span><span class="minner">⋯</span><span class="mopen">[</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose">]</span><span class="mrel">&#x3D;</span><span class="mord mathrm">&amp;</span><span class="mord mathit">a</span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span><span class="minner">⋯</span><span class="mopen">[</span><span class="mord mathrm">0</span><span class="mclose">]</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="col-align-l"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="minner">⋯</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord mathit">s</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathrm mtight">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="minner">⋯</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord mathit">s</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="minner">⋯</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord scriptstyle cramped mtight"><span class="mord mathit mtight">n</span><span class="mbin mtight">−</span><span class="mord mathrm mtight">1</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord mathit">s</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord textstyle uncramped"></span><span class="mbin">+</span><span class="mord"><span class="mord mathit">i</span><span class="msupsub"><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped mtight"><span class="mord mathit mtight">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin">⋅</span><span class="mord mathit">s</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span></p><ol start="4"><li><p>三角矩阵与带状矩阵：</p><ul><li>将三角矩阵进行存储时（上下三角），为了节省空间，只会存储三角部分。</li></ul><p>​       地址的计算推导如下：</p><p>$\begin{align*}<br>&amp;a[i][0] &amp;&#x3D; &amp;a[0][0] + s \cdot \sum_{k&#x3D;1}^{i} k &#x3D; &amp;a[0][0] + \frac{i(i+1)}{2} \cdot s \<br>\<br>&amp;a[i][j] &amp;&#x3D; &amp;a[i][0] + j \cdot s \<br>\<br>&amp;a[i][j] &amp;&#x3D; &amp;a[0][0] + \left[\frac{i(i+1)}{2} + j\right] \cdot s<br>\end{align*}$</p><ul><li><p>带状矩阵：</p><p>对于n阶矩阵，若只有以最长对角线为中心区域存在非零元素，则将该矩阵称为带状矩阵。</p><p>设上，下方区域均有b条对角线，则称该矩阵的带宽为(2b + 1)。</p><p>在存储时，只存储带状区域元素。存储方式如下：</p><p><u>第一行与最后一行不变，将其他行均当做有(2b+1)个元素进行存储</u>。对于进行补齐的元素，不进行存取操作。</p><p>故可得到地址表达式为：</p><p>&amp;a [ i ] [ j ] &#x3D; &amp;a [ 0 ] [ 0 ] + [(2b+1) *i + j] * s</p></li></ul></li></ol><ul><li><p>稀疏矩阵：</p><ul><li><p>引入：若矩阵中0元素个数远大于非0元素个数，为了避免空间的浪费，有必要进行矩阵的压缩存储。以下为两种压缩存储方式：</p></li><li><p><u>设i行j列有一个元素a[ i ] [ j ].我们可以将其写成三元组数组的形式：(i,  j,  a[ i ] [ j ])。</u>并用新的二维数组进行存储。<u>存储顺序为行号的递增顺序。</u></p><p>例如稀疏矩阵：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtable><mtr><mtd><mrow><mn>1</mn><mn>2</mn></mrow></mtd><mtd><mrow><mn>1</mn><mn>5</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>3</mn><mn>6</mn></mrow></mtd><mtd><mrow><mn>4</mn><mn>6</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>5</mn><mn>2</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd></mtr><mtr><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>7</mn><mn>2</mn></mrow></mtd><mtd><mrow><mn>0</mn></mrow></mtd><mtd><mrow><mn>6</mn><mn>8</mn></mrow></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\begin{matrix}<br>12 &amp; 15 &amp; 0 &amp; 0 \<br>0 &amp; 0 &amp; 0 &amp; 0\<br>36 &amp; 46 &amp; 0 &amp; 52\<br>0 &amp; 0 &amp; 0 &amp; 0 \<br>0 &amp; 72 &amp; 0 &amp; 68<br>\end{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:3.25em;"></span><span class="strut bottom" style="height:6em;vertical-align:-2.7500000000000004em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">2</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">3</span><span class="mord mathrm">6</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">5</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">4</span><span class="mord mathrm">6</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">7</span><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist"><span style="top:-2.41em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-1.2100000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:-0.009999999999999953em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">2</span></span></span><span style="top:1.1900000000000002em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">0</span></span></span><span style="top:2.3900000000000006em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="mord textstyle uncramped"><span class="mord mathrm">6</span><span class="mord mathrm">8</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></span><br>转换结果：</p><table><thead><tr><th align="center">5</th><th align="center">4</th><th align="center">7</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">12</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">15</td></tr><tr><td align="center">2</td><td align="center">0</td><td align="center">36</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">46</td></tr><tr><td align="center">2</td><td align="center">3</td><td align="center">52</td></tr><tr><td align="center">4</td><td align="center">1</td><td align="center">72</td></tr><tr><td align="center">4</td><td align="center">3</td><td align="center">68</td></tr></tbody></table><p>第一行表示总行数，总列数，总元素个数。</p></li><li><p>转换后矩阵的运算：</p></li></ul><p>​       矩阵转置：即将i 与 j 调换即可。为了避免转置后是递增性，提取的顺序按照原列号的递增顺序进行。</p></li></ul><h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数模a题模型积累及应用</title>
      <link href="/2025/09/03/%E6%95%B0%E6%A8%A1a%E9%A2%98%E6%A8%A1%E5%9E%8B%E7%A7%AF%E7%B4%AF%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/2025/09/03/%E6%95%B0%E6%A8%A1a%E9%A2%98%E6%A8%A1%E5%9E%8B%E7%A7%AF%E7%B4%AF%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="微分方程及差分方程"><a href="#微分方程及差分方程" class="headerlink" title="微分方程及差分方程"></a>微分方程及差分方程</h1><p>偏微分方程（热传导问题）</p><h1 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h1><h2 id="现代优化算法"><a href="#现代优化算法" class="headerlink" title="现代优化算法"></a>现代优化算法</h2><h3 id="模拟退火算法："><a href="#模拟退火算法：" class="headerlink" title="模拟退火算法："></a>模拟退火算法：</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>来源于固体退火原理，为一种基于概率的算法。将固体加热至充分，再<strong>徐徐</strong>冷却。徐徐冷却时，粒子在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。</p><h4 id="具体过程："><a href="#具体过程：" class="headerlink" title="具体过程："></a>具体过程：</h4><p><img src="C:\Users\LENOVO\Pictures\eecbcc6e4ca230adfdd1076ff30f2d52.png" alt="eecbcc6e4ca230adfdd1076ff30f2d52"></p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>其核心在于以一定概率接受一个比当前解更差的邻域解。概率为：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>&#x3D;</mo><msup><mi>e</mi><mrow><mo>−</mo><mo>(</mo><msub><mi>e</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>−</mo><msub><mi>e</mi><mrow><mi>o</mi><mi>l</mi><mi>d</mi></mrow></msub><mo>)</mo><mi mathvariant="normal">&#x2F;</mi><mi>T</mi></mrow></msup></mrow><annotation encoding="application/x-tex">p &#x3D; e^{-(e_{new} - e_{old})&#x2F;T}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8879999999999999em;"></span><span class="strut bottom" style="height:1.0824399999999998em;vertical-align:-0.19444em;"></span><span class="base textstyle uncramped"><span class="mord mathit">p</span><span class="mrel">&#x3D;</span><span class="mord"><span class="mord mathit">e</span><span class="msupsub"><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped mtight"><span class="mord scriptstyle uncramped mtight"><span class="mord mtight">−</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathit mtight">e</span><span class="msupsub"><span class="vlist"><span style="top:0.143em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped mtight"><span class="mord scriptscriptstyle cramped mtight"><span class="mord mathit mtight">n</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathit mtight">e</span><span class="msupsub"><span class="vlist"><span style="top:0.15122857142857138em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped mtight"><span class="mord scriptscriptstyle cramped mtight"><span class="mord mathit mtight">o</span><span class="mord mathit mtight" style="margin-right:0.01968em;">l</span><span class="mord mathit mtight">d</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span><span class="mclose mtight">)</span><span class="mord mathrm mtight">&#x2F;</span><span class="mord mathit mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p><h4 id="python代码实现模拟退火算法，解决旅行商问题："><a href="#python代码实现模拟退火算法，解决旅行商问题：" class="headerlink" title="python代码实现模拟退火算法，解决旅行商问题："></a>python代码实现模拟退火算法，解决旅行商问题：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_energy</span>(<span class="params">path, distance_matrix</span>):</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    num_cities = <span class="built_in">len</span>(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_cities):</span><br><span class="line">        total += distance_matrix[path[i]][path[(i + <span class="number">1</span>) % num_cities]] <span class="comment">##还要返回起点</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过交换两个城市的位置产生新解</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">current_path</span>):</span><br><span class="line">    new_path = current_path.copy()</span><br><span class="line">    i, j = random.sample(<span class="built_in">range</span>(<span class="built_in">len</span>(current_path)), <span class="number">2</span>)</span><br><span class="line">    new_path[i], new_path[j] = new_path[j], new_path[i]</span><br><span class="line">    <span class="keyword">return</span> new_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution_tsp</span>(<span class="params">distance_matrix, T_max, T_min, alpha, max_iter</span>):</span><br><span class="line">    <span class="comment">#初始化：</span></span><br><span class="line">    num_cities = <span class="built_in">len</span>(distance_matrix)</span><br><span class="line">    current_path = <span class="built_in">list</span>(<span class="built_in">range</span>(num_cities))  <span class="comment">##0 ~ n-1 随机排列</span></span><br><span class="line">    random.shuffle(current_path)  <span class="comment">##打乱</span></span><br><span class="line">    current_energy = calc_energy(current_path, distance_matrix)</span><br><span class="line">    </span><br><span class="line">    T = T_max</span><br><span class="line">    best_path = current_path</span><br><span class="line">    best_energy = current_energy</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> T &gt; T_min:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(max_iter):</span><br><span class="line">            <span class="comment">#a ,打乱产生新解：</span></span><br><span class="line">            new_path = generate(current_path)</span><br><span class="line">            new_energy = calc_energy(new_path, distance_matrix)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> new_energy &lt; current_energy:</span><br><span class="line">                current_path = new_path</span><br><span class="line">                current_energy = current_energy</span><br><span class="line">                <span class="keyword">if</span> new_energy &lt; best_energy:</span><br><span class="line">                    best_path = new_path</span><br><span class="line">                    best_energy = new_energy</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment">#新解更差，概率接受:</span></span><br><span class="line">                p = math.exp(-(new_energy - current_energy) / T)</span><br><span class="line">                <span class="keyword">if</span> random.random() &lt; p:</span><br><span class="line">                    current_path = new_path</span><br><span class="line">                    current_energy = new_energy</span><br><span class="line">                </span><br><span class="line">        T = T * alpha <span class="comment">##降温</span></span><br><span class="line">    <span class="keyword">return</span> best_path, best_energy</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#创建随机距离矩阵：</span></span><br><span class="line"><span class="comment">#特点：距离矩阵是对称矩阵，对角线上的距离为0</span></span><br><span class="line">num_cities = <span class="number">10</span></span><br><span class="line">data = np.random.rand(num_cities, num_cities)</span><br><span class="line">distance_matrix = (data + data.T) / <span class="number">2</span>  <span class="comment">##data.T, 转置矩阵</span></span><br><span class="line">np.fill_diagonal(distance_matrix, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##运行算法：</span></span><br><span class="line">best_path, best_energy = solution_tsp(</span><br><span class="line">    distance_matrix,</span><br><span class="line">    T_max = <span class="number">1000</span>, <span class="comment">#最大温度</span></span><br><span class="line">    T_min = <span class="number">1</span>, <span class="comment">#最小温度</span></span><br><span class="line">    alpha = <span class="number">0.99</span>, <span class="comment">#降温系数</span></span><br><span class="line">    max_iter = <span class="number">1000</span>, <span class="comment">#每个温度下的最大迭代次数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳路径:&quot;</span>, best_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最短距离:&quot;</span>, best_energy)</span><br></pre></td></tr></table></figure><h4 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h4><ul><li><p>优点：</p><ul><li>实现较简单</li><li>能有效避免陷入局部最优解的情况</li></ul></li><li><p>缺点：</p><ul><li>收敛速度慢，占用空间较大</li><li>冷却时必须缓缓冷却。</li></ul></li><li><p>经典优化算法</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSAPP_Note</title>
      <link href="/2025/09/02/CSAPP-Note/"/>
      <url>/2025/09/02/CSAPP-Note/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：计算机系统漫游"><a href="#第一章：计算机系统漫游" class="headerlink" title="第一章：计算机系统漫游"></a>第一章：计算机系统漫游</h1><h3 id="一，信息由字节表示："><a href="#一，信息由字节表示：" class="headerlink" title="一，信息由字节表示："></a>一，信息由字节表示：</h3><p>无论是cpp文件亦或是其他文件，程序中的每一个文本字符都是由ASCII码表示的，例如hello.c文件由ASCII文本表示如下：</p><p>![屏幕截图 2025-09-02 181956](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-02 181956.png)</p><p>像以上的文件被称为文本文件，所有其他文件均被称为二进制文件。</p><h3 id="二，程序编译过程的不同形式："><a href="#二，程序编译过程的不同形式：" class="headerlink" title="二，程序编译过程的不同形式："></a>二，程序编译过程的不同形式：</h3><p>系统上helllo.c文件的运行：</p><p>每条C语句被转化为<strong>低级机器语言指令</strong>，这些指令再按照称为<strong>可执行目标程序</strong>的格式打包，以二进制的磁盘文件形式存放。<u>（目标程序文件也被称为可执行目标文件）</u></p><p>从源文件到目标文件的转化是由编译器驱动程序完成的。编译过程则可分为四个阶段，执行四个阶段的程序</p><p><strong>（预处理器，编译器，汇编器，链接器）一起构成了编译系统。</strong></p><p>![屏幕截图 2025-09-02 183128](C:\Users\LENOVO\Pictures\Screenshots\屏幕截图 2025-09-02 183128.png)</p><h4 id="过程解释："><a href="#过程解释：" class="headerlink" title="过程解释："></a>过程解释：</h4><h5 id="预处理阶段："><a href="#预处理阶段：" class="headerlink" title="预处理阶段："></a>预处理阶段：</h5><p>根据#子开头的命令，引用并插入库文件内容，得到对应的扩展文件；</p><h5 id="编译阶段："><a href="#编译阶段：" class="headerlink" title="编译阶段："></a>编译阶段：</h5><p>将文本文件hello.i翻译为文本文件hello.s，其中包括一汇编语言程序。</p><p>汇编语言的作用：将不同编译器编译的不同语言，转化为通用的汇编语言进行输出。</p><h5 id="汇编阶段："><a href="#汇编阶段：" class="headerlink" title="汇编阶段："></a>汇编阶段：</h5><p>将hello.s翻译为机器语言指令，并将其打包为<strong>可重定位目标程序</strong>的格式—-hello.o，</p><h5 id="链接阶段："><a href="#链接阶段：" class="headerlink" title="链接阶段："></a>链接阶段：</h5><p>将printf函数进行解析，链接添加进hello.o文件中，此时才可最终执行。</p><h1 id="第二章：信息的表示和处理"><a href="#第二章：信息的表示和处理" class="headerlink" title="第二章：信息的表示和处理"></a>第二章：信息的表示和处理</h1><h3 id="信息的存储："><a href="#信息的存储：" class="headerlink" title="信息的存储："></a>信息的存储：</h3><p>程序将内存视作一个大型数组，数组的元素由一个个字节(Byte)组成，每个字节都由唯一的数字表示，称为地址。所有地址的集合就称为虚拟地址空间。</p><ul><li><p>字节：</p><p>一个字节由8位组成。取值范围从00000000 ~ 11111111，即为0 ~ 255。这种一位位表示的方式称为位模式。</p></li><li><p>十六进制的引入：</p><ol><li>避免了二进制的冗长与十进制的麻烦：以 0 ~ 9与A ~ F构成。在C语言中，十六进制以0X开头（大小写随意）</li><li>便于与二进制进行转换：直接将每一位数字以二进制表示即可。注意当总位数不是4的倍数时，需要用0进行补齐。</li></ol></li><li><p>进制的转换：</p><ol><li><p>2的n次方转换为二进制，即是1后面跟了n个0</p></li><li><p>二进制与16进制的转换：</p><p>对于二进制 1000…0(n个0)，采取n &#x3D; i + 4 * j 的方法。</p><p>即表示该数由 j 个0与一个 i 组成。</p></li><li><p>十进制与十六进制的转换：</p><p>采用辗转相除的方法；</p></li></ol></li><li><p>字长(Words):</p><p>字长决定了在虚拟机中能够存储的最大位到多少。</p><p>对于一个字长为w的机器，虚拟地址的范围是 0 ~ 2^w - 1。</p><p>现常见的机器为32位与64位两种：</p><p>其中32位的文件，两种机器均可运行（因为64位机器大都实现了向下兼容）；而64位的文件只能运行在64位机器上</p><p>各类型数据的字节长：</p></li><li><p>字节的存储顺序：</p><ol><li><p>大端法：从高位往低位存储：</p><p>小端法：从低位往高位存储：</p></li></ol></li><li><p>​    布尔代数：</p><ul><li><p>~ （非）：</p><p>~0 &#x3D; 1； ~1 &#x3D; 0；</p></li><li><p>&amp;（与）：</p><p>0 &amp; 0 &#x3D; 0； 0 &amp; 1 &#x3D; 0； 1 &amp;1 &#x3D; 1；</p></li><li><p>|（或）：</p><p>0 | 0 &#x3D; 0；0 | 1 &#x3D; 1；1 | 1 &#x3D; 1；</p></li><li><p>^（异或）：</p><p>两参数相同时为0；不同时为1；</p></li></ul></li><li><p>掩码运算（Masking Operations):</p><p>通过位运算可以得到特定的掩码序列。</p><p>例如想要得到 0X89ABCDEF的最低有效字节：</p></li><li><p>​    位移运算：</p><ul><li><p>左移：左移n位即是在右端补上n个0</p></li><li><p>右移：分为逻辑右移和算术右移：</p><p>逻辑右移时，向高位补0；</p><p>算术右移：</p><p>​    当最高位是0时，向最高位补0；</p><p>​    <strong>当最高位是1时，向最高位补1；</strong></p><p>当数值为无符号数是，右移一定是逻辑右移；</p><p>当数值为有符号数时，右移一定是算术右移；</p></li></ul></li></ul><h3 id="整数表示："><a href="#整数表示：" class="headerlink" title="整数表示："></a>整数表示：</h3><h4 id="无符号数的编码-Unsigned"><a href="#无符号数的编码-Unsigned" class="headerlink" title="无符号数的编码(Unsigned):"></a>无符号数的编码(Unsigned):</h4><p>采用一个向量表示vector X &#x3D; [a1, a2, a3….];</p><p>使用转换函数B2U后得到：</p><p>对于<strong>B2U([1011]) &#x3D; 1*2^3 + 1 * 2^1 + 1 * 2^0;</strong></p><p>无符号数 的值就是数值为1的单位的对应长度之和。</p><h4 id="有符号数的编码："><a href="#有符号数的编码：" class="headerlink" title="有符号数的编码："></a>有符号数的编码：</h4><p><strong>采用补码的形式</strong>。</p><p>对于向量X &#x3D; [a1, a2, a3….]</p><p><strong>最高位称为符号位，</strong>B2U的转换规则如下：</p><p><strong>对于B2T([1011]) :  value &#x3D; 1 * (-2^3) + 1 * 2^1 + 1 * 2^0</strong></p><p><strong>最高位为1或0保证了结果一定为负数或正数。</strong> </p><h4 id="最值："><a href="#最值：" class="headerlink" title="最值："></a>最值：</h4><ul><li><h5 id="最大值："><a href="#最大值：" class="headerlink" title="最大值："></a>最大值：</h5></li></ul><p>字长为N的无符号数：最大值即为2^N - 1;</p><p>字长为N的有符号数：最大值即为2^(N-1) - 1；</p><ul><li><h5 id="最小值："><a href="#最小值：" class="headerlink" title="最小值："></a>最小值：</h5></li></ul><p>有符号的最小值：形式均为：10000..000 </p><p><strong>注意-1的补码表示与无符号的最大值相同：11111….1111;</strong></p><h4 id="有符号数与无符号数之间的转换："><a href="#有符号数与无符号数之间的转换：" class="headerlink" title="有符号数与无符号数之间的转换："></a>有符号数与无符号数之间的转换：</h4><p>结合转换函数的公式得到：</p><p><strong>B2U - B2T &#x3D; x1 * 2^w(w为位数)</strong></p><p>所以得到转换公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">对于T2U(x)：</span><br><span class="line"></span><br><span class="line">    value = x + 2^w ( x &lt; 0);</span><br><span class="line"></span><br><span class="line">    value = x (x &gt;= 0)</span><br><span class="line"></span><br><span class="line">对于U2T(x)：</span><br><span class="line"></span><br><span class="line">    value = x - 2^w(x &gt; T的最大值)</span><br><span class="line"></span><br><span class="line">    value = x (x &lt;= T的最大值)</span><br></pre></td></tr></table></figure><p><strong>注意：隐式转换：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = -1;</span><br><span class="line">unsigned int b = 0;</span><br><span class="line">if(a &lt; b)&#123;</span><br><span class="line">   return true;</span><br><span class="line">&#125;</span><br><span class="line">else return false;</span><br></pre></td></tr></table></figure><p>得到结果是false。就是因为有符号数在于无符号数进行比较的时候，自动转换为无符号数。</p><h4 id="数据类型之间的转换："><a href="#数据类型之间的转换：" class="headerlink" title="数据类型之间的转换："></a>数据类型之间的转换：</h4><h5 id="较小转变为较大："><a href="#较小转变为较大：" class="headerlink" title="较小转变为较大："></a>较小转变为较大：</h5><p>   1，对于无符号数，在前位补0即可；</p><p>   2，<strong>对于有符号数，在前部补最高位的数字：</strong></p><p>如：B2T[a1, a2, a3, ….., an]；</p><p>转变为B2T[a1, a1…. a1, a1, a2, …, an];</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">证明如下：</span><br><span class="line"></span><br><span class="line">对于B2T(W)与B2T(W+1):</span><br><span class="line"></span><br><span class="line">两者作差即可得到：-a1 * 2^(W + 1) + a1 * 2^(W) + a1 * 2^(W) = 0;</span><br><span class="line"></span><br><span class="line">类推可得：B2T(W+1) = B2T(W+2)........</span><br><span class="line"></span><br><span class="line">最终得到B2T(W) = B2T(W + k)；</span><br></pre></td></tr></table></figure><h5 id="较大转变为较小："><a href="#较大转变为较小：" class="headerlink" title="较大转变为较小：,"></a>较大转变为较小：,</h5><p>1，会造成数据的阶段，多的位数被舍弃；(类似于基于二进制的取模运算)</p><p>2，对于有符号数，采取的措施是：</p><p>先将数位看成无符号数进行截断后，在将剩余的位数转换为有符号数。</p><h3 id="整数运算："><a href="#整数运算：" class="headerlink" title="整数运算："></a>整数运算：</h3><h3 id="浮点数："><a href="#浮点数：" class="headerlink" title="浮点数："></a>浮点数：</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS61B学习</title>
      <link href="/2025/09/01/CS61B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/09/01/CS61B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>Project 2：Gitlet</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
