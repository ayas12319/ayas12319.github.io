# 基本定义：
设R是一个关系，X，Y为属性集的任意子集，Y函数依赖于X，记作：
X --> Y。
**即关系R中的每一个X值，都恰好对应一个Y值。**
也即：如果 r 中的两个元组在 X 上的值相同，那么它们在 Y 上的值也必然相同。

若关系R在函数依赖集S下是合法的，我们称R满足于S。
函数依赖用于对于合法关系集合施加约束，若R上的关系均满足S，则称S在R上成立。

那么如何寻找最小规模的函数依赖集？

# 平凡和非平凡的函数依赖：
一个最明显的缩小规模的方法即是消除平凡函数依赖：
## 基本定义：
若一个函数依赖一定会被满足，则说明它是**平凡的**；
若一个函数依赖是平凡的，当且仅当右侧属性集是左侧的子集：
例如：
```
{S#, B#}-->{S#}
```
## 性质：
一些函数依赖可以推导出其他的一些函数依赖。
例如：
```
{S#, P#} --> {CITY, QTY}
则可以得到：
{S#, P#} --> {QTY}
{S#, P#} --> {CITY}
```
**定义：**
给定函数依赖集S，所有能被S推导出来的函数依赖的集合，称为S的闭包，记作：$S^+$

**Armstrong公理：**
1，自反律：若$B \subseteq A$，则A--> B(即平凡的判断)
2，增广律：如果A ---> B,则有AC ---> BC
3，传递律：如果A --> B, B--->C, 则有：A --> C
以上规则具有完备性和可靠性。

**函数依赖集的闭包：**
**推导的规则：**
1，自确定律：A ---> A
2，分解律：若A--> BC, 则有：A ---> B  A ---> C
3，合并律：如果A --> B, B--->C, 则有：A --> BC
4，复合律：如果 A → B 且 C → D，则 AC → BD

**计算在S下求Z的闭包$Z^+$的解法：**
1，令ans = Z
2，重复以下，直至不再变化：
对于S中的每一个函数依赖X --> Y：若$X \subseteq ans$，则将Y加入ans
3，最终即得到$Z^+$

**判断某个函数依赖是否成立，即可以看该属性的闭包中是否含有该属性。**

**属性集闭包的重要推论：**
1，函数依赖X --> Y能由S推导出，当且仅当Y是X在S下闭包的子集
2，K是超键，当且仅当K的闭包恰好等于所有属性的集合。

**判断一函数是否是候选键：**
1，该函数能函数确定所有属性（满足超键性）
2，其任何真子集都不满足超键性。

## 覆盖和等价：
**若S1中所蕴含的每个函数依赖都包含在S2的闭包中，则称S2是S1的覆盖。**
若S1与S2之间互为覆盖，则称两者等价。

## 最小函数依赖集：
满足以下条件，即称函数依赖集S是不可分的（最小覆盖）：
- 每个函数依赖的右侧只包含单个属性
- 每个函数依赖的左侧没有冗余属性
- S中没有冗余的函数依赖。

### 最小函数依赖集的求解：
1，右部最小化，将右部的多重属性全部拆为单个。
2，消除冗余依赖，即去除某个函数依赖，看看剩余部分能否将其推导出来。
3，左部最小化：检查左边是否有多余属性，方法同上。
4，合并左部相同的依赖
