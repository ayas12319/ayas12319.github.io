规范化即是将一组关系减少冗余的形式

# 无损分解：
分解的过程实质上是一种投影操作
如何确保分解过程中信息不丢失：
 **Heath定理：**
 给定关系R，其属性集为：A, B, C。若R满足函数依赖A ---> B，则R就等于{A, B} 与{A, C}之间的自然连接。
 即：**若分解基于某个函数依赖A ---> B， 则需要保证A在两个子模式中均有出现。**
# 第一范式：
**表中每一个属性值都是不可再分的原子值**
即不允许包含，集合，数组，列表等多值结构
即遵循原则：
尽可能使得属性相互独立，从而更新某个属性时，不会对其他属性造成影响。

# 第二范式：
**一个关系满足第二范式，当且仅当它满足第一范式，且每一个非键字段都完全函数依赖于主键（而不是部分依赖于主键的真子集）**
**解决方式：**
将对应依赖于某个主键的属性集合拆解成一个表
给定关系R如下：
R（A, B, C, D），主键为（A, B)
函数依赖A --> D
将原表分解成两个投影R1, R1：
R1(A, D)； R2（A , B, C）

# 第三范式：
**即在满足第二范式的基础上，所有的非键字段都不互相依赖。**
**解决方法：**
将依赖的两个字段，作为一张表：
给定关系R如下：R(A, B, C)，主键为 A，函数依赖：B → C。
将 R 分解为两个投影 R1 和 R2：
R1(B, C)，主键为 B；R2(A, B)，主键为 A

# 保持函数依赖：
若期望分解后的关系式相互独立的：
对其中任何一个关系的更新可以无需考虑另一个关系。
这种理念，即是”依赖保持“。
分解过程中，不应有任何函数依赖跨越两个关系变量。
关系变量 R 的投影 R1 和 R2 是**独立的**，当且仅当满足以下两个条件：
- （依赖保持）R中的每一个函数依赖，都是R1与R2中函数依赖的逻辑推论。
- R1和R2的公共属性至少构成其中一个关系的候选键。

# BCNF范式：
**若一个关系满足BCNF范式，当且仅当每一个不平凡，左部不可约的函数依赖的决定因素都是候选键。**
即在依赖图中，所有的箭头都是从候选键中指出。
当满足以下条件，3NF与BCNF等价：
- 存在>=2个候选键
- 这些候选键都是复合键
- 它们至少有一个公共属性。

# 规范化一般步骤：
1，1NF到2NF：消除部分依赖
2，从2NF到3NF：消除非主属性间的依赖
3，从3NF到BCNF：消除决定因素不是候选键的函数依赖。
4，从BCNF到4NF：消除不是函数依赖的多值依赖
5，从4NF到5NF：

# 反规范化：
**规范化的缺点：**
- 导致性能下降——产生过多小表。
- 分解导致语义约束被破坏

# 判断属于第几范式：
1，先求出候选键
2，判断非主属性是否完全函数依赖于候选键：
- 不是：则为第一范式；
- 是；则继续判断；
3，判断是否满足传递函数依赖：
即若有依赖：A ---> B,  B ---> C, 则可以得到：A ---> C.
若有依赖做到以上依赖的反推，则说明不满足传递函数依赖。
【类似于AB ---> C,  C ---> B也是不可以的】
- 是：则为第二范式
- 不是：继续判断
4，判断表头是否都为候选键：
- 是：为BCNF
- 不是：为3NF








