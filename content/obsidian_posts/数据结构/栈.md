# 链表模拟栈实现：

```c++
template <class Type> LStack;
template <class Type> node{
   friend class LStack<Type>;
   private:
     Type data;
     node<Type>* link;
   public:
     node(Type d=0, node<Type>* next=nullptr):
           data(d), link(next){}
}

template <class Type> class LStack{
   private:
      node<Type>* top;
   public:
      LStack(): top(nullptr)
      ~LStack(){ MakeEmpty();}
      void push(Type &x){
         top = new node<Type>(x, top);
         assert(top != nullptr);
      }
      bool pop(Type &x){
         if(isEmpty()) retrun false;
         node<Type>* p = top;
         x = p->data;
         top = top->link;
         delete p;
         return true;
      }
      void MakeEmpty(){
        node<Type>* p;
        while(top != nullptr){
          p = top;
          top = top->link;
          delete p;
        }
      }
      bool isEmpty();
      int GetSize() const;
      
}

```

# 表达式求值：

## 表达式的三种表示方法：

中缀表示： 操作数 操作符 操作数  
前缀表示： 操作符 操作数 操作数  
后缀表示： 操作数 操作数 操作符

## 表达式求值：

### 利用后缀表达式求值：

顺序扫描表达式每一项：

- 若该项是操作数：则将其压栈；
- 若该项是操作符：则从栈中连续退出两个操作数A, B，形成运算指令B A，并将计算结果重新压栈。

### 将中缀表示转化为后缀表示：

栈是用来存储运算符顺序的。  
1，遍历处理各个字符：  
对于操作数：直接加入输出序列中；  
左括号：直接压入运算符栈；  
右括号：弹出栈中的运算符到输出序列中，直到遇到(，弹出( 但不输出；  
一般运算符：

- 若当前运算符优先级 > 栈顶优先级，将当前运算符压入栈；
- 若当前运算符优先级**小于等于**栈顶优先级，弹出栈顶到输出。