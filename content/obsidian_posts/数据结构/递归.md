
# 如何利用栈将递归算法转化为非递归算法：

类型：

- 单向递归和尾递归可直接通过迭代实现；
- 其他情形需要借助栈实现。

## hannoi问题：

递归写法：

```c++
void towers(int n, int A, int B, int C){
   if(n == 1) cout << "A -> C"<<endl;
   else{
     towers(n - 1, A, C, B);
     cout<< "A -> C"<<endl;
     towers(n-1, B, A, C);
   }
}
```

非递归改写：

```c++
//step1: 处理n-1个盘子从A移到B，辅助为C
void step1(int& n, int& A, int& B, int& C){
//转化为处理n-1个盘子的问题，目标为B， 辅助为C
   n--;
   int temp = C;
   C = B;
   B = temp;
}

void step2(int& n, int& A, int& B, int& C){
   //已完成step1，从B出发，目标C，辅助A
   n--;
   int temp = A;
   A = B;
   B = temp;
}

void towers(int n, int A, int B, int C){
   stack s;
   initstack(&s, n);
   bool done = false;
   while(!done){
      while(n > 1){
        //压入当前状态
        push(&s, n, A, B, C);
        //更新参数：
        step1(&n, &A, &B, &C);
      }
      //n=1时，直接从A移到C：
      cout << ~~~~~~<<endl;
      //逐步恢复栈中状态
      if(!isEmpty(&s)){
        //弹出上一层状态
        pop(&s, &n, &A, &B, &C);
        //恢复到上级的n个盘子的移动问题
        cout << "Move disk from A to C"<<endl;
        step2(&n, &A, &B, &C);
      }else{
         //栈为空，则结束
         done = true;
      }
   }
   free(s.data);
}

```

## 尾递归：

递归调用递归过程中的最后一条语句。  
例如：

```
int fact(int n, long long acc=1){
   if(n == 1) return acc;
   return fact(n-1, n * acc);
}
```

**尾递归可以直接使用迭代法转化为非递归算法：**  
例如对于上式中的阶乘问题：

```
int fact(int n){
   int f = 1;
   for(int i = 2; i <= n; ++i){
      f = n * f;
   }
   return f;
}
```

## 线性递归问题：

**线性递归的一般形式：**  
![image-28.png](image-28.png)  
即一般形式为：

```
proc(int n){
  stms1(n);
  if(eval(n)){
     proc(n-1);
     stms2(n);
  }
  else
    stms3(n);
}
```

**其等价的非递归形式为：**

```
proc(int n){
  int k = n + 1;
  do{
    k --;
    stms1(k);
  }while(eval(k));
  stms3(k);
  while(k < n){
    k ++;
    stms2(k);
  }
}
```

## 单向递归：

单向递归可以有多个递归调用，但这些调用都必须处于递归调用过程的最后。  
例如斐波那契数列的递归算法：

```
int fib(int n){
  if(n <= 1) return n;
  else return fib(n-1) + fib(n-2);
}
```

单项递归用栈转化为递归算法：  
dfs八皇后的非递归算法：

```
void dfs_with_stack(){
  stack<pair<int, int>> s;
  //首先压入初始状态
  s.push({1, 0});
  while(!s.empty()){
    auto [row, col] = s.top();
    s.pop();
    if(col > 0) map[row][col] = 0;
    int next_col = col + 1;
    if(next_col <= 8){
       s.push({row, next_col});
       if(valid(row, next_col)){
         map[row][next_col] = 1;
         if(row == 8){
            cnt++;
            output();
            cout<<endl;
         }
         else s.push({row + 1, 0});
       }
    }
  }
}
```