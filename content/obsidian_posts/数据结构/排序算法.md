# 基本概念：

## 排序的稳定性：

若序列中关键字值相等的值，排序前后的相对顺序保持不变，则称这种排序算法是稳定的，否则即为不稳定。  
例如对于：  
待排序列：34 12 34‘ 08 96  
稳定：08 12 34 34‘ 96  
不稳定：08 12 34’ 34 96

# 排序的基本方法：

## 插入排序：

**基本思想：**  
默认已完成元素已排好序，依次从未完成序列中提取新元素，将其与前面的元素进行比较，若前面的元素比他大，就将元素向前移动，直至前面的元素小于等于该元素。  
**算法实现：**

```c++
void insertSort(int a[], int l, int r)
{
   int i, j;
   int t;
   for(i = l + 1; i <= r; ++i){
      t = a[i];  //保存当前要插入的值
      //从后往前，依次将较大的元素后移一位
      for(j = i - 1; j >= 0 && t < a[j]; j--){
          a[j+1] = a[j];
      }
      a[j+1] = t;
   }
}
```

**性能分析：**  
时间复杂度：O()  
空间开销：O(1)  
稳定性：稳定  
适用于节点数较少的场景。

## 冒泡排序：

**基本思想：**  
依次比较两个相邻的元素，若顺序不对，则两者交换。重复操作直至全部被排好序。  
**算法实现：**

```c++
void bubbleSort(int a[], int l, int r)
{
   for(int i = l ; i < r; ++i){
     for(int j = l ; j < r - i + 1; ++j){
        if(a[j] > a[j + 1]) swap(a[j], a[j + 1]);
     }
   }
}
```

**性能分析：**  
时间复杂度：O()  
空间开销：O(1)  
稳定性：稳定。

## 选择排序：

**基本思想：**  
首先选出键值最小的项，将其与第一个项交换位置。然后选出第二小的项，将其与第二个项交换位置，重复进行......  
**算法实现：**

```c++
void SelectSort(int a[], int l, int r){
  int i, j, min;
  for(i = l; i < r; ++i){
     for(min = i, j =i + 1; j <= r; ++j){
        if(a[j] < a[min]) min = j;
     }
     swap(a[min], a[i]);
  }
}
```

性能分析：  
时间复杂度：O()  
稳定性：不稳定。

## 归并排序：

**基本思想：**  
即利用分治思想。设出一个分界点mid。设出一个新数组temp临时存放结果。假设原数组mid的右半部分均大于左半部分。从左右两边向中间开始遍历，较小的先放入temp数组中。  
归并排序主要包括自顶向下和自底向上两种解决方法。

### 自顶向下归并排序：

**基本步骤：**  
先递归排序左半部分；  
再递归排序右半部分；  
最后将两个已排好序的子数组合并。  
**算法实现：**

```c++
//merge原子操作
void merge(int a[], int l, int m, int r){
  int i, j;
  static int temp[N];
  //左半部分升序，右半部分降序
  for(i = m + 1; i > l; --i) temp[i-1] = a[i-1];
  for(j = m; j < r; ++j) temp[r + m - j] = a[j+1];
  //逐个比较，进行升序合并。
  for(int k = l; k <= r; ++k){
      if(temp[j] < temp[i]) a[k] = temp[j--];
      else a[k] = temp[i++];
  }
}
//Merge实现操作
void MergeSort(int a[], int l, int r){
   if(r <= l) return;
   int m = (l + r)/2;
   MergeSort(a, l, m);
   MergrSort(a, m+1, r);
   merge(a, l, m, r);
}
```

### 自底向上归并排序：

```c++

void merge(int a[], int left, int mid, int right){
   int n = right - left + 1;
   int* temp = new int[n];
   
   int i = left;
   int j = mid + 1;
   int k = 0;
   
   while(i <= mid && j <= right){
     if(a[i] <= a[j]){
         temp[k++] = a[i++];
     }
     else temp[k++] = a[j++];
   }
   while(i <= mid) temp[k++] = a[i++];
   while(j <= right) temp[k++] = a[j++];
   
   for(i = left, k = 0; i <= right; i++, k++){
      a[i] = temp[k];
   }
   delete[] temp;
}

void mergeSort(int a[], int l, int r){
   if(l >= r) return;
   for(int m = 1; m <= r - l; m = m + m){  //步长，逐渐倍增符合二分思想
     for(int i = l; i <= r - m; i += m + m){
        int mid = i + m - 1;  //第一个数组结束位置
        int right = min(i + m + m - 1, r);   //第二个数组右边界
        merge(a, i, mid, right);
     }
   }
}
```

**时间复杂度：**

- 平均：O(NlogN)
- 最坏：O(NlogN)  
    **归并排序是稳定的**

**一轮循环操作结果求解：**  
对于内部已经分为若干个有序子序列的，即采用自底向上归并排序方法：  
设一组初始记录关键字序列（【25，50】，【15，35】，【80，85】，【20，40】，【36，70】），其中含有5个长度为2 的有序子表，则用归并排序的方法对该记录关键字序列进行一趟归并后的结果为？  
——解：  
mergeL1与L2：  
25与15比较——选择15；25与35比较——选择25；35与50比较——选择35.............  
.................  
mergeL1与L2，L3与L4后，L5剩余：  
得到：15，25，35，50，20，40，80，85，36，70。

## 快速排序：

```c++
void QuickSort(int a[], int l, int r){
  if(l >= r) return;
  int mid = (a[l] + a[r]) / 2;
  int i = l - 1;
  int j = r + 1;
  while(i < j){
    do i++; while(a[i] < mid);
    do j--; while(a[j] > mid);
    if(i < j) swap(a[i], a[j]);
  } 
  QuickSort(a, l, j);
  QuickSort(a, j + 1, r);
}
```

**时间复杂度：**

- 平均：O(NlogN)
- 最坏：O()  
    **快速排序是稳定的**  
    **实际执行：采用挖坑填数法——解决首轮循环状态问题**  
    设一组初始关键字记录为（20， 15， 14， 18， 21， 36， 40， 10），则以20为基准记录的一趟快速排序结束后的结果为：  
    解：  
    由于20为基准，故i = 0 的位置设置为坑。j从7位置开始，10小于20，故填充到坑中——  
    10，15，14，18，21，36，40，20【此时位置7为一处坑】  
    i从左开始，遍历到21大于20，，将21填到坑中——  
    10，15，14，18，20，36，40，21  
    再将j继续左移，直至与i相遇

## 希尔排序：

思路：

- 先选定一个步长，通过步长对于原数组进行分组，再对分成的每一小组进行插入排序。
- 逐步缩小步长的大小，直至步长为1时，视作原数组结束。

```c++
int gap = n;

while(gap > 1){
  gap /= 2;
  for(int i = 1; i < n - gap + 1; ++i){
    int ed = i;
    int temp = a[ed + gap];
    while(ed >= 1){
      if(temp < a[ed]){
        a[ed + gap] = a[ed];
        ed -= gap;
      }
      else break;
    }
    a[ed + gap] = temp;
  }
}

```

# 各排序方法的每趟特点比较

- 冒泡排序：  
    看数组末尾，每一趟中最大的元素会出现“沉底”现象，逐渐累积到后面；
- 插入排序：  
    第n趟排序后，前n个元素应该是有序的。
- 选择排序：  
    看数组开头，前k个元素是全局最小的且已就绪。
- 希尔排序：  
    以特定间隔分组的子序列各自有序。
- 快速排序：  
    基准中间元素就绪，左右分区区别形成，但内部无序。