# 引入——多项式乘法：
**1，系数乘法：**
 引入两个多项式A, B：
 $A = 5X^2 + 3X + 7$
$B = 7X^2 + 2X + 1$
计算C = A * B的结果，需要O($N^2$)的时间复杂度：
即对于多项式C的系数满足$c_i = \sum _{j = 0}^i a_jb_{i - j}$.
那么如果优化算法，使之达到O(NlogN)的时间复杂度

**2，点值乘法：**
给定n个点可以确认n-1次函数曲线的系数点值。
例如：
（1）：将$x_0, x_1, x_2$的点代入，求出对应两个曲线的函数A(x). B(x)。
（2）：相乘。计算C($x_i$) = A($x_i$) * B($x_i$)。
（3）：将计算得到的Cx带入插值即可。

# 傅里叶变换：

# 快速傅里叶变换(FFT)：
将求点值和系数的运算优化到O(NlogN)的复杂度。核心是借助复数的运算，实现递归分治。
## 由系数求点值（正变换）：
设A(x)的系数为($a_0,a_1, a_2....a_{n-1}$)。则有：
$$
\begin{aligned}
A(x) &= a_0 + a_1x + a_2x^2 + ... + a_{n-1}x^{n-1} \\ % 使用 \\ 换行
& = (a_0+ a_2x^{2}+... + a_{n-2}x^{n-2}) -------偶项 \\
& + (a_{1}+ a_{3}x^{2} + ... + a_{n-1}x^{n-2}) -----奇项
\end{aligned}
$$

设$A_{1}(x)= a_{0}+ a_{2}x+ a_{4}x^{2} + ... + a_{n-2} x^{\frac{n}{2} - 1}$
$A_{2}(x) = a_{1}+ a_{3}x+ a_{5}x^{2} + ... + a_{n-1} x^{\frac{n}{2} - 1}$
**所以有A(x) = $A_{1}(x^2)+ A_{2}(x^{2})x$**
设单位根为：$w_{n}^{k}= cos\frac{2\pi k}{n} + isin\frac{2\pi k}{n}$。——将单位圆n等分，取第k份。
 FFT要求 $n = 2^{b}, b为自然数$：
    1，周期性：$w_{n}^{k + n} = w_{n}^{k}$
    2，对称性：$w_{n}^{k + \frac{n}{2}} = -w_{n}^{k}$。
    3，折半性：$w_{n}^{2k} = w_{\frac{n}{2}}^{k}$
 将$w_{n}^ {k}$（k < $\frac{n}{2}$）代入得到:
 $$
 \begin{aligned}
 A(w_{n}^{k}) &= A_{1}(w_{n}^{2k}) + A_{2}(w_{n}^{2k})w_{n}^{k} \\
  &= A_{1}\left(w_{\frac{n}{2}}^{k}\right)+  A_{1}\left(w_{\frac{n}{2}}^{k}\right)w_{n}^{k}
\end{aligned}
 $$
 将$w_{n}^{k+\frac{n}{2}}$代入得到：
 $$
  \begin{aligned}
 A(w_{n}^{k + \frac{n}{2}}) &= A_{1}(w_{n}^{2k+n}) + A_{2}(w_{n}^{2k+n})w_{n}^{k+\frac{n}{2}} \\
  &= A_{1}\left(w_{\frac{n}{2}}^{k}\right)-  A_{2}\left(w_{\frac{n}{2}}^{k}\right)w_{n}^{k}
\end{aligned}
$$
 
 这样分析时间复杂度得到：
 **T(N) = 2T(N/2) + O(N)，所以得到T(N) = O(NlogN)。**
 算法实现如下：
 ```c++
 void FFT(complex A[], int n){
    if(n == 1) return;
    complex A1[n/2], A2[n/2];
    for(int i = 0; i < n/2; ++i){  //分奇偶项组合
       A1[i] = A[i * 2];
       A2[i] = A[i * 2 + 1];
    }
    FFT(A1, n/2), FFT(A2, n/2);
    complex w1({cos(2 * PI/n), sin(2 * PI/n)});  //基本旋转因子，在单位圆上旋转1/n圈的角度。
    complex wk({1, 0});   //当前旋转因子
    for(int i = 0; i < n/2; ++i){ //结合公式，同时计算前后两半部分。
       A[i] = A1[i] + A2[i] * wk;
       A[i + n/2] = A1[i] - A2[i] * wk;
       wk = wk * w1;
    }
 }
 
 ```
 ![](https://cdn.jsdelivr.net/gh/ayas12319/picture-bed@main/img/20260219013954871.png)
 由上可知，一共有logN层，每层的计算量均为O(logN),故时间复杂度为O(NlogN).
## 由点值求系数(逆变换):
 设A(x) = $a_{0}+ a_{1}x + ... + a_{n-1}x^{n-1}$。代入$w_{n}^{0}, w_{n}^{1}, w_{n}^{2}...$，得到点值为：$y_{0},y_{1}, y_{2}, ...y^{n-1}$。
 其中$y_{i}$ = $\sum\limits_{j=0}^{n-1}a_{j}(w_{n}^{i})^{j}$
 将点值反看作系数得到新多项式：
$$
B(x) = y_{0} + y_{1}x + y_{2}x^{2} +... y_{n-1}x^{n-1}
$$
 将n个单位根的倒数代入B(x)得到新点值为$z_{i}$
 所以得到：
 $z_{k} = \sum\limits_{i=0}^{n-1}y_{i}(w_{n}^{-k})^{k} = \sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{n-1}a_{j}(w_{n}^{i})^{j}(w_{n}^{-k})^{i} = \sum\limits_{j=0}^{n-1}a_{j}\sum\limits_{i=0}^{n-1}(w_{n}^{j-k})^{i}$
 所以得到：
 - 当j = k时，内层的和等于n
 - 当j 不等于k时，和 = $\frac{(w_{n}^{j-k})^{n} - 1}{w_{n}^{j-k} - 1} = \frac{(w_{n}^{n})^{j-k} - 1}{w_{n}^{j-k} - 1} = 0$
所以$z_{k}$ = n$a_{k}$，即$a_{k} = \frac{z_{k}}{n}$

**NOTE:**
$w_{n}^{k} = \cos \theta + i \sin \theta$，代入单位根的倒数得到：
$\frac{1}{w_{n}^{k}} = \frac{1}{\cos \theta + i \sin \theta} = cos \theta - i sin \theta = w_{n}^{-k}$
**即逆代入单位根的倒数等价于将虚部变为负号。**

代码实现：
```c++
void IFFT(complex A[], int n){
  if(n == 1) return;
  complex A1[n/2], A2[n/2];
  for(int i = 0; i < n/2; ++i){
     A1[i] = A[i * 2], A2[i] = A[i*2 + 1];  
  }
  FFT(A1, n/2);
  FFT(A2, n/2);
  complex w1({cos(2*PI/n), -sin(2*PI/n)});
  complex wk({1, 0});
  for(int i=0; i<n/2; ++i){
    A[i] = A1[i] + A2[i]*wk;
    A[i + n/2] = A1[i] - A2[i] * wk;
    wk = wk*w1;
  }
}
```
最后结果再/n即可。
# 多项式乘法：
$w_{n}^{1} = cos\frac{2\pi}{n} + isin\frac{2\pi}{n}, w_{n}^{k} = (w_{n}^{1})^{k}$
当k< n/2时，$A(w_{n}^{k}) = A1\left(w_{\frac{n}{2}}^{k}\right)+ A2(w_{\frac{n}{2}}^{k})w_{n}^{k}$
后半部分：$A(w_{n}^{k}) = A1\left(w_{\frac{n}{2}}^{k}\right)- A2(w_{\frac{n}{2}}^{k})w_{n}^{k}$
代码实现：
```c++
void FFT(complex A[], int n, int op){  ///op=1为正变换，op=-1为负变换
  if(n == 1) return;
  complex A1[n/2], A2[n/2];
  for(int i = 0; i < n/2; ++i){
    A1[i] = A[i * 2];
    A2[i] = A[i * 2 + 1];
  }
  FFT(A1, n/2, op);
  FFT(A2, n/2, op);
  complex w1({cos(2 * PI / n), sin(2 * PI / n) * op});  //乘以op决定正逆变换
  complex w2({1, 0});
  for(int i = 0; i < n/2; ++i){
    A[i] = A1[i] + A2[i] * wk;
    A[i + n/2] = A1[i] - A2[i] * wk;
    wk = wk * w1;
  }
}

int main(){
  int n, m;
  cin >> n >> m;
  for(int i = 0; i <= n; ++i) cin>>A[i];
  for(int i = 0; i <= m; ++i) cin>>B[i];
  for(m = n+m; n = 1; n <= m; n<<=1);  //找到第一个大于等于n + m的2的幂，因为是最高次分别为n和m的多项式相乘，同时FFT需要长度是2的幂
  FFT(A, n, 1); FFT(B, n, 1);   //正变换——将系数转换为点值。
  for(int i = 0; i < n; ++i) A[i] = A[i] * B[i];  //点值表示下，多项式相乘的结果就是点值相乘
  FFT(A, n, -1);  //求结果的点值反推出结果多项式的系数
  for(int i = 0; i <= m; ++i){
    cout<<A[i].real / n;
  }
return 0;
}
```
# 迭代实现FFT算法：
## 位逆序变换：
### 基本概念：
在正常递归过程中，我们反复按照奇偶性来进行区分组别：
- 第一层：按最低位分开
- 第二层：按次低位分开
- .............
例如原序列为：
0 (000),  1(001), 2(010), 3(011),  4(100), 5(101), 6(110), 7(111)
那么排序过程如下：
![](https://cdn.jsdelivr.net/gh/ayas12319/picture-bed@main/img/20260219014052705.png)
即按照递归的顺序，提前预处理迭代的顺序，进行蝶形运算。
## 实现：
设n = $2^{k}$，k表示二进制数的长度。设R【x】表示长度为k的二进制数x翻转后的数。
为了避免一个个的求解，可以通过R【n/2】来推到求解R【n】。
**基本思想：**
设x = ($b_{k-1}b_{k-2}...b_{1}b_{0}$)，那么x/2 = (0$b_{k-1}b_{k-2}...b_{1}$)
同时有R【x/2】= $(b_{1}b_{2}...b_{k-2}b_{k-1}0)_{2}$。
那么使得R【x/2】右移一位得到：$(0b_{1}b_{2}...b_{k-2}b_{k-1})_{2}$
- 那么当$b_{0}$ = 0时，此时R【x】 = R【x/2】 >> 1;
- 当$b_{0}$ = 1时，此时R【x】 = (R【x/2】>>1) + $2^{k-1}$
那么综合上述公式得到：
$$
R[X] = \frac{R[\frac{x}{2}]}{2} + [x \& 1] * \frac{n}{2}
$$
迭代实现FFT算法代码：
```c++
void FFT(complex A[], int n, int op){
  change(A, n);   //执行位逆序变换
  for(int m = 2; m <= n; m <<=1){  //枚举块宽,对应从底向上的合并过程
    complex w1({cos(2 * PI/m), sin(2 * PI/m) * op});
    for(int i = 0; i < n; i += m){ //遍历每一个块
      complex wk({1, 0});   //初始化当前的旋转因子
      for(int j = 0; j < m/2; ++j){
        complex x = A[i + j], y = A[i + j + m/2] * wk;
        A[i+j] = x+y;  //合并
        A[i + j + m/2] = x-y;  //对称位置合并
        wk = wk * w1;
      }
    }
  }
}
```