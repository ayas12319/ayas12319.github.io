# 引入：
对于之前使用的斐波那契堆，红黑树，优先队列，B树，他们对于N个元素的排序操作，其时间复杂度的下界均为O(NlogN)。
考虑类比[[排序算法]]中的计数排序，通过利用附加属性，在限定的范围内对于有限个元素进行排序，以实现O(N+K)的线性时间复杂度。

下面介绍几种判断元素X是否存在于动态集合S中的方法：
# 基本方法：
## 直接寻址：
维护一个u位的位向量数组，判断一个元素是否在集合中出现，即看对应位置的元素是否为1。这样的INSERT，DELETE，MEMBER操作时间复杂度均为O(1), 但是SEARCH操作为O(N)
## 叠加的二叉树结构：
想要知道整个数组中是否存在某个元素。
- 使得位向量的每一个元素都作为二叉树的一个叶子结点，使用0或1来表示对应的位置索引是否存在。
   例如对于数组\[2,3,4,5,7\]，叶子层设置为：

| A     | 0   | 0   | 1   | 1   | 1   | 1   | 0   | 1   | 0   |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| INDEX | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
向上的每一个结点均为两个子节点的逻辑或结果。
- 查找最小元素：从树根开始总是走最左边包含1的路径直至叶节点。
- 查找最大元素：从树根开始总是走最右边包含1的路径直至叶节点。
- 查找x的后继：从x的叶节点开始，向上走，直至从左侧进入一个结点，同时其右孩子z为1。从z开始查找子树的最小元素。
**时间复杂度为O(lgu)**
```c++
层级 3 (根) :                     [1]
                                 /   \
层级 2 :                      [1]     [1]
                            /   \    /   \
层级 1 :                  [1]   [0] [1]   [1]
                         / \    / \ / \   / \
层级 0 (原始位向量):      0   1  0  0 1 0  1   1
                        0   1  2  3 4 5  6   7  (索引)
```
## 叠加一颗高度恒定的树
对于给定大小范围<= u的元素列表。假设全域的大小u = $2^{2k}$，对于位向量叠加一个高度为$\sqrt u$的树。
故深度为1的$\sqrt u$个结点定义了一个summary数组，用来表示其子数组中是否存在1。
对于summary\[i\]对应的子数组，称为第i个**簇**。
对于位A\[x\]，其出现在簇号为$\frac{x}{\sqrt u}$的 簇中。
- 插入操作：置A\[x\]与summary\[$\frac{x}{\sqrt u}$\]为1，时间复杂度为O(1)。
- 查询最值：现在summary数组中查询最左or最右位置，再在对应簇中查询最左or最右位置。
- 查找x的后继or前驱：先在x的簇内部向右or向左查找。若无结果，令i = $\frac{x}{\sqrt u}$,在summary数组中向右or向左查找。
- 删除操作：将A\[x\]置为0，再将summary\[$\frac{x}{\sqrt u}$\]重新改为簇中元素的逻辑或结果。
操作至多对两个簇进行查找，即时间复杂度最多为O($\sqrt u$)。
