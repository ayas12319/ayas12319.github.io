#  基本定义：
 给定一个规模为N的问题，将这个问题划分为规模为N / b的问题子集a，同时满足b严格大于1，
 再递归地解决每一个问题子集a。
 故基本的时间复杂度为：$T(N) = a * T(N / b) + union 子问题的时间$
# 凸包 (convex hull) 问题：
即是在一个点集中找出一个最小的，能够包裹住所有点的最小凸多边形。
## 凸包的表示：
**使用凸包边界上的点的序列，采用双向链表的形式来进行表示。采用顺时针的顺序来枚举点。**
## 朴素解法：
对于任意两个点进行连接，若形成的直线满足其余所有顶点均在一侧，则该直线是凸包的一部分。
**复杂度分析：**
假设现有n个点，共有O($n^2$)个线段，对于每一个线段的test函数复杂度为O(n)。
故现在的时间复杂度为O($n^3$)。
**伪代码：**
-  对x坐标进行排序；
- 输入集合S
- 将左半部分坐标集与右半部分坐标集分开
- 计算ch(A)与ch(B)
- 联合

## 如何联合：
### 朴素方法：
若要连接两个凸包集，即是找到这两个凸包集的上切线和下切线：
![[算法设计与分析/MIT6.046/image-5.png]]

## 上下切线的寻找：
 - 朴素方法：遍历所有可能的线段，即O($N^2$)的复杂度。 
### 双指法：
**设y(a, b)即为a，b两点连线在分界线上的截距大小。**
伪代码：
```c++
l = 1;
j = 1;
while(y(i, j + 1) > y(i, j) or y(i - 1, j) > y(i, j)):
    if(y(i, j + 1) > y(i, j)){
           j = j + 1 (mod V);
        }
    else i = i - 1 (mod P);
return (ai, bj) as uppen 切线
```
**时间复杂度：**
1，分成两半：O(N)。
2，递归计算左右凸包：2 * O(N / 2)
3，合并两个凸包：O(N)。
故时间复杂度为O(NlogN)。

  