# 机器指令

## 指令的一般格式

指令由操作码和地址码组成。

### 操作码

操作码用来指明该指令用来执行的操作。操作码的位数表示了可以执行的条数。  
操作码的长度可以固定也可以为动态变化：  
（1）长度固定：  
用于指令较长的情形。  
（2）长度可变：  
操作码分散在指令的各个字段中。  
**扩展操作码技术：**  
![image|616x686](https://img2024.cnblogs.com/blog/3707689/202511/3707689-20251130210129109-854410078.png)  
操作码的位数随着地址码的增加而减少  
采取扩展操作码的目的是：增加指令的条数。  
**解读：**  
**1，这种case，就是拿出一个编码作为扩展窗口。**  
目前有一个问题：如何区别图中的三地址指令和二地址指令？  
在三地址指令的处理中：为什么不将操作码的范围设置为0000~1111？  
就是需要使用1111来作为标识字段，当机器识别到第一个字段为1111时，便需要明白这不是三地址指令。  
同理，在二地址指令与一地址指令的边界上，二地址指令只能设置为1111 0000~ 1111 1110.  
注意：由于零地址码之后无后续内容，故边界范围可以设置为....0000 ~ ....1111。  
**2，各个地址码的指令种数：**  
对于三地址码：即种  
对于二地址码：即种  
一地址码同上  
零地址码：即种  
**即：表示的种数由变动的位数来决定。**  
**3，实际上扩展窗口可以由若干个编码方式来表示：**  
例如在上图中，对于二地址编码我们可以使用1111 和1110两种方式来加以识别  
那么此时三地址编码种数：种，三地址表示范围为0000 ~ 1101  
此时二地址编码种数：种  
**例题：**  
假设指令字长为16位，操作数的地址码为6位，指令有零，一，二地址三种格式。  
(1) 设操作码固定，若零地址指令有P种，一地址指令有Q种，则二地址指令最多有几种？  
解：由于操作码固定，操作码的位数为16 - 6 - 6 = 4.故共有种编码。  
所以二地址指令为 16 - Q - P种。  
(2)采用扩展操作码技术，若二地址指令有X种，零地址指令有Y种，则一地址指令最多有几种？  
解：已知二地址码有x种，则一地址码最多有种—(OP字段还剩余的表示方法数 -下一字段的变化总数。)  
设一地址码实际有Z种，则零，一地址码之间的扩展窗口数为：$(2^4-x)_2^6 - Z故零地址码最多有：[(2^4-x)*2^6 - Z] _2^6种所以得到：[(2^4-x)_2^6 - Z] * 2^6 = Y$，故可解得X。

### 地址码

地址码用来指出该指令源操作数的地址，结果的地址，下一条指令的地址。

#### 四地址指令：

格式如：  
![image|605x142](https://img2024.cnblogs.com/blog/3707689/202511/3707689-20251130224314685-1818338752.png)  
**OP为操作码，A1,A2为第一，二操作数的地址，A3为结果地址，A4为下一条指令地址**。  
指令含义：(A1) OP (A2) -> A3  
表示范围：  
如图中所示，地址码可访问的范围即为  
完成成一次四地址指令，需要访存4次(取指令1次，取两个操作数2次，存放结果1次)  
又由于程序计数器既可以存放当前指令地址，也可以计数，故可以自动生成下一条指令地址。  
即得到三地址执行。

#### 三地址指令：

同样完成一条三地址指令，需要访存4次。  
由于每次的运算结果没必要均存入内存之中，可以暂时存放在CPU中的寄存器(如：ACC)中，  
故可得到二地址指令。

#### 二地址指令：

可完成的操作为： (A1) OP (A2)->A1/A2  
A1既代表源操作数的地址，又代表存放结果的地址。  
操作数的存放位置既可以是寄存器，也可以是主存单元。  
此时完成一条指令仍需访存4次；若将结果放在ACC中，则可访存3次。  
若将一个操作数的地址隐于ACC种，则可实现一地址指令。

#### 一地址指令：

可完成操作： (ACC) OP (A1) -> ACC  
即另一个操作数隐藏在运算器中的ACC中。  
完成一条指令的访存次数为2次（取指令和取一个操作数）

#### 零地址指令：

用于一些特殊指令：  
空操作，停机，子程序返回(REPT),中断返回(IRET)  
零地址指令的操作数来自于“栈顶和次栈顶”。

## 指令字长：

通常指令字长取8的整数倍。

# 操作数类型和操作类型：

## 操作数类型：

- 地址：  
    可以看作一个无符号整数
- 数字：  
    即包括定点数，浮点数，和十进制数等等
- 字符：  
    常见采用ASCII编码
- 逻辑数据：  
    即进行逻辑运算——与，或，非时的逻辑操作数

## 数据在存储器中的存储方式：

数据一般存放在寄存器或存储器中，寄存器的位数即可反映字长。  
数据在存放时遵循**边界对准**的要求，不能恰好填充时，往往需要填充一个或多个空白字节。  
在数据的访问时，按照 字节，半字，字，双字进行访问。

## 操作类型：

基本机器操作方式如下：

- **数据传送**：
    
- **算术逻辑运算**：
    
- **移位**：
    
- **转移**：  
    （1）无条件转移： JMP X  
    （2）有条件转移： JLE X，根基条件码判断  
    （3）调用与返回：CALL(调用) 与 RETURN(返回)  
    （4）陷阱与陷阱指令：作为一种隐指令，不显式提供  
    **注意：**  
    若采用字节编址，在读取一条指令后，PC值增加的是该条指令对应的字节数；  
    采用字编址同理，增加的是对应的字数。
    
- **输入输出**：
    

# 寻址方式：

寻址方式即确定本条指令的数据地址以及下一条将要执行的指令的地址的方法。  
寻址方式分为：指令寻址和数据寻址两种。

## 指令寻址：

指令寻址分为**顺序寻址**和**跳跃寻址**两种  
顺序寻址：  
通过程序计数器PC自动加1，自动生成下一条指令的地址。  
跳跃寻址：  
通过JMP指令实现

## 数据寻址：

指令的一般形式：  
| 操作码 | 寻址特征 | 形式地址A |  
操作数的真实地址由寻址特征和形式地址A共同决定。

### 立即寻址：

**特点**：  
形式地址A中存放的就是操作数。数据采用补码形式存放。  
格式： | OP | # | A |

### 直接寻址：

**特点：**  
形式地址A中存放的是操作数的地址

### 隐含寻址：

**特点：**  
指令中不显式地给出操作数地址，操作数的地址隐含在操作码或某个寄存器中。  
例如：一地址指令的加法实现。加数就放在ACC中

### 间接寻址：

**特点：**  
形式地址中给出的是操作数地址的存放单元的地址。  
优点：  
1，扩大了操作数的范围：  
存储指令的字长即相当于指令字长。  
2，便于子程序的返回机制。  
缺点：  
需要进行多次访存。

### 寄存器寻址：

**特点：**  
地址码字段存放寄存器编号，操作数直接存放在寄存器中。故无需访存操作。

### 寄存器间接寻址：

**特点：**  
地址码字段存放寄存器编号，寄存器中存放操作数的地址。  
**适合于编写循环程序：**  
例如循环对数组元素进行操作，对于i个不同的数据，若采用其他寻址方式，则需准备i条指令。但若使用寄存器间接寻址，则寄存器编号不变，只改变寄存器内容即可。

### 基址寻址：

**特点：**  
需要设定一个基址寄存器BR。  
**操作数真实地址 = 形式地址A + BR中的内容。**  
可以分为隐式和显式两种，主要区别在于是否能够指定基址寄存器的编号。  
常用例子：  
BR中存放一个数组的首地址，A中存放偏移量。通过基址寻址来访问数组元素

### 变址寻址：

**特点：**  
**有效地址 = 形式地址 + 变址寄存器中的内容。**  
变址寄存器中的内容可以改变，但形式地址中的内容不能改变。  
例子：  
形式地址中存放数组首地址，变址寄存器中存放偏移量。

### 相对寻址：

**特点：**  
有效地址 = 形式地址 + (PC)即当前指令地址  
形式地址A成为偏移量，可正可负，采用补码表示。  
示例：  
设相对寻址的转移指令占3个字节。若PC当前值为240，要求转移到290，则二三地址中存放的是什么？  
解：  
取出该指令后，（PC）= 243，则偏移量 = 290 - 243 = 47.

### 堆栈寻址:

**执行顺序：**

- 执行入栈动作：  
    更新指示的断点，和存储的单元内容；再执行栈顶单元 - 1。
- 执行出栈操作：  
    先执行栈顶元素+1，再恢复内容，调回断点位置。


# RISC技术：
## 设计思想与目标：
**1，设计思想：**
通过简化硬件来换取更高的执行效率与更有的流水线性能。
**2，主要目标：**
- 实现单周期指令。
- 充分利用流水线技术，提高指令吞吐率。
- 使得硬件设计精简。

## 与CISC的比较：
1，RISC更能充分利用VLSI芯片的面积
2，RISC能提高计算机的运算速度
3，指令数，指令格式，寻址方式均较少。
4，便于实现指令流水——单个指令精简。
5，便于设计